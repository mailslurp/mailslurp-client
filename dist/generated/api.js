"use strict";
/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * MailSlurp API
 * MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.   ## Resources - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://www.mailslurp.com/docs/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * OpenAPI spec version: 44260f6d0ae6501a22c82e73d2775a799f3d4a81
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MailServerControllerApiFetchParamCreator = exports.InboxControllerApi = exports.InboxControllerApiFactory = exports.InboxControllerApiFp = exports.InboxControllerApiFetchParamCreator = exports.GroupControllerApi = exports.GroupControllerApiFactory = exports.GroupControllerApiFp = exports.GroupControllerApiFetchParamCreator = exports.FormControllerApi = exports.FormControllerApiFactory = exports.FormControllerApiFp = exports.FormControllerApiFetchParamCreator = exports.EmailControllerApi = exports.EmailControllerApiFactory = exports.EmailControllerApiFp = exports.EmailControllerApiFetchParamCreator = exports.DomainControllerApi = exports.DomainControllerApiFactory = exports.DomainControllerApiFp = exports.DomainControllerApiFetchParamCreator = exports.ContactControllerApi = exports.ContactControllerApiFactory = exports.ContactControllerApiFp = exports.ContactControllerApiFetchParamCreator = exports.CommonActionsControllerApi = exports.CommonActionsControllerApiFactory = exports.CommonActionsControllerApiFp = exports.CommonActionsControllerApiFetchParamCreator = exports.BulkActionsControllerApi = exports.BulkActionsControllerApiFactory = exports.BulkActionsControllerApiFp = exports.BulkActionsControllerApiFetchParamCreator = exports.AttachmentControllerApi = exports.AttachmentControllerApiFactory = exports.AttachmentControllerApiFp = exports.AttachmentControllerApiFetchParamCreator = exports.AliasControllerApi = exports.AliasControllerApiFactory = exports.AliasControllerApiFp = exports.AliasControllerApiFetchParamCreator = exports.WebhookTestRequest = exports.WebhookDto = exports.WaitForConditions = exports.TemplateVariable = exports.SendEmailOptions = exports.MatchOption = exports.RequiredError = exports.BaseAPI = exports.COLLECTION_FORMATS = void 0;
exports.WebhookControllerApi = exports.WebhookControllerApiFactory = exports.WebhookControllerApiFp = exports.WebhookControllerApiFetchParamCreator = exports.WaitForControllerApi = exports.WaitForControllerApiFactory = exports.WaitForControllerApiFp = exports.WaitForControllerApiFetchParamCreator = exports.TemplateControllerApi = exports.TemplateControllerApiFactory = exports.TemplateControllerApiFp = exports.TemplateControllerApiFetchParamCreator = exports.SentEmailsControllerApi = exports.SentEmailsControllerApiFactory = exports.SentEmailsControllerApiFp = exports.SentEmailsControllerApiFetchParamCreator = exports.MailServerControllerApi = exports.MailServerControllerApiFactory = exports.MailServerControllerApiFp = void 0;
var url = __importStar(require("url"));
var portableFetch = __importStar(require("portable-fetch"));
var BASE_PATH = 'https://api.mailslurp.com'.replace(/\/+$/, '');
/**
 *
 * @export
 */
exports.COLLECTION_FORMATS = {
    csv: ',',
    ssv: ' ',
    tsv: '\t',
    pipes: '|',
};
/**
 *
 * @export
 * @class BaseAPI
 */
var BaseAPI = /** @class */ (function () {
    function BaseAPI(configuration, basePath, fetch) {
        if (basePath === void 0) { basePath = BASE_PATH; }
        if (fetch === void 0) { fetch = portableFetch; }
        this.basePath = basePath;
        this.fetch = fetch;
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
    return BaseAPI;
}());
exports.BaseAPI = BaseAPI;
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
var RequiredError = /** @class */ (function (_super) {
    __extends(RequiredError, _super);
    function RequiredError(field, msg) {
        var _this = _super.call(this, msg) || this;
        _this.field = field;
        return _this;
    }
    return RequiredError;
}(Error));
exports.RequiredError = RequiredError;
/**
 * @export
 * @namespace MatchOption
 */
var MatchOption;
(function (MatchOption) {
    /**
     * @export
     * @enum {string}
     */
    var FieldEnum;
    (function (FieldEnum) {
        FieldEnum[FieldEnum["SUBJECT"] = 'SUBJECT'] = "SUBJECT";
        FieldEnum[FieldEnum["TO"] = 'TO'] = "TO";
        FieldEnum[FieldEnum["BCC"] = 'BCC'] = "BCC";
        FieldEnum[FieldEnum["CC"] = 'CC'] = "CC";
        FieldEnum[FieldEnum["FROM"] = 'FROM'] = "FROM";
    })(FieldEnum = MatchOption.FieldEnum || (MatchOption.FieldEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    var ShouldEnum;
    (function (ShouldEnum) {
        ShouldEnum[ShouldEnum["CONTAIN"] = 'CONTAIN'] = "CONTAIN";
        ShouldEnum[ShouldEnum["EQUAL"] = 'EQUAL'] = "EQUAL";
    })(ShouldEnum = MatchOption.ShouldEnum || (MatchOption.ShouldEnum = {}));
})(MatchOption = exports.MatchOption || (exports.MatchOption = {}));
/**
 * @export
 * @namespace SendEmailOptions
 */
var SendEmailOptions;
(function (SendEmailOptions) {
    /**
     * @export
     * @enum {string}
     */
    var SendStrategyEnum;
    (function (SendStrategyEnum) {
        SendStrategyEnum[SendStrategyEnum["SINGLEMESSAGE"] = 'SINGLE_MESSAGE'] = "SINGLEMESSAGE";
    })(SendStrategyEnum = SendEmailOptions.SendStrategyEnum || (SendEmailOptions.SendStrategyEnum = {}));
})(SendEmailOptions = exports.SendEmailOptions || (exports.SendEmailOptions = {}));
/**
 * @export
 * @namespace TemplateVariable
 */
var TemplateVariable;
(function (TemplateVariable) {
    /**
     * @export
     * @enum {string}
     */
    var VariableTypeEnum;
    (function (VariableTypeEnum) {
        VariableTypeEnum[VariableTypeEnum["STRING"] = 'STRING'] = "STRING";
    })(VariableTypeEnum = TemplateVariable.VariableTypeEnum || (TemplateVariable.VariableTypeEnum = {}));
})(TemplateVariable = exports.TemplateVariable || (exports.TemplateVariable = {}));
/**
 * @export
 * @namespace WaitForConditions
 */
var WaitForConditions;
(function (WaitForConditions) {
    /**
     * @export
     * @enum {string}
     */
    var CountTypeEnum;
    (function (CountTypeEnum) {
        CountTypeEnum[CountTypeEnum["EXACTLY"] = 'EXACTLY'] = "EXACTLY";
        CountTypeEnum[CountTypeEnum["ATLEAST"] = 'ATLEAST'] = "ATLEAST";
    })(CountTypeEnum = WaitForConditions.CountTypeEnum || (WaitForConditions.CountTypeEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    var SortDirectionEnum;
    (function (SortDirectionEnum) {
        SortDirectionEnum[SortDirectionEnum["ASC"] = 'ASC'] = "ASC";
        SortDirectionEnum[SortDirectionEnum["DESC"] = 'DESC'] = "DESC";
    })(SortDirectionEnum = WaitForConditions.SortDirectionEnum || (WaitForConditions.SortDirectionEnum = {}));
})(WaitForConditions = exports.WaitForConditions || (exports.WaitForConditions = {}));
/**
 * @export
 * @namespace WebhookDto
 */
var WebhookDto;
(function (WebhookDto) {
    /**
     * @export
     * @enum {string}
     */
    var MethodEnum;
    (function (MethodEnum) {
        MethodEnum[MethodEnum["GET"] = 'GET'] = "GET";
        MethodEnum[MethodEnum["HEAD"] = 'HEAD'] = "HEAD";
        MethodEnum[MethodEnum["POST"] = 'POST'] = "POST";
        MethodEnum[MethodEnum["PUT"] = 'PUT'] = "PUT";
        MethodEnum[MethodEnum["PATCH"] = 'PATCH'] = "PATCH";
        MethodEnum[MethodEnum["DELETE"] = 'DELETE'] = "DELETE";
        MethodEnum[MethodEnum["OPTIONS"] = 'OPTIONS'] = "OPTIONS";
        MethodEnum[MethodEnum["TRACE"] = 'TRACE'] = "TRACE";
    })(MethodEnum = WebhookDto.MethodEnum || (WebhookDto.MethodEnum = {}));
})(WebhookDto = exports.WebhookDto || (exports.WebhookDto = {}));
/**
 * @export
 * @namespace WebhookTestRequest
 */
var WebhookTestRequest;
(function (WebhookTestRequest) {
    /**
     * @export
     * @enum {string}
     */
    var MethodEnum;
    (function (MethodEnum) {
        MethodEnum[MethodEnum["GET"] = 'GET'] = "GET";
        MethodEnum[MethodEnum["HEAD"] = 'HEAD'] = "HEAD";
        MethodEnum[MethodEnum["POST"] = 'POST'] = "POST";
        MethodEnum[MethodEnum["PUT"] = 'PUT'] = "PUT";
        MethodEnum[MethodEnum["PATCH"] = 'PATCH'] = "PATCH";
        MethodEnum[MethodEnum["DELETE"] = 'DELETE'] = "DELETE";
        MethodEnum[MethodEnum["OPTIONS"] = 'OPTIONS'] = "OPTIONS";
        MethodEnum[MethodEnum["TRACE"] = 'TRACE'] = "TRACE";
    })(MethodEnum = WebhookTestRequest.MethodEnum || (WebhookTestRequest.MethodEnum = {}));
})(WebhookTestRequest = exports.WebhookTestRequest || (exports.WebhookTestRequest = {}));
/**
 * AliasControllerApi - fetch parameter creator
 * @export
 */
var AliasControllerApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Create an email alias belonging to a user ID. To create anonymous aliases use the `createAnonymousAlias` method.
         * @summary Create an email alias
         * @param {CreateOwnedAliasOptions} createOwnedAliasOptions createOwnedAliasOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlias: function (createOwnedAliasOptions, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'createOwnedAliasOptions' is not null or undefined
            if (createOwnedAliasOptions === null ||
                createOwnedAliasOptions === undefined) {
                throw new RequiredError('createOwnedAliasOptions', 'Required parameter createOwnedAliasOptions was null or undefined when calling createAlias.');
            }
            var localVarPath = "/aliases";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'CreateOwnedAliasOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(createOwnedAliasOptions || {})
                : createOwnedAliasOptions || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create an anonymous email alias
         * @param {CreateAnonymousAliasOptions} createAnonymousAliasOptions createAnonymousAliasOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnonymousAlias: function (createAnonymousAliasOptions, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'createAnonymousAliasOptions' is not null or undefined
            if (createAnonymousAliasOptions === null ||
                createAnonymousAliasOptions === undefined) {
                throw new RequiredError('createAnonymousAliasOptions', 'Required parameter createAnonymousAliasOptions was null or undefined when calling createAnonymousAlias.');
            }
            var localVarPath = "/aliases/anonymous";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'CreateAnonymousAliasOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(createAnonymousAliasOptions || {})
                : createAnonymousAliasOptions || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete an owned alias
         * @param {string} aliasId aliasId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlias: function (aliasId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'aliasId' is not null or undefined
            if (aliasId === null || aliasId === undefined) {
                throw new RequiredError('aliasId', 'Required parameter aliasId was null or undefined when calling deleteAlias.');
            }
            var localVarPath = "/aliases/{aliasId}".replace("{" + 'aliasId' + "}", encodeURIComponent(String(aliasId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an email alias by ID
         * @summary Get an email alias
         * @param {string} aliasId aliasId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlias: function (aliasId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'aliasId' is not null or undefined
            if (aliasId === null || aliasId === undefined) {
                throw new RequiredError('aliasId', 'Required parameter aliasId was null or undefined when calling getAlias.');
            }
            var localVarPath = "/aliases/{aliasId}".replace("{" + 'aliasId' + "}", encodeURIComponent(String(aliasId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all email aliases in paginated form
         * @summary Get all email aliases
         * @param {number} [page] Optional page index in alias list pagination
         * @param {number} [size] Optional page size in alias list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAliases: function (page, size, sort, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/aliases";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update an owned alias
         * @param {string} aliasId aliasId
         * @param {CreateOwnedAliasOptions} createOwnedAliasOptions createOwnedAliasOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlias: function (aliasId, createOwnedAliasOptions, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'aliasId' is not null or undefined
            if (aliasId === null || aliasId === undefined) {
                throw new RequiredError('aliasId', 'Required parameter aliasId was null or undefined when calling updateAlias.');
            }
            // verify required parameter 'createOwnedAliasOptions' is not null or undefined
            if (createOwnedAliasOptions === null ||
                createOwnedAliasOptions === undefined) {
                throw new RequiredError('createOwnedAliasOptions', 'Required parameter createOwnedAliasOptions was null or undefined when calling updateAlias.');
            }
            var localVarPath = "/aliases/{aliasId}".replace("{" + 'aliasId' + "}", encodeURIComponent(String(aliasId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'CreateOwnedAliasOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(createOwnedAliasOptions || {})
                : createOwnedAliasOptions || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.AliasControllerApiFetchParamCreator = AliasControllerApiFetchParamCreator;
/**
 * AliasControllerApi - functional programming interface
 * @export
 */
var AliasControllerApiFp = function (configuration) {
    return {
        /**
         * Create an email alias belonging to a user ID. To create anonymous aliases use the `createAnonymousAlias` method.
         * @summary Create an email alias
         * @param {CreateOwnedAliasOptions} createOwnedAliasOptions createOwnedAliasOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlias: function (createOwnedAliasOptions, options) {
            var localVarFetchArgs = exports.AliasControllerApiFetchParamCreator(configuration).createAlias(createOwnedAliasOptions, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Create an anonymous email alias
         * @param {CreateAnonymousAliasOptions} createAnonymousAliasOptions createAnonymousAliasOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnonymousAlias: function (createAnonymousAliasOptions, options) {
            var localVarFetchArgs = exports.AliasControllerApiFetchParamCreator(configuration).createAnonymousAlias(createAnonymousAliasOptions, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete an owned alias
         * @param {string} aliasId aliasId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlias: function (aliasId, options) {
            var localVarFetchArgs = exports.AliasControllerApiFetchParamCreator(configuration).deleteAlias(aliasId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get an email alias by ID
         * @summary Get an email alias
         * @param {string} aliasId aliasId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlias: function (aliasId, options) {
            var localVarFetchArgs = exports.AliasControllerApiFetchParamCreator(configuration).getAlias(aliasId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all email aliases in paginated form
         * @summary Get all email aliases
         * @param {number} [page] Optional page index in alias list pagination
         * @param {number} [size] Optional page size in alias list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAliases: function (page, size, sort, options) {
            var localVarFetchArgs = exports.AliasControllerApiFetchParamCreator(configuration).getAliases(page, size, sort, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update an owned alias
         * @param {string} aliasId aliasId
         * @param {CreateOwnedAliasOptions} createOwnedAliasOptions createOwnedAliasOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlias: function (aliasId, createOwnedAliasOptions, options) {
            var localVarFetchArgs = exports.AliasControllerApiFetchParamCreator(configuration).updateAlias(aliasId, createOwnedAliasOptions, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.AliasControllerApiFp = AliasControllerApiFp;
/**
 * AliasControllerApi - factory interface
 * @export
 */
var AliasControllerApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Create an email alias belonging to a user ID. To create anonymous aliases use the `createAnonymousAlias` method.
         * @summary Create an email alias
         * @param {CreateOwnedAliasOptions} createOwnedAliasOptions createOwnedAliasOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlias: function (createOwnedAliasOptions, options) {
            return exports.AliasControllerApiFp(configuration).createAlias(createOwnedAliasOptions, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create an anonymous email alias
         * @param {CreateAnonymousAliasOptions} createAnonymousAliasOptions createAnonymousAliasOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnonymousAlias: function (createAnonymousAliasOptions, options) {
            return exports.AliasControllerApiFp(configuration).createAnonymousAlias(createAnonymousAliasOptions, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete an owned alias
         * @param {string} aliasId aliasId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlias: function (aliasId, options) {
            return exports.AliasControllerApiFp(configuration).deleteAlias(aliasId, options)(fetch, basePath);
        },
        /**
         * Get an email alias by ID
         * @summary Get an email alias
         * @param {string} aliasId aliasId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlias: function (aliasId, options) {
            return exports.AliasControllerApiFp(configuration).getAlias(aliasId, options)(fetch, basePath);
        },
        /**
         * Get all email aliases in paginated form
         * @summary Get all email aliases
         * @param {number} [page] Optional page index in alias list pagination
         * @param {number} [size] Optional page size in alias list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAliases: function (page, size, sort, options) {
            return exports.AliasControllerApiFp(configuration).getAliases(page, size, sort, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an owned alias
         * @param {string} aliasId aliasId
         * @param {CreateOwnedAliasOptions} createOwnedAliasOptions createOwnedAliasOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlias: function (aliasId, createOwnedAliasOptions, options) {
            return exports.AliasControllerApiFp(configuration).updateAlias(aliasId, createOwnedAliasOptions, options)(fetch, basePath);
        },
    };
};
exports.AliasControllerApiFactory = AliasControllerApiFactory;
/**
 * AliasControllerApi - object-oriented interface
 * @export
 * @class AliasControllerApi
 * @extends {BaseAPI}
 */
var AliasControllerApi = /** @class */ (function (_super) {
    __extends(AliasControllerApi, _super);
    function AliasControllerApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Create an email alias belonging to a user ID. To create anonymous aliases use the `createAnonymousAlias` method.
     * @summary Create an email alias
     * @param {CreateOwnedAliasOptions} createOwnedAliasOptions createOwnedAliasOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasControllerApi
     */
    AliasControllerApi.prototype.createAlias = function (createOwnedAliasOptions, options) {
        return exports.AliasControllerApiFp(this.configuration).createAlias(createOwnedAliasOptions, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Create an anonymous email alias
     * @param {CreateAnonymousAliasOptions} createAnonymousAliasOptions createAnonymousAliasOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasControllerApi
     */
    AliasControllerApi.prototype.createAnonymousAlias = function (createAnonymousAliasOptions, options) {
        return exports.AliasControllerApiFp(this.configuration).createAnonymousAlias(createAnonymousAliasOptions, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Delete an owned alias
     * @param {string} aliasId aliasId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasControllerApi
     */
    AliasControllerApi.prototype.deleteAlias = function (aliasId, options) {
        return exports.AliasControllerApiFp(this.configuration).deleteAlias(aliasId, options)(this.fetch, this.basePath);
    };
    /**
     * Get an email alias by ID
     * @summary Get an email alias
     * @param {string} aliasId aliasId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasControllerApi
     */
    AliasControllerApi.prototype.getAlias = function (aliasId, options) {
        return exports.AliasControllerApiFp(this.configuration).getAlias(aliasId, options)(this.fetch, this.basePath);
    };
    /**
     * Get all email aliases in paginated form
     * @summary Get all email aliases
     * @param {number} [page] Optional page index in alias list pagination
     * @param {number} [size] Optional page size in alias list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasControllerApi
     */
    AliasControllerApi.prototype.getAliases = function (page, size, sort, options) {
        return exports.AliasControllerApiFp(this.configuration).getAliases(page, size, sort, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Update an owned alias
     * @param {string} aliasId aliasId
     * @param {CreateOwnedAliasOptions} createOwnedAliasOptions createOwnedAliasOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasControllerApi
     */
    AliasControllerApi.prototype.updateAlias = function (aliasId, createOwnedAliasOptions, options) {
        return exports.AliasControllerApiFp(this.configuration).updateAlias(aliasId, createOwnedAliasOptions, options)(this.fetch, this.basePath);
    };
    return AliasControllerApi;
}(BaseAPI));
exports.AliasControllerApi = AliasControllerApi;
/**
 * AttachmentControllerApi - fetch parameter creator
 * @export
 */
var AttachmentControllerApiFetchParamCreator = function (configuration) {
    return {
        /**
         * When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment IDs. For legacy reasons the ID is returned in an array. Only a single ID is ever returned at one time. To send the attachments pass a list of attachment IDs with SendEmailOptions when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
         * @summary Upload an attachment for sending using base64 file encoding. Returns an array whose first element is the ID of the uploaded attachment.
         * @param {UploadAttachmentOptions} uploadOptions uploadOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAttachment: function (uploadOptions, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'uploadOptions' is not null or undefined
            if (uploadOptions === null || uploadOptions === undefined) {
                throw new RequiredError('uploadOptions', 'Required parameter uploadOptions was null or undefined when calling uploadAttachment.');
            }
            var localVarPath = "/attachments";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'UploadAttachmentOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(uploadOptions || {})
                : uploadOptions || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment IDs. For legacy reasons the ID is returned in an array. Only a single ID is ever returned at one time. To send the attachments pass a list of attachment IDs with SendEmailOptions when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
         * @summary Upload an attachment for sending using file byte stream input octet stream. Returns an array whose first element is the ID of the uploaded attachment.
         * @param {string} [string] Optional contentType for file. For instance &#x60;application/pdf&#x60;
         * @param {string} [byteArray] Byte array request body
         * @param {string} [filename] Optional filename to save upload with
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAttachmentBytes: function (string, byteArray, filename, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/attachments/bytes";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (string !== undefined) {
                localVarQueryParameter['String'] = string;
            }
            if (filename !== undefined) {
                localVarQueryParameter['filename'] = filename;
            }
            localVarHeaderParameter['Content-Type'] =
                'application/octet-stream';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'string' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(byteArray || {})
                : byteArray || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment IDs. For legacy reasons the ID is returned in an array. Only a single ID is ever returned at one time. To send the attachments pass a list of attachment IDs with SendEmailOptions when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
         * @summary Upload an attachment for sending using a Multipart Form request. Returns an array whose first element is the ID of the uploaded attachment.
         * @param {any} file file
         * @param {string} [contentType] Optional content type of attachment
         * @param {string} [contentTypeHeader] Optional content type header of attachment
         * @param {string} [filename] Optional name of file
         * @param {string} [xFilename] Optional content type header of attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMultipartForm: function (file, contentType, contentTypeHeader, filename, xFilename, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file', 'Required parameter file was null or undefined when calling uploadMultipartForm.');
            }
            var localVarPath = "/attachments/multipart";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            var localVarFormParams = new url.URLSearchParams();
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (contentType !== undefined) {
                localVarQueryParameter['contentType'] = contentType;
            }
            if (filename !== undefined) {
                localVarQueryParameter['filename'] = filename;
            }
            if (xFilename !== undefined) {
                localVarQueryParameter['x-filename'] = xFilename;
            }
            if (file !== undefined) {
                localVarFormParams.set('file', file);
            }
            localVarHeaderParameter['Content-Type'] =
                'application/x-www-form-urlencoded';
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();
            var needsSerialization = 'string' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(contentTypeHeader || {})
                : contentTypeHeader || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.AttachmentControllerApiFetchParamCreator = AttachmentControllerApiFetchParamCreator;
/**
 * AttachmentControllerApi - functional programming interface
 * @export
 */
var AttachmentControllerApiFp = function (configuration) {
    return {
        /**
         * When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment IDs. For legacy reasons the ID is returned in an array. Only a single ID is ever returned at one time. To send the attachments pass a list of attachment IDs with SendEmailOptions when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
         * @summary Upload an attachment for sending using base64 file encoding. Returns an array whose first element is the ID of the uploaded attachment.
         * @param {UploadAttachmentOptions} uploadOptions uploadOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAttachment: function (uploadOptions, options) {
            var localVarFetchArgs = exports.AttachmentControllerApiFetchParamCreator(configuration).uploadAttachment(uploadOptions, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment IDs. For legacy reasons the ID is returned in an array. Only a single ID is ever returned at one time. To send the attachments pass a list of attachment IDs with SendEmailOptions when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
         * @summary Upload an attachment for sending using file byte stream input octet stream. Returns an array whose first element is the ID of the uploaded attachment.
         * @param {string} [string] Optional contentType for file. For instance &#x60;application/pdf&#x60;
         * @param {string} [byteArray] Byte array request body
         * @param {string} [filename] Optional filename to save upload with
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAttachmentBytes: function (string, byteArray, filename, options) {
            var localVarFetchArgs = exports.AttachmentControllerApiFetchParamCreator(configuration).uploadAttachmentBytes(string, byteArray, filename, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment IDs. For legacy reasons the ID is returned in an array. Only a single ID is ever returned at one time. To send the attachments pass a list of attachment IDs with SendEmailOptions when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
         * @summary Upload an attachment for sending using a Multipart Form request. Returns an array whose first element is the ID of the uploaded attachment.
         * @param {any} file file
         * @param {string} [contentType] Optional content type of attachment
         * @param {string} [contentTypeHeader] Optional content type header of attachment
         * @param {string} [filename] Optional name of file
         * @param {string} [xFilename] Optional content type header of attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMultipartForm: function (file, contentType, contentTypeHeader, filename, xFilename, options) {
            var localVarFetchArgs = exports.AttachmentControllerApiFetchParamCreator(configuration).uploadMultipartForm(file, contentType, contentTypeHeader, filename, xFilename, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.AttachmentControllerApiFp = AttachmentControllerApiFp;
/**
 * AttachmentControllerApi - factory interface
 * @export
 */
var AttachmentControllerApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment IDs. For legacy reasons the ID is returned in an array. Only a single ID is ever returned at one time. To send the attachments pass a list of attachment IDs with SendEmailOptions when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
         * @summary Upload an attachment for sending using base64 file encoding. Returns an array whose first element is the ID of the uploaded attachment.
         * @param {UploadAttachmentOptions} uploadOptions uploadOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAttachment: function (uploadOptions, options) {
            return exports.AttachmentControllerApiFp(configuration).uploadAttachment(uploadOptions, options)(fetch, basePath);
        },
        /**
         * When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment IDs. For legacy reasons the ID is returned in an array. Only a single ID is ever returned at one time. To send the attachments pass a list of attachment IDs with SendEmailOptions when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
         * @summary Upload an attachment for sending using file byte stream input octet stream. Returns an array whose first element is the ID of the uploaded attachment.
         * @param {string} [string] Optional contentType for file. For instance &#x60;application/pdf&#x60;
         * @param {string} [byteArray] Byte array request body
         * @param {string} [filename] Optional filename to save upload with
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAttachmentBytes: function (string, byteArray, filename, options) {
            return exports.AttachmentControllerApiFp(configuration).uploadAttachmentBytes(string, byteArray, filename, options)(fetch, basePath);
        },
        /**
         * When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment IDs. For legacy reasons the ID is returned in an array. Only a single ID is ever returned at one time. To send the attachments pass a list of attachment IDs with SendEmailOptions when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
         * @summary Upload an attachment for sending using a Multipart Form request. Returns an array whose first element is the ID of the uploaded attachment.
         * @param {any} file file
         * @param {string} [contentType] Optional content type of attachment
         * @param {string} [contentTypeHeader] Optional content type header of attachment
         * @param {string} [filename] Optional name of file
         * @param {string} [xFilename] Optional content type header of attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMultipartForm: function (file, contentType, contentTypeHeader, filename, xFilename, options) {
            return exports.AttachmentControllerApiFp(configuration).uploadMultipartForm(file, contentType, contentTypeHeader, filename, xFilename, options)(fetch, basePath);
        },
    };
};
exports.AttachmentControllerApiFactory = AttachmentControllerApiFactory;
/**
 * AttachmentControllerApi - object-oriented interface
 * @export
 * @class AttachmentControllerApi
 * @extends {BaseAPI}
 */
var AttachmentControllerApi = /** @class */ (function (_super) {
    __extends(AttachmentControllerApi, _super);
    function AttachmentControllerApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment IDs. For legacy reasons the ID is returned in an array. Only a single ID is ever returned at one time. To send the attachments pass a list of attachment IDs with SendEmailOptions when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
     * @summary Upload an attachment for sending using base64 file encoding. Returns an array whose first element is the ID of the uploaded attachment.
     * @param {UploadAttachmentOptions} uploadOptions uploadOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentControllerApi
     */
    AttachmentControllerApi.prototype.uploadAttachment = function (uploadOptions, options) {
        return exports.AttachmentControllerApiFp(this.configuration).uploadAttachment(uploadOptions, options)(this.fetch, this.basePath);
    };
    /**
     * When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment IDs. For legacy reasons the ID is returned in an array. Only a single ID is ever returned at one time. To send the attachments pass a list of attachment IDs with SendEmailOptions when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
     * @summary Upload an attachment for sending using file byte stream input octet stream. Returns an array whose first element is the ID of the uploaded attachment.
     * @param {string} [string] Optional contentType for file. For instance &#x60;application/pdf&#x60;
     * @param {string} [byteArray] Byte array request body
     * @param {string} [filename] Optional filename to save upload with
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentControllerApi
     */
    AttachmentControllerApi.prototype.uploadAttachmentBytes = function (string, byteArray, filename, options) {
        return exports.AttachmentControllerApiFp(this.configuration).uploadAttachmentBytes(string, byteArray, filename, options)(this.fetch, this.basePath);
    };
    /**
     * When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment IDs. For legacy reasons the ID is returned in an array. Only a single ID is ever returned at one time. To send the attachments pass a list of attachment IDs with SendEmailOptions when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
     * @summary Upload an attachment for sending using a Multipart Form request. Returns an array whose first element is the ID of the uploaded attachment.
     * @param {any} file file
     * @param {string} [contentType] Optional content type of attachment
     * @param {string} [contentTypeHeader] Optional content type header of attachment
     * @param {string} [filename] Optional name of file
     * @param {string} [xFilename] Optional content type header of attachment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentControllerApi
     */
    AttachmentControllerApi.prototype.uploadMultipartForm = function (file, contentType, contentTypeHeader, filename, xFilename, options) {
        return exports.AttachmentControllerApiFp(this.configuration).uploadMultipartForm(file, contentType, contentTypeHeader, filename, xFilename, options)(this.fetch, this.basePath);
    };
    return AttachmentControllerApi;
}(BaseAPI));
exports.AttachmentControllerApi = AttachmentControllerApi;
/**
 * BulkActionsControllerApi - fetch parameter creator
 * @export
 */
var BulkActionsControllerApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Bulk create Inboxes (email addresses)
         * @param {number} count Number of inboxes to be created in bulk
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkCreateInboxes: function (count, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'count' is not null or undefined
            if (count === null || count === undefined) {
                throw new RequiredError('count', 'Required parameter count was null or undefined when calling bulkCreateInboxes.');
            }
            var localVarPath = "/bulk/inboxes";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Bulk Delete Inboxes
         * @param {Array<string>} ids ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkDeleteInboxes: function (ids, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'ids' is not null or undefined
            if (ids === null || ids === undefined) {
                throw new RequiredError('ids', 'Required parameter ids was null or undefined when calling bulkDeleteInboxes.');
            }
            var localVarPath = "/bulk/inboxes";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'Array&lt;string&gt;' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(ids || {})
                : ids || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Bulk Send Emails
         * @param {BulkSendEmailOptions} bulkSendEmailOptions bulkSendEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkSendEmails: function (bulkSendEmailOptions, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'bulkSendEmailOptions' is not null or undefined
            if (bulkSendEmailOptions === null ||
                bulkSendEmailOptions === undefined) {
                throw new RequiredError('bulkSendEmailOptions', 'Required parameter bulkSendEmailOptions was null or undefined when calling bulkSendEmails.');
            }
            var localVarPath = "/bulk/send";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'BulkSendEmailOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(bulkSendEmailOptions || {})
                : bulkSendEmailOptions || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.BulkActionsControllerApiFetchParamCreator = BulkActionsControllerApiFetchParamCreator;
/**
 * BulkActionsControllerApi - functional programming interface
 * @export
 */
var BulkActionsControllerApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Bulk create Inboxes (email addresses)
         * @param {number} count Number of inboxes to be created in bulk
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkCreateInboxes: function (count, options) {
            var localVarFetchArgs = exports.BulkActionsControllerApiFetchParamCreator(configuration).bulkCreateInboxes(count, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Bulk Delete Inboxes
         * @param {Array<string>} ids ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkDeleteInboxes: function (ids, options) {
            var localVarFetchArgs = exports.BulkActionsControllerApiFetchParamCreator(configuration).bulkDeleteInboxes(ids, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Bulk Send Emails
         * @param {BulkSendEmailOptions} bulkSendEmailOptions bulkSendEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkSendEmails: function (bulkSendEmailOptions, options) {
            var localVarFetchArgs = exports.BulkActionsControllerApiFetchParamCreator(configuration).bulkSendEmails(bulkSendEmailOptions, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.BulkActionsControllerApiFp = BulkActionsControllerApiFp;
/**
 * BulkActionsControllerApi - factory interface
 * @export
 */
var BulkActionsControllerApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Bulk create Inboxes (email addresses)
         * @param {number} count Number of inboxes to be created in bulk
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkCreateInboxes: function (count, options) {
            return exports.BulkActionsControllerApiFp(configuration).bulkCreateInboxes(count, options)(fetch, basePath);
        },
        /**
         *
         * @summary Bulk Delete Inboxes
         * @param {Array<string>} ids ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkDeleteInboxes: function (ids, options) {
            return exports.BulkActionsControllerApiFp(configuration).bulkDeleteInboxes(ids, options)(fetch, basePath);
        },
        /**
         *
         * @summary Bulk Send Emails
         * @param {BulkSendEmailOptions} bulkSendEmailOptions bulkSendEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkSendEmails: function (bulkSendEmailOptions, options) {
            return exports.BulkActionsControllerApiFp(configuration).bulkSendEmails(bulkSendEmailOptions, options)(fetch, basePath);
        },
    };
};
exports.BulkActionsControllerApiFactory = BulkActionsControllerApiFactory;
/**
 * BulkActionsControllerApi - object-oriented interface
 * @export
 * @class BulkActionsControllerApi
 * @extends {BaseAPI}
 */
var BulkActionsControllerApi = /** @class */ (function (_super) {
    __extends(BulkActionsControllerApi, _super);
    function BulkActionsControllerApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Bulk create Inboxes (email addresses)
     * @param {number} count Number of inboxes to be created in bulk
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BulkActionsControllerApi
     */
    BulkActionsControllerApi.prototype.bulkCreateInboxes = function (count, options) {
        return exports.BulkActionsControllerApiFp(this.configuration).bulkCreateInboxes(count, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Bulk Delete Inboxes
     * @param {Array<string>} ids ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BulkActionsControllerApi
     */
    BulkActionsControllerApi.prototype.bulkDeleteInboxes = function (ids, options) {
        return exports.BulkActionsControllerApiFp(this.configuration).bulkDeleteInboxes(ids, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Bulk Send Emails
     * @param {BulkSendEmailOptions} bulkSendEmailOptions bulkSendEmailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BulkActionsControllerApi
     */
    BulkActionsControllerApi.prototype.bulkSendEmails = function (bulkSendEmailOptions, options) {
        return exports.BulkActionsControllerApiFp(this.configuration).bulkSendEmails(bulkSendEmailOptions, options)(this.fetch, this.basePath);
    };
    return BulkActionsControllerApi;
}(BaseAPI));
exports.BulkActionsControllerApi = BulkActionsControllerApi;
/**
 * CommonActionsControllerApi - fetch parameter creator
 * @export
 */
var CommonActionsControllerApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Returns an Inbox with an `id` and an `emailAddress`
         * @summary Create new random inbox
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewEmailAddress: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/createInbox";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an Inbox with an `id` and an `emailAddress`
         * @summary Create new random inbox
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewEmailAddress1: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/newEmailAddress";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes all emails
         * @summary Delete all emails in an inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emptyInbox: function (inboxId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError('inboxId', 'Required parameter inboxId was null or undefined when calling emptyInbox.');
            }
            var localVarPath = "/emptyInbox";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (inboxId !== undefined) {
                localVarQueryParameter['inboxId'] = inboxId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If no senderId or inboxId provided a random email address will be used to send from.
         * @summary Send an email
         * @param {SimpleSendEmailOptions} emailOptions emailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailSimple: function (emailOptions, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'emailOptions' is not null or undefined
            if (emailOptions === null || emailOptions === undefined) {
                throw new RequiredError('emailOptions', 'Required parameter emailOptions was null or undefined when calling sendEmailSimple.');
            }
            var localVarPath = "/sendEmail";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'SimpleSendEmailOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(emailOptions || {})
                : emailOptions || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.CommonActionsControllerApiFetchParamCreator = CommonActionsControllerApiFetchParamCreator;
/**
 * CommonActionsControllerApi - functional programming interface
 * @export
 */
var CommonActionsControllerApiFp = function (configuration) {
    return {
        /**
         * Returns an Inbox with an `id` and an `emailAddress`
         * @summary Create new random inbox
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewEmailAddress: function (options) {
            var localVarFetchArgs = exports.CommonActionsControllerApiFetchParamCreator(configuration).createNewEmailAddress(options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns an Inbox with an `id` and an `emailAddress`
         * @summary Create new random inbox
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewEmailAddress1: function (options) {
            var localVarFetchArgs = exports.CommonActionsControllerApiFetchParamCreator(configuration).createNewEmailAddress1(options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes all emails
         * @summary Delete all emails in an inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emptyInbox: function (inboxId, options) {
            var localVarFetchArgs = exports.CommonActionsControllerApiFetchParamCreator(configuration).emptyInbox(inboxId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * If no senderId or inboxId provided a random email address will be used to send from.
         * @summary Send an email
         * @param {SimpleSendEmailOptions} emailOptions emailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailSimple: function (emailOptions, options) {
            var localVarFetchArgs = exports.CommonActionsControllerApiFetchParamCreator(configuration).sendEmailSimple(emailOptions, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.CommonActionsControllerApiFp = CommonActionsControllerApiFp;
/**
 * CommonActionsControllerApi - factory interface
 * @export
 */
var CommonActionsControllerApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Returns an Inbox with an `id` and an `emailAddress`
         * @summary Create new random inbox
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewEmailAddress: function (options) {
            return exports.CommonActionsControllerApiFp(configuration).createNewEmailAddress(options)(fetch, basePath);
        },
        /**
         * Returns an Inbox with an `id` and an `emailAddress`
         * @summary Create new random inbox
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewEmailAddress1: function (options) {
            return exports.CommonActionsControllerApiFp(configuration).createNewEmailAddress1(options)(fetch, basePath);
        },
        /**
         * Deletes all emails
         * @summary Delete all emails in an inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emptyInbox: function (inboxId, options) {
            return exports.CommonActionsControllerApiFp(configuration).emptyInbox(inboxId, options)(fetch, basePath);
        },
        /**
         * If no senderId or inboxId provided a random email address will be used to send from.
         * @summary Send an email
         * @param {SimpleSendEmailOptions} emailOptions emailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailSimple: function (emailOptions, options) {
            return exports.CommonActionsControllerApiFp(configuration).sendEmailSimple(emailOptions, options)(fetch, basePath);
        },
    };
};
exports.CommonActionsControllerApiFactory = CommonActionsControllerApiFactory;
/**
 * CommonActionsControllerApi - object-oriented interface
 * @export
 * @class CommonActionsControllerApi
 * @extends {BaseAPI}
 */
var CommonActionsControllerApi = /** @class */ (function (_super) {
    __extends(CommonActionsControllerApi, _super);
    function CommonActionsControllerApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns an Inbox with an `id` and an `emailAddress`
     * @summary Create new random inbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonActionsControllerApi
     */
    CommonActionsControllerApi.prototype.createNewEmailAddress = function (options) {
        return exports.CommonActionsControllerApiFp(this.configuration).createNewEmailAddress(options)(this.fetch, this.basePath);
    };
    /**
     * Returns an Inbox with an `id` and an `emailAddress`
     * @summary Create new random inbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonActionsControllerApi
     */
    CommonActionsControllerApi.prototype.createNewEmailAddress1 = function (options) {
        return exports.CommonActionsControllerApiFp(this.configuration).createNewEmailAddress1(options)(this.fetch, this.basePath);
    };
    /**
     * Deletes all emails
     * @summary Delete all emails in an inbox
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonActionsControllerApi
     */
    CommonActionsControllerApi.prototype.emptyInbox = function (inboxId, options) {
        return exports.CommonActionsControllerApiFp(this.configuration).emptyInbox(inboxId, options)(this.fetch, this.basePath);
    };
    /**
     * If no senderId or inboxId provided a random email address will be used to send from.
     * @summary Send an email
     * @param {SimpleSendEmailOptions} emailOptions emailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonActionsControllerApi
     */
    CommonActionsControllerApi.prototype.sendEmailSimple = function (emailOptions, options) {
        return exports.CommonActionsControllerApiFp(this.configuration).sendEmailSimple(emailOptions, options)(this.fetch, this.basePath);
    };
    return CommonActionsControllerApi;
}(BaseAPI));
exports.CommonActionsControllerApi = CommonActionsControllerApi;
/**
 * ContactControllerApi - fetch parameter creator
 * @export
 */
var ContactControllerApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Create a contact
         * @param {CreateContactOptions} createContactOptions createContactOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContact: function (createContactOptions, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'createContactOptions' is not null or undefined
            if (createContactOptions === null ||
                createContactOptions === undefined) {
                throw new RequiredError('createContactOptions', 'Required parameter createContactOptions was null or undefined when calling createContact.');
            }
            var localVarPath = "/contacts";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'CreateContactOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(createContactOptions || {})
                : createContactOptions || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete contact
         * @param {string} contactId contactId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContact: function (contactId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'contactId' is not null or undefined
            if (contactId === null || contactId === undefined) {
                throw new RequiredError('contactId', 'Required parameter contactId was null or undefined when calling deleteContact.');
            }
            var localVarPath = "/contacts/{contactId}".replace("{" + 'contactId' + "}", encodeURIComponent(String(contactId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all contacts
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllContacts: function (page, size, sort, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/contacts/paginated";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get contact
         * @param {string} contactId contactId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContact: function (contactId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'contactId' is not null or undefined
            if (contactId === null || contactId === undefined) {
                throw new RequiredError('contactId', 'Required parameter contactId was null or undefined when calling getContact.');
            }
            var localVarPath = "/contacts/{contactId}".replace("{" + 'contactId' + "}", encodeURIComponent(String(contactId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all contacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContacts: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/contacts";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.ContactControllerApiFetchParamCreator = ContactControllerApiFetchParamCreator;
/**
 * ContactControllerApi - functional programming interface
 * @export
 */
var ContactControllerApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Create a contact
         * @param {CreateContactOptions} createContactOptions createContactOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContact: function (createContactOptions, options) {
            var localVarFetchArgs = exports.ContactControllerApiFetchParamCreator(configuration).createContact(createContactOptions, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete contact
         * @param {string} contactId contactId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContact: function (contactId, options) {
            var localVarFetchArgs = exports.ContactControllerApiFetchParamCreator(configuration).deleteContact(contactId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all contacts
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllContacts: function (page, size, sort, options) {
            var localVarFetchArgs = exports.ContactControllerApiFetchParamCreator(configuration).getAllContacts(page, size, sort, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get contact
         * @param {string} contactId contactId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContact: function (contactId, options) {
            var localVarFetchArgs = exports.ContactControllerApiFetchParamCreator(configuration).getContact(contactId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all contacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContacts: function (options) {
            var localVarFetchArgs = exports.ContactControllerApiFetchParamCreator(configuration).getContacts(options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.ContactControllerApiFp = ContactControllerApiFp;
/**
 * ContactControllerApi - factory interface
 * @export
 */
var ContactControllerApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Create a contact
         * @param {CreateContactOptions} createContactOptions createContactOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContact: function (createContactOptions, options) {
            return exports.ContactControllerApiFp(configuration).createContact(createContactOptions, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete contact
         * @param {string} contactId contactId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContact: function (contactId, options) {
            return exports.ContactControllerApiFp(configuration).deleteContact(contactId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get all contacts
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllContacts: function (page, size, sort, options) {
            return exports.ContactControllerApiFp(configuration).getAllContacts(page, size, sort, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get contact
         * @param {string} contactId contactId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContact: function (contactId, options) {
            return exports.ContactControllerApiFp(configuration).getContact(contactId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get all contacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContacts: function (options) {
            return exports.ContactControllerApiFp(configuration).getContacts(options)(fetch, basePath);
        },
    };
};
exports.ContactControllerApiFactory = ContactControllerApiFactory;
/**
 * ContactControllerApi - object-oriented interface
 * @export
 * @class ContactControllerApi
 * @extends {BaseAPI}
 */
var ContactControllerApi = /** @class */ (function (_super) {
    __extends(ContactControllerApi, _super);
    function ContactControllerApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Create a contact
     * @param {CreateContactOptions} createContactOptions createContactOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactControllerApi
     */
    ContactControllerApi.prototype.createContact = function (createContactOptions, options) {
        return exports.ContactControllerApiFp(this.configuration).createContact(createContactOptions, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Delete contact
     * @param {string} contactId contactId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactControllerApi
     */
    ContactControllerApi.prototype.deleteContact = function (contactId, options) {
        return exports.ContactControllerApiFp(this.configuration).deleteContact(contactId, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Get all contacts
     * @param {number} [page] Optional page index in inbox list pagination
     * @param {number} [size] Optional page size in inbox list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactControllerApi
     */
    ContactControllerApi.prototype.getAllContacts = function (page, size, sort, options) {
        return exports.ContactControllerApiFp(this.configuration).getAllContacts(page, size, sort, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Get contact
     * @param {string} contactId contactId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactControllerApi
     */
    ContactControllerApi.prototype.getContact = function (contactId, options) {
        return exports.ContactControllerApiFp(this.configuration).getContact(contactId, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Get all contacts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactControllerApi
     */
    ContactControllerApi.prototype.getContacts = function (options) {
        return exports.ContactControllerApiFp(this.configuration).getContacts(options)(this.fetch, this.basePath);
    };
    return ContactControllerApi;
}(BaseAPI));
exports.ContactControllerApi = ContactControllerApi;
/**
 * DomainControllerApi - fetch parameter creator
 * @export
 */
var DomainControllerApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Link a domain that you own with MailSlurp so you can create email addresses using it. Endpoint returns DNS records used for validation. You must add these verification records to your host provider's DNS setup to verify the domain.
         * @summary Create Domain
         * @param {CreateDomainOptions} domainOptions domainOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDomain: function (domainOptions, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'domainOptions' is not null or undefined
            if (domainOptions === null || domainOptions === undefined) {
                throw new RequiredError('domainOptions', 'Required parameter domainOptions was null or undefined when calling createDomain.');
            }
            var localVarPath = "/domains";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'CreateDomainOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(domainOptions || {})
                : domainOptions || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a domain. This will disable any existing inboxes that use this domain.
         * @summary Delete a domain
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDomain: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling deleteDomain.');
            }
            var localVarPath = "/domains/{id}".replace("{" + 'id' + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns domain verification status and tokens for a given domain
         * @summary Get a domain
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomain: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling getDomain.');
            }
            var localVarPath = "/domains/{id}".replace("{" + 'id' + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all custom domains you have created
         * @summary Get domains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomains: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/domains";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.DomainControllerApiFetchParamCreator = DomainControllerApiFetchParamCreator;
/**
 * DomainControllerApi - functional programming interface
 * @export
 */
var DomainControllerApiFp = function (configuration) {
    return {
        /**
         * Link a domain that you own with MailSlurp so you can create email addresses using it. Endpoint returns DNS records used for validation. You must add these verification records to your host provider's DNS setup to verify the domain.
         * @summary Create Domain
         * @param {CreateDomainOptions} domainOptions domainOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDomain: function (domainOptions, options) {
            var localVarFetchArgs = exports.DomainControllerApiFetchParamCreator(configuration).createDomain(domainOptions, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a domain. This will disable any existing inboxes that use this domain.
         * @summary Delete a domain
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDomain: function (id, options) {
            var localVarFetchArgs = exports.DomainControllerApiFetchParamCreator(configuration).deleteDomain(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns domain verification status and tokens for a given domain
         * @summary Get a domain
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomain: function (id, options) {
            var localVarFetchArgs = exports.DomainControllerApiFetchParamCreator(configuration).getDomain(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all custom domains you have created
         * @summary Get domains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomains: function (options) {
            var localVarFetchArgs = exports.DomainControllerApiFetchParamCreator(configuration).getDomains(options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.DomainControllerApiFp = DomainControllerApiFp;
/**
 * DomainControllerApi - factory interface
 * @export
 */
var DomainControllerApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Link a domain that you own with MailSlurp so you can create email addresses using it. Endpoint returns DNS records used for validation. You must add these verification records to your host provider's DNS setup to verify the domain.
         * @summary Create Domain
         * @param {CreateDomainOptions} domainOptions domainOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDomain: function (domainOptions, options) {
            return exports.DomainControllerApiFp(configuration).createDomain(domainOptions, options)(fetch, basePath);
        },
        /**
         * Delete a domain. This will disable any existing inboxes that use this domain.
         * @summary Delete a domain
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDomain: function (id, options) {
            return exports.DomainControllerApiFp(configuration).deleteDomain(id, options)(fetch, basePath);
        },
        /**
         * Returns domain verification status and tokens for a given domain
         * @summary Get a domain
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomain: function (id, options) {
            return exports.DomainControllerApiFp(configuration).getDomain(id, options)(fetch, basePath);
        },
        /**
         * List all custom domains you have created
         * @summary Get domains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomains: function (options) {
            return exports.DomainControllerApiFp(configuration).getDomains(options)(fetch, basePath);
        },
    };
};
exports.DomainControllerApiFactory = DomainControllerApiFactory;
/**
 * DomainControllerApi - object-oriented interface
 * @export
 * @class DomainControllerApi
 * @extends {BaseAPI}
 */
var DomainControllerApi = /** @class */ (function (_super) {
    __extends(DomainControllerApi, _super);
    function DomainControllerApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Link a domain that you own with MailSlurp so you can create email addresses using it. Endpoint returns DNS records used for validation. You must add these verification records to your host provider's DNS setup to verify the domain.
     * @summary Create Domain
     * @param {CreateDomainOptions} domainOptions domainOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainControllerApi
     */
    DomainControllerApi.prototype.createDomain = function (domainOptions, options) {
        return exports.DomainControllerApiFp(this.configuration).createDomain(domainOptions, options)(this.fetch, this.basePath);
    };
    /**
     * Delete a domain. This will disable any existing inboxes that use this domain.
     * @summary Delete a domain
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainControllerApi
     */
    DomainControllerApi.prototype.deleteDomain = function (id, options) {
        return exports.DomainControllerApiFp(this.configuration).deleteDomain(id, options)(this.fetch, this.basePath);
    };
    /**
     * Returns domain verification status and tokens for a given domain
     * @summary Get a domain
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainControllerApi
     */
    DomainControllerApi.prototype.getDomain = function (id, options) {
        return exports.DomainControllerApiFp(this.configuration).getDomain(id, options)(this.fetch, this.basePath);
    };
    /**
     * List all custom domains you have created
     * @summary Get domains
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainControllerApi
     */
    DomainControllerApi.prototype.getDomains = function (options) {
        return exports.DomainControllerApiFp(this.configuration).getDomains(options)(this.fetch, this.basePath);
    };
    return DomainControllerApi;
}(BaseAPI));
exports.DomainControllerApi = DomainControllerApi;
/**
 * EmailControllerApi - fetch parameter creator
 * @export
 */
var EmailControllerApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Deletes all emails in your account. Be careful as emails cannot be recovered
         * @summary Delete all emails
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllEmails: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/emails";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an email and removes it from the inbox. Deleted emails cannot be recovered.
         * @summary Delete an email
         * @param {string} emailId ID of email to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmail: function (emailId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError('emailId', 'Required parameter emailId was null or undefined when calling deleteEmail.');
            }
            var localVarPath = "/emails/{emailId}".replace("{" + 'emailId' + "}", encodeURIComponent(String(emailId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified attachment for a given email as a stream / array of bytes. You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
         * @summary Get email attachment bytes. If you have trouble with byte responses try the `downloadAttachmentBase64` response endpoints.
         * @param {string} attachmentId ID of attachment
         * @param {string} emailId ID of email
         * @param {string} [apiKey] Can pass apiKey in url for this request if you wish to download the file in a browser. Content type will be set to original content type of the attachment file. This is so that browsers can download the file correctly.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachment: function (attachmentId, emailId, apiKey, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError('attachmentId', 'Required parameter attachmentId was null or undefined when calling downloadAttachment.');
            }
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError('emailId', 'Required parameter emailId was null or undefined when calling downloadAttachment.');
            }
            var localVarPath = "/emails/{emailId}/attachments/{attachmentId}"
                .replace("{" + 'attachmentId' + "}", encodeURIComponent(String(attachmentId)))
                .replace("{" + 'emailId' + "}", encodeURIComponent(String(emailId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (apiKey !== undefined) {
                localVarQueryParameter['apiKey'] = apiKey;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified attachment for a given email as a base 64 encoded string. The response type is application/json. This method is similar to the `downloadAttachment` method but allows some clients to get around issues with binary responses.
         * @summary Get email attachment as base64 encoded string (alternative to binary responses)
         * @param {string} attachmentId ID of attachment
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachmentBase64: function (attachmentId, emailId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError('attachmentId', 'Required parameter attachmentId was null or undefined when calling downloadAttachmentBase64.');
            }
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError('emailId', 'Required parameter emailId was null or undefined when calling downloadAttachmentBase64.');
            }
            var localVarPath = "/emails/{emailId}/attachments/{attachmentId}/base64"
                .replace("{" + 'attachmentId' + "}", encodeURIComponent(String(attachmentId)))
                .replace("{" + 'emailId' + "}", encodeURIComponent(String(emailId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Forward an existing email to new recipients.
         * @summary Forward email
         * @param {string} emailId ID of email
         * @param {ForwardEmailOptions} forwardEmailOptions forwardEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forwardEmail: function (emailId, forwardEmailOptions, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError('emailId', 'Required parameter emailId was null or undefined when calling forwardEmail.');
            }
            // verify required parameter 'forwardEmailOptions' is not null or undefined
            if (forwardEmailOptions === null ||
                forwardEmailOptions === undefined) {
                throw new RequiredError('forwardEmailOptions', 'Required parameter forwardEmailOptions was null or undefined when calling forwardEmail.');
            }
            var localVarPath = "/emails/{emailId}/forward".replace("{" + 'emailId' + "}", encodeURIComponent(String(emailId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'ForwardEmailOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(forwardEmailOptions || {})
                : forwardEmailOptions || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the metadata such as name and content-type for a given attachment and email.
         * @summary Get email attachment metadata
         * @param {string} attachmentId ID of attachment
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachmentMetaData: function (attachmentId, emailId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError('attachmentId', 'Required parameter attachmentId was null or undefined when calling getAttachmentMetaData.');
            }
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError('emailId', 'Required parameter emailId was null or undefined when calling getAttachmentMetaData.');
            }
            var localVarPath = "/emails/{emailId}/attachments/{attachmentId}/metadata"
                .replace("{" + 'attachmentId' + "}", encodeURIComponent(String(attachmentId)))
                .replace("{" + 'emailId' + "}", encodeURIComponent(String(emailId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of attachment metadata such as name and content-type for a given email if present.
         * @summary Get all email attachment metadata
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachments: function (emailId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError('emailId', 'Required parameter emailId was null or undefined when calling getAttachments.');
            }
            var localVarPath = "/emails/{emailId}/attachments".replace("{" + 'emailId' + "}", encodeURIComponent(String(emailId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawEmail endpoints
         * @summary Get email content
         * @param {string} emailId emailId
         * @param {boolean} [decode] Decode email body quoted-printable encoding to plain text. SMTP servers often encode text using quoted-printable format (for instance &#x60;&#x3D;D7&#x60;). This can be a pain for testing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmail: function (emailId, decode, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError('emailId', 'Required parameter emailId was null or undefined when calling getEmail.');
            }
            var localVarPath = "/emails/{emailId}".replace("{" + 'emailId' + "}", encodeURIComponent(String(emailId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (decode !== undefined) {
                localVarQueryParameter['decode'] = decode;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the matches for a given Java style regex pattern. Do not include the typical `/` at start or end of regex in some languages. Given an example `your code is: 12345` the pattern to extract match looks like `code is: (\\d{6})`. This will return an array of matches with the first matching the entire pattern and the subsequent matching the groups: `['code is: 123456', '123456']` See https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html for more information of available patterns.
         * @summary Get email content regex pattern match results. Runs regex against email body and returns match groups.
         * @param {ContentMatchOptions} contentMatchOptions contentMatchOptions
         * @param {string} emailId ID of email to match against
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailContentMatch: function (contentMatchOptions, emailId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'contentMatchOptions' is not null or undefined
            if (contentMatchOptions === null ||
                contentMatchOptions === undefined) {
                throw new RequiredError('contentMatchOptions', 'Required parameter contentMatchOptions was null or undefined when calling getEmailContentMatch.');
            }
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError('emailId', 'Required parameter emailId was null or undefined when calling getEmailContentMatch.');
            }
            var localVarPath = "/emails/{emailId}/contentMatch".replace("{" + 'emailId' + "}", encodeURIComponent(String(emailId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'ContentMatchOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(contentMatchOptions || {})
                : contentMatchOptions || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve email content as HTML response for viewing in browsers. Decodes quoted-printable entities and converts charset to UTF-8. Pass your API KEY as a request parameter when viewing in a browser: `?apiKey=xxx`
         * @summary Get email content as HTML
         * @param {string} emailId emailId
         * @param {boolean} [decode] decode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailHTML: function (emailId, decode, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError('emailId', 'Required parameter emailId was null or undefined when calling getEmailHTML.');
            }
            var localVarPath = "/emails/{emailId}/html".replace("{" + 'emailId' + "}", encodeURIComponent(String(emailId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (decode !== undefined) {
                localVarQueryParameter['decode'] = decode;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
         * @summary Get all emails
         * @param {Array<string>} [inboxId] Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account.
         * @param {number} [page] Optional page index in email list pagination
         * @param {number} [size] Optional page size in email list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {boolean} [unreadOnly] Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailsPaginated: function (inboxId, page, size, sort, unreadOnly, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/emails";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (inboxId) {
                localVarQueryParameter['inboxId'] = inboxId;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            if (unreadOnly !== undefined) {
                localVarQueryParameter['unreadOnly'] = unreadOnly;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a raw, unparsed, and unprocessed email. If your client has issues processing the response it is likely due to the response content-type which is text/plain. If you need a JSON response content-type use the getRawEmailJson endpoint
         * @summary Get raw email string
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawEmailContents: function (emailId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError('emailId', 'Required parameter emailId was null or undefined when calling getRawEmailContents.');
            }
            var localVarPath = "/emails/{emailId}/raw".replace("{" + 'emailId' + "}", encodeURIComponent(String(emailId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a raw, unparsed, and unprocessed email wrapped in a JSON response object for easier handling when compared with the getRawEmail text/plain response
         * @summary Get raw email in JSON
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawEmailJson: function (emailId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError('emailId', 'Required parameter emailId was null or undefined when calling getRawEmailJson.');
            }
            var localVarPath = "/emails/{emailId}/raw/json".replace("{" + 'emailId' + "}", encodeURIComponent(String(emailId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get number of emails unread
         * @summary Get unread email count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnreadEmailCount: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/emails/unreadCount";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate the HTML content of email if HTML is found. Considered valid if no HTML.
         * @summary Validate email
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateEmail: function (emailId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError('emailId', 'Required parameter emailId was null or undefined when calling validateEmail.');
            }
            var localVarPath = "/emails/{emailId}/validate".replace("{" + 'emailId' + "}", encodeURIComponent(String(emailId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.EmailControllerApiFetchParamCreator = EmailControllerApiFetchParamCreator;
/**
 * EmailControllerApi - functional programming interface
 * @export
 */
var EmailControllerApiFp = function (configuration) {
    return {
        /**
         * Deletes all emails in your account. Be careful as emails cannot be recovered
         * @summary Delete all emails
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllEmails: function (options) {
            var localVarFetchArgs = exports.EmailControllerApiFetchParamCreator(configuration).deleteAllEmails(options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes an email and removes it from the inbox. Deleted emails cannot be recovered.
         * @summary Delete an email
         * @param {string} emailId ID of email to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmail: function (emailId, options) {
            var localVarFetchArgs = exports.EmailControllerApiFetchParamCreator(configuration).deleteEmail(emailId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the specified attachment for a given email as a stream / array of bytes. You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
         * @summary Get email attachment bytes. If you have trouble with byte responses try the `downloadAttachmentBase64` response endpoints.
         * @param {string} attachmentId ID of attachment
         * @param {string} emailId ID of email
         * @param {string} [apiKey] Can pass apiKey in url for this request if you wish to download the file in a browser. Content type will be set to original content type of the attachment file. This is so that browsers can download the file correctly.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachment: function (attachmentId, emailId, apiKey, options) {
            var localVarFetchArgs = exports.EmailControllerApiFetchParamCreator(configuration).downloadAttachment(attachmentId, emailId, apiKey, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the specified attachment for a given email as a base 64 encoded string. The response type is application/json. This method is similar to the `downloadAttachment` method but allows some clients to get around issues with binary responses.
         * @summary Get email attachment as base64 encoded string (alternative to binary responses)
         * @param {string} attachmentId ID of attachment
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachmentBase64: function (attachmentId, emailId, options) {
            var localVarFetchArgs = exports.EmailControllerApiFetchParamCreator(configuration).downloadAttachmentBase64(attachmentId, emailId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Forward an existing email to new recipients.
         * @summary Forward email
         * @param {string} emailId ID of email
         * @param {ForwardEmailOptions} forwardEmailOptions forwardEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forwardEmail: function (emailId, forwardEmailOptions, options) {
            var localVarFetchArgs = exports.EmailControllerApiFetchParamCreator(configuration).forwardEmail(emailId, forwardEmailOptions, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the metadata such as name and content-type for a given attachment and email.
         * @summary Get email attachment metadata
         * @param {string} attachmentId ID of attachment
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachmentMetaData: function (attachmentId, emailId, options) {
            var localVarFetchArgs = exports.EmailControllerApiFetchParamCreator(configuration).getAttachmentMetaData(attachmentId, emailId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns an array of attachment metadata such as name and content-type for a given email if present.
         * @summary Get all email attachment metadata
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachments: function (emailId, options) {
            var localVarFetchArgs = exports.EmailControllerApiFetchParamCreator(configuration).getAttachments(emailId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawEmail endpoints
         * @summary Get email content
         * @param {string} emailId emailId
         * @param {boolean} [decode] Decode email body quoted-printable encoding to plain text. SMTP servers often encode text using quoted-printable format (for instance &#x60;&#x3D;D7&#x60;). This can be a pain for testing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmail: function (emailId, decode, options) {
            var localVarFetchArgs = exports.EmailControllerApiFetchParamCreator(configuration).getEmail(emailId, decode, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return the matches for a given Java style regex pattern. Do not include the typical `/` at start or end of regex in some languages. Given an example `your code is: 12345` the pattern to extract match looks like `code is: (\\d{6})`. This will return an array of matches with the first matching the entire pattern and the subsequent matching the groups: `['code is: 123456', '123456']` See https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html for more information of available patterns.
         * @summary Get email content regex pattern match results. Runs regex against email body and returns match groups.
         * @param {ContentMatchOptions} contentMatchOptions contentMatchOptions
         * @param {string} emailId ID of email to match against
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailContentMatch: function (contentMatchOptions, emailId, options) {
            var localVarFetchArgs = exports.EmailControllerApiFetchParamCreator(configuration).getEmailContentMatch(contentMatchOptions, emailId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve email content as HTML response for viewing in browsers. Decodes quoted-printable entities and converts charset to UTF-8. Pass your API KEY as a request parameter when viewing in a browser: `?apiKey=xxx`
         * @summary Get email content as HTML
         * @param {string} emailId emailId
         * @param {boolean} [decode] decode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailHTML: function (emailId, decode, options) {
            var localVarFetchArgs = exports.EmailControllerApiFetchParamCreator(configuration).getEmailHTML(emailId, decode, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
         * @summary Get all emails
         * @param {Array<string>} [inboxId] Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account.
         * @param {number} [page] Optional page index in email list pagination
         * @param {number} [size] Optional page size in email list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {boolean} [unreadOnly] Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailsPaginated: function (inboxId, page, size, sort, unreadOnly, options) {
            var localVarFetchArgs = exports.EmailControllerApiFetchParamCreator(configuration).getEmailsPaginated(inboxId, page, size, sort, unreadOnly, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a raw, unparsed, and unprocessed email. If your client has issues processing the response it is likely due to the response content-type which is text/plain. If you need a JSON response content-type use the getRawEmailJson endpoint
         * @summary Get raw email string
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawEmailContents: function (emailId, options) {
            var localVarFetchArgs = exports.EmailControllerApiFetchParamCreator(configuration).getRawEmailContents(emailId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a raw, unparsed, and unprocessed email wrapped in a JSON response object for easier handling when compared with the getRawEmail text/plain response
         * @summary Get raw email in JSON
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawEmailJson: function (emailId, options) {
            var localVarFetchArgs = exports.EmailControllerApiFetchParamCreator(configuration).getRawEmailJson(emailId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get number of emails unread
         * @summary Get unread email count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnreadEmailCount: function (options) {
            var localVarFetchArgs = exports.EmailControllerApiFetchParamCreator(configuration).getUnreadEmailCount(options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Validate the HTML content of email if HTML is found. Considered valid if no HTML.
         * @summary Validate email
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateEmail: function (emailId, options) {
            var localVarFetchArgs = exports.EmailControllerApiFetchParamCreator(configuration).validateEmail(emailId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.EmailControllerApiFp = EmailControllerApiFp;
/**
 * EmailControllerApi - factory interface
 * @export
 */
var EmailControllerApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Deletes all emails in your account. Be careful as emails cannot be recovered
         * @summary Delete all emails
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllEmails: function (options) {
            return exports.EmailControllerApiFp(configuration).deleteAllEmails(options)(fetch, basePath);
        },
        /**
         * Deletes an email and removes it from the inbox. Deleted emails cannot be recovered.
         * @summary Delete an email
         * @param {string} emailId ID of email to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmail: function (emailId, options) {
            return exports.EmailControllerApiFp(configuration).deleteEmail(emailId, options)(fetch, basePath);
        },
        /**
         * Returns the specified attachment for a given email as a stream / array of bytes. You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
         * @summary Get email attachment bytes. If you have trouble with byte responses try the `downloadAttachmentBase64` response endpoints.
         * @param {string} attachmentId ID of attachment
         * @param {string} emailId ID of email
         * @param {string} [apiKey] Can pass apiKey in url for this request if you wish to download the file in a browser. Content type will be set to original content type of the attachment file. This is so that browsers can download the file correctly.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachment: function (attachmentId, emailId, apiKey, options) {
            return exports.EmailControllerApiFp(configuration).downloadAttachment(attachmentId, emailId, apiKey, options)(fetch, basePath);
        },
        /**
         * Returns the specified attachment for a given email as a base 64 encoded string. The response type is application/json. This method is similar to the `downloadAttachment` method but allows some clients to get around issues with binary responses.
         * @summary Get email attachment as base64 encoded string (alternative to binary responses)
         * @param {string} attachmentId ID of attachment
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachmentBase64: function (attachmentId, emailId, options) {
            return exports.EmailControllerApiFp(configuration).downloadAttachmentBase64(attachmentId, emailId, options)(fetch, basePath);
        },
        /**
         * Forward an existing email to new recipients.
         * @summary Forward email
         * @param {string} emailId ID of email
         * @param {ForwardEmailOptions} forwardEmailOptions forwardEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forwardEmail: function (emailId, forwardEmailOptions, options) {
            return exports.EmailControllerApiFp(configuration).forwardEmail(emailId, forwardEmailOptions, options)(fetch, basePath);
        },
        /**
         * Returns the metadata such as name and content-type for a given attachment and email.
         * @summary Get email attachment metadata
         * @param {string} attachmentId ID of attachment
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachmentMetaData: function (attachmentId, emailId, options) {
            return exports.EmailControllerApiFp(configuration).getAttachmentMetaData(attachmentId, emailId, options)(fetch, basePath);
        },
        /**
         * Returns an array of attachment metadata such as name and content-type for a given email if present.
         * @summary Get all email attachment metadata
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachments: function (emailId, options) {
            return exports.EmailControllerApiFp(configuration).getAttachments(emailId, options)(fetch, basePath);
        },
        /**
         * Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawEmail endpoints
         * @summary Get email content
         * @param {string} emailId emailId
         * @param {boolean} [decode] Decode email body quoted-printable encoding to plain text. SMTP servers often encode text using quoted-printable format (for instance &#x60;&#x3D;D7&#x60;). This can be a pain for testing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmail: function (emailId, decode, options) {
            return exports.EmailControllerApiFp(configuration).getEmail(emailId, decode, options)(fetch, basePath);
        },
        /**
         * Return the matches for a given Java style regex pattern. Do not include the typical `/` at start or end of regex in some languages. Given an example `your code is: 12345` the pattern to extract match looks like `code is: (\\d{6})`. This will return an array of matches with the first matching the entire pattern and the subsequent matching the groups: `['code is: 123456', '123456']` See https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html for more information of available patterns.
         * @summary Get email content regex pattern match results. Runs regex against email body and returns match groups.
         * @param {ContentMatchOptions} contentMatchOptions contentMatchOptions
         * @param {string} emailId ID of email to match against
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailContentMatch: function (contentMatchOptions, emailId, options) {
            return exports.EmailControllerApiFp(configuration).getEmailContentMatch(contentMatchOptions, emailId, options)(fetch, basePath);
        },
        /**
         * Retrieve email content as HTML response for viewing in browsers. Decodes quoted-printable entities and converts charset to UTF-8. Pass your API KEY as a request parameter when viewing in a browser: `?apiKey=xxx`
         * @summary Get email content as HTML
         * @param {string} emailId emailId
         * @param {boolean} [decode] decode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailHTML: function (emailId, decode, options) {
            return exports.EmailControllerApiFp(configuration).getEmailHTML(emailId, decode, options)(fetch, basePath);
        },
        /**
         * By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
         * @summary Get all emails
         * @param {Array<string>} [inboxId] Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account.
         * @param {number} [page] Optional page index in email list pagination
         * @param {number} [size] Optional page size in email list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {boolean} [unreadOnly] Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailsPaginated: function (inboxId, page, size, sort, unreadOnly, options) {
            return exports.EmailControllerApiFp(configuration).getEmailsPaginated(inboxId, page, size, sort, unreadOnly, options)(fetch, basePath);
        },
        /**
         * Returns a raw, unparsed, and unprocessed email. If your client has issues processing the response it is likely due to the response content-type which is text/plain. If you need a JSON response content-type use the getRawEmailJson endpoint
         * @summary Get raw email string
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawEmailContents: function (emailId, options) {
            return exports.EmailControllerApiFp(configuration).getRawEmailContents(emailId, options)(fetch, basePath);
        },
        /**
         * Returns a raw, unparsed, and unprocessed email wrapped in a JSON response object for easier handling when compared with the getRawEmail text/plain response
         * @summary Get raw email in JSON
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawEmailJson: function (emailId, options) {
            return exports.EmailControllerApiFp(configuration).getRawEmailJson(emailId, options)(fetch, basePath);
        },
        /**
         * Get number of emails unread
         * @summary Get unread email count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnreadEmailCount: function (options) {
            return exports.EmailControllerApiFp(configuration).getUnreadEmailCount(options)(fetch, basePath);
        },
        /**
         * Validate the HTML content of email if HTML is found. Considered valid if no HTML.
         * @summary Validate email
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateEmail: function (emailId, options) {
            return exports.EmailControllerApiFp(configuration).validateEmail(emailId, options)(fetch, basePath);
        },
    };
};
exports.EmailControllerApiFactory = EmailControllerApiFactory;
/**
 * EmailControllerApi - object-oriented interface
 * @export
 * @class EmailControllerApi
 * @extends {BaseAPI}
 */
var EmailControllerApi = /** @class */ (function (_super) {
    __extends(EmailControllerApi, _super);
    function EmailControllerApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Deletes all emails in your account. Be careful as emails cannot be recovered
     * @summary Delete all emails
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    EmailControllerApi.prototype.deleteAllEmails = function (options) {
        return exports.EmailControllerApiFp(this.configuration).deleteAllEmails(options)(this.fetch, this.basePath);
    };
    /**
     * Deletes an email and removes it from the inbox. Deleted emails cannot be recovered.
     * @summary Delete an email
     * @param {string} emailId ID of email to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    EmailControllerApi.prototype.deleteEmail = function (emailId, options) {
        return exports.EmailControllerApiFp(this.configuration).deleteEmail(emailId, options)(this.fetch, this.basePath);
    };
    /**
     * Returns the specified attachment for a given email as a stream / array of bytes. You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
     * @summary Get email attachment bytes. If you have trouble with byte responses try the `downloadAttachmentBase64` response endpoints.
     * @param {string} attachmentId ID of attachment
     * @param {string} emailId ID of email
     * @param {string} [apiKey] Can pass apiKey in url for this request if you wish to download the file in a browser. Content type will be set to original content type of the attachment file. This is so that browsers can download the file correctly.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    EmailControllerApi.prototype.downloadAttachment = function (attachmentId, emailId, apiKey, options) {
        return exports.EmailControllerApiFp(this.configuration).downloadAttachment(attachmentId, emailId, apiKey, options)(this.fetch, this.basePath);
    };
    /**
     * Returns the specified attachment for a given email as a base 64 encoded string. The response type is application/json. This method is similar to the `downloadAttachment` method but allows some clients to get around issues with binary responses.
     * @summary Get email attachment as base64 encoded string (alternative to binary responses)
     * @param {string} attachmentId ID of attachment
     * @param {string} emailId ID of email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    EmailControllerApi.prototype.downloadAttachmentBase64 = function (attachmentId, emailId, options) {
        return exports.EmailControllerApiFp(this.configuration).downloadAttachmentBase64(attachmentId, emailId, options)(this.fetch, this.basePath);
    };
    /**
     * Forward an existing email to new recipients.
     * @summary Forward email
     * @param {string} emailId ID of email
     * @param {ForwardEmailOptions} forwardEmailOptions forwardEmailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    EmailControllerApi.prototype.forwardEmail = function (emailId, forwardEmailOptions, options) {
        return exports.EmailControllerApiFp(this.configuration).forwardEmail(emailId, forwardEmailOptions, options)(this.fetch, this.basePath);
    };
    /**
     * Returns the metadata such as name and content-type for a given attachment and email.
     * @summary Get email attachment metadata
     * @param {string} attachmentId ID of attachment
     * @param {string} emailId ID of email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    EmailControllerApi.prototype.getAttachmentMetaData = function (attachmentId, emailId, options) {
        return exports.EmailControllerApiFp(this.configuration).getAttachmentMetaData(attachmentId, emailId, options)(this.fetch, this.basePath);
    };
    /**
     * Returns an array of attachment metadata such as name and content-type for a given email if present.
     * @summary Get all email attachment metadata
     * @param {string} emailId ID of email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    EmailControllerApi.prototype.getAttachments = function (emailId, options) {
        return exports.EmailControllerApiFp(this.configuration).getAttachments(emailId, options)(this.fetch, this.basePath);
    };
    /**
     * Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawEmail endpoints
     * @summary Get email content
     * @param {string} emailId emailId
     * @param {boolean} [decode] Decode email body quoted-printable encoding to plain text. SMTP servers often encode text using quoted-printable format (for instance &#x60;&#x3D;D7&#x60;). This can be a pain for testing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    EmailControllerApi.prototype.getEmail = function (emailId, decode, options) {
        return exports.EmailControllerApiFp(this.configuration).getEmail(emailId, decode, options)(this.fetch, this.basePath);
    };
    /**
     * Return the matches for a given Java style regex pattern. Do not include the typical `/` at start or end of regex in some languages. Given an example `your code is: 12345` the pattern to extract match looks like `code is: (\\d{6})`. This will return an array of matches with the first matching the entire pattern and the subsequent matching the groups: `['code is: 123456', '123456']` See https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html for more information of available patterns.
     * @summary Get email content regex pattern match results. Runs regex against email body and returns match groups.
     * @param {ContentMatchOptions} contentMatchOptions contentMatchOptions
     * @param {string} emailId ID of email to match against
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    EmailControllerApi.prototype.getEmailContentMatch = function (contentMatchOptions, emailId, options) {
        return exports.EmailControllerApiFp(this.configuration).getEmailContentMatch(contentMatchOptions, emailId, options)(this.fetch, this.basePath);
    };
    /**
     * Retrieve email content as HTML response for viewing in browsers. Decodes quoted-printable entities and converts charset to UTF-8. Pass your API KEY as a request parameter when viewing in a browser: `?apiKey=xxx`
     * @summary Get email content as HTML
     * @param {string} emailId emailId
     * @param {boolean} [decode] decode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    EmailControllerApi.prototype.getEmailHTML = function (emailId, decode, options) {
        return exports.EmailControllerApiFp(this.configuration).getEmailHTML(emailId, decode, options)(this.fetch, this.basePath);
    };
    /**
     * By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
     * @summary Get all emails
     * @param {Array<string>} [inboxId] Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account.
     * @param {number} [page] Optional page index in email list pagination
     * @param {number} [size] Optional page size in email list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {boolean} [unreadOnly] Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    EmailControllerApi.prototype.getEmailsPaginated = function (inboxId, page, size, sort, unreadOnly, options) {
        return exports.EmailControllerApiFp(this.configuration).getEmailsPaginated(inboxId, page, size, sort, unreadOnly, options)(this.fetch, this.basePath);
    };
    /**
     * Returns a raw, unparsed, and unprocessed email. If your client has issues processing the response it is likely due to the response content-type which is text/plain. If you need a JSON response content-type use the getRawEmailJson endpoint
     * @summary Get raw email string
     * @param {string} emailId ID of email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    EmailControllerApi.prototype.getRawEmailContents = function (emailId, options) {
        return exports.EmailControllerApiFp(this.configuration).getRawEmailContents(emailId, options)(this.fetch, this.basePath);
    };
    /**
     * Returns a raw, unparsed, and unprocessed email wrapped in a JSON response object for easier handling when compared with the getRawEmail text/plain response
     * @summary Get raw email in JSON
     * @param {string} emailId ID of email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    EmailControllerApi.prototype.getRawEmailJson = function (emailId, options) {
        return exports.EmailControllerApiFp(this.configuration).getRawEmailJson(emailId, options)(this.fetch, this.basePath);
    };
    /**
     * Get number of emails unread
     * @summary Get unread email count
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    EmailControllerApi.prototype.getUnreadEmailCount = function (options) {
        return exports.EmailControllerApiFp(this.configuration).getUnreadEmailCount(options)(this.fetch, this.basePath);
    };
    /**
     * Validate the HTML content of email if HTML is found. Considered valid if no HTML.
     * @summary Validate email
     * @param {string} emailId ID of email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    EmailControllerApi.prototype.validateEmail = function (emailId, options) {
        return exports.EmailControllerApiFp(this.configuration).validateEmail(emailId, options)(this.fetch, this.basePath);
    };
    return EmailControllerApi;
}(BaseAPI));
exports.EmailControllerApi = EmailControllerApi;
/**
 * FormControllerApi - fetch parameter creator
 * @export
 */
var FormControllerApiFetchParamCreator = function (configuration) {
    return {
        /**
         * This endpoint allows you to submit HTML forms and receive the field values and files via email.   #### Parameters The endpoint looks for special meta parameters in the form fields OR in the URL request parameters. The meta parameters can be used to specify the behaviour of the email.   You must provide at-least a `_to` email address or a `_toAlias` email alias ID to tell the endpoint where the form should be emailed. These can be submitted as hidden HTML input fields with the corresponding `name` attributes or as URL query parameters such as `?_to=test@example.com`  The endpoint takes all other form fields that are named and includes them in the message body of the email. Files are sent as attachments.  #### Submitting This endpoint accepts form submission via POST method. It accepts `application/x-www-form-urlencoded`, and `multipart/form-data` content-types.  #### HTML Example ```html <form    action=\"https://api.mailslurp.com/forms\"   method=\"post\" >   <input name=\"_to\" type=\"hidden\" value=\"test@example.com\"/>   <textarea name=\"feedback\"></textarea>   <button type=\"submit\">Submit</button> </form> ```  #### URL Example ```html <form    action=\"https://api.mailslurp.com/forms?_toAlias=test@example.com\"   method=\"post\" >   <textarea name=\"feedback\"></textarea>   <button type=\"submit\">Submit</button> </form> ```    The email address is specified by a `_to` field OR is extracted from an email alias specified by a `_toAlias` field (see the alias controller for more information).  Endpoint accepts .  You can specify a content type in HTML forms using the `enctype` attribute, for instance: `<form enctype=\"multipart/form-data\">`.
         * @summary Submit a form to be parsed and sent as an email to an address determined by the form fields
         * @param {string} [emailAddress] Email address of the submitting user. Include this if you wish to record the submitters email address and reply to it later.
         * @param {string} [redirectTo] Optional URL to redirect form submitter to after submission. If not present user will see a success message.
         * @param {string} [spamCheck] Optional but recommended field that catches spammers out. Include as a hidden form field but LEAVE EMPTY. Spam-bots will usually fill every field. If the _spamCheck field is filled the form submission will be ignored.
         * @param {string} [subject] Optional subject of the email that will be sent.
         * @param {string} [successMessage] Optional success message to display if no _redirectTo present.
         * @param {string} [to] The email address that submitted form should be sent to. Either this or _toAlias must be present for a form to be successfully submitted..
         * @param {string} [toAlias] ID of an email alias to that form should be sent to. Aliases must be created before submission and can be used to hide an email address and reduce spam.
         * @param {string} [otherParameters] All other parameters or fields will be accepted and attached to the sent email. This includes files and any HTML form field with a name. These fields will become the body of the email that is sent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitForm: function (emailAddress, redirectTo, spamCheck, subject, successMessage, to, toAlias, otherParameters, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/forms";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            var localVarFormParams = new url.URLSearchParams();
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (emailAddress !== undefined) {
                localVarFormParams.set('_emailAddress', emailAddress);
            }
            if (redirectTo !== undefined) {
                localVarFormParams.set('_redirectTo', redirectTo);
            }
            if (spamCheck !== undefined) {
                localVarFormParams.set('_spamCheck', spamCheck);
            }
            if (subject !== undefined) {
                localVarFormParams.set('_subject', subject);
            }
            if (successMessage !== undefined) {
                localVarFormParams.set('_successMessage', successMessage);
            }
            if (to !== undefined) {
                localVarFormParams.set('_to', to);
            }
            if (toAlias !== undefined) {
                localVarFormParams.set('_toAlias', toAlias);
            }
            if (otherParameters !== undefined) {
                localVarFormParams.set('otherParameters', otherParameters);
            }
            localVarHeaderParameter['Content-Type'] =
                'application/x-www-form-urlencoded';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.FormControllerApiFetchParamCreator = FormControllerApiFetchParamCreator;
/**
 * FormControllerApi - functional programming interface
 * @export
 */
var FormControllerApiFp = function (configuration) {
    return {
        /**
         * This endpoint allows you to submit HTML forms and receive the field values and files via email.   #### Parameters The endpoint looks for special meta parameters in the form fields OR in the URL request parameters. The meta parameters can be used to specify the behaviour of the email.   You must provide at-least a `_to` email address or a `_toAlias` email alias ID to tell the endpoint where the form should be emailed. These can be submitted as hidden HTML input fields with the corresponding `name` attributes or as URL query parameters such as `?_to=test@example.com`  The endpoint takes all other form fields that are named and includes them in the message body of the email. Files are sent as attachments.  #### Submitting This endpoint accepts form submission via POST method. It accepts `application/x-www-form-urlencoded`, and `multipart/form-data` content-types.  #### HTML Example ```html <form    action=\"https://api.mailslurp.com/forms\"   method=\"post\" >   <input name=\"_to\" type=\"hidden\" value=\"test@example.com\"/>   <textarea name=\"feedback\"></textarea>   <button type=\"submit\">Submit</button> </form> ```  #### URL Example ```html <form    action=\"https://api.mailslurp.com/forms?_toAlias=test@example.com\"   method=\"post\" >   <textarea name=\"feedback\"></textarea>   <button type=\"submit\">Submit</button> </form> ```    The email address is specified by a `_to` field OR is extracted from an email alias specified by a `_toAlias` field (see the alias controller for more information).  Endpoint accepts .  You can specify a content type in HTML forms using the `enctype` attribute, for instance: `<form enctype=\"multipart/form-data\">`.
         * @summary Submit a form to be parsed and sent as an email to an address determined by the form fields
         * @param {string} [emailAddress] Email address of the submitting user. Include this if you wish to record the submitters email address and reply to it later.
         * @param {string} [redirectTo] Optional URL to redirect form submitter to after submission. If not present user will see a success message.
         * @param {string} [spamCheck] Optional but recommended field that catches spammers out. Include as a hidden form field but LEAVE EMPTY. Spam-bots will usually fill every field. If the _spamCheck field is filled the form submission will be ignored.
         * @param {string} [subject] Optional subject of the email that will be sent.
         * @param {string} [successMessage] Optional success message to display if no _redirectTo present.
         * @param {string} [to] The email address that submitted form should be sent to. Either this or _toAlias must be present for a form to be successfully submitted..
         * @param {string} [toAlias] ID of an email alias to that form should be sent to. Aliases must be created before submission and can be used to hide an email address and reduce spam.
         * @param {string} [otherParameters] All other parameters or fields will be accepted and attached to the sent email. This includes files and any HTML form field with a name. These fields will become the body of the email that is sent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitForm: function (emailAddress, redirectTo, spamCheck, subject, successMessage, to, toAlias, otherParameters, options) {
            var localVarFetchArgs = exports.FormControllerApiFetchParamCreator(configuration).submitForm(emailAddress, redirectTo, spamCheck, subject, successMessage, to, toAlias, otherParameters, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.FormControllerApiFp = FormControllerApiFp;
/**
 * FormControllerApi - factory interface
 * @export
 */
var FormControllerApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * This endpoint allows you to submit HTML forms and receive the field values and files via email.   #### Parameters The endpoint looks for special meta parameters in the form fields OR in the URL request parameters. The meta parameters can be used to specify the behaviour of the email.   You must provide at-least a `_to` email address or a `_toAlias` email alias ID to tell the endpoint where the form should be emailed. These can be submitted as hidden HTML input fields with the corresponding `name` attributes or as URL query parameters such as `?_to=test@example.com`  The endpoint takes all other form fields that are named and includes them in the message body of the email. Files are sent as attachments.  #### Submitting This endpoint accepts form submission via POST method. It accepts `application/x-www-form-urlencoded`, and `multipart/form-data` content-types.  #### HTML Example ```html <form    action=\"https://api.mailslurp.com/forms\"   method=\"post\" >   <input name=\"_to\" type=\"hidden\" value=\"test@example.com\"/>   <textarea name=\"feedback\"></textarea>   <button type=\"submit\">Submit</button> </form> ```  #### URL Example ```html <form    action=\"https://api.mailslurp.com/forms?_toAlias=test@example.com\"   method=\"post\" >   <textarea name=\"feedback\"></textarea>   <button type=\"submit\">Submit</button> </form> ```    The email address is specified by a `_to` field OR is extracted from an email alias specified by a `_toAlias` field (see the alias controller for more information).  Endpoint accepts .  You can specify a content type in HTML forms using the `enctype` attribute, for instance: `<form enctype=\"multipart/form-data\">`.
         * @summary Submit a form to be parsed and sent as an email to an address determined by the form fields
         * @param {string} [emailAddress] Email address of the submitting user. Include this if you wish to record the submitters email address and reply to it later.
         * @param {string} [redirectTo] Optional URL to redirect form submitter to after submission. If not present user will see a success message.
         * @param {string} [spamCheck] Optional but recommended field that catches spammers out. Include as a hidden form field but LEAVE EMPTY. Spam-bots will usually fill every field. If the _spamCheck field is filled the form submission will be ignored.
         * @param {string} [subject] Optional subject of the email that will be sent.
         * @param {string} [successMessage] Optional success message to display if no _redirectTo present.
         * @param {string} [to] The email address that submitted form should be sent to. Either this or _toAlias must be present for a form to be successfully submitted..
         * @param {string} [toAlias] ID of an email alias to that form should be sent to. Aliases must be created before submission and can be used to hide an email address and reduce spam.
         * @param {string} [otherParameters] All other parameters or fields will be accepted and attached to the sent email. This includes files and any HTML form field with a name. These fields will become the body of the email that is sent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitForm: function (emailAddress, redirectTo, spamCheck, subject, successMessage, to, toAlias, otherParameters, options) {
            return exports.FormControllerApiFp(configuration).submitForm(emailAddress, redirectTo, spamCheck, subject, successMessage, to, toAlias, otherParameters, options)(fetch, basePath);
        },
    };
};
exports.FormControllerApiFactory = FormControllerApiFactory;
/**
 * FormControllerApi - object-oriented interface
 * @export
 * @class FormControllerApi
 * @extends {BaseAPI}
 */
var FormControllerApi = /** @class */ (function (_super) {
    __extends(FormControllerApi, _super);
    function FormControllerApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * This endpoint allows you to submit HTML forms and receive the field values and files via email.   #### Parameters The endpoint looks for special meta parameters in the form fields OR in the URL request parameters. The meta parameters can be used to specify the behaviour of the email.   You must provide at-least a `_to` email address or a `_toAlias` email alias ID to tell the endpoint where the form should be emailed. These can be submitted as hidden HTML input fields with the corresponding `name` attributes or as URL query parameters such as `?_to=test@example.com`  The endpoint takes all other form fields that are named and includes them in the message body of the email. Files are sent as attachments.  #### Submitting This endpoint accepts form submission via POST method. It accepts `application/x-www-form-urlencoded`, and `multipart/form-data` content-types.  #### HTML Example ```html <form    action=\"https://api.mailslurp.com/forms\"   method=\"post\" >   <input name=\"_to\" type=\"hidden\" value=\"test@example.com\"/>   <textarea name=\"feedback\"></textarea>   <button type=\"submit\">Submit</button> </form> ```  #### URL Example ```html <form    action=\"https://api.mailslurp.com/forms?_toAlias=test@example.com\"   method=\"post\" >   <textarea name=\"feedback\"></textarea>   <button type=\"submit\">Submit</button> </form> ```    The email address is specified by a `_to` field OR is extracted from an email alias specified by a `_toAlias` field (see the alias controller for more information).  Endpoint accepts .  You can specify a content type in HTML forms using the `enctype` attribute, for instance: `<form enctype=\"multipart/form-data\">`.
     * @summary Submit a form to be parsed and sent as an email to an address determined by the form fields
     * @param {string} [emailAddress] Email address of the submitting user. Include this if you wish to record the submitters email address and reply to it later.
     * @param {string} [redirectTo] Optional URL to redirect form submitter to after submission. If not present user will see a success message.
     * @param {string} [spamCheck] Optional but recommended field that catches spammers out. Include as a hidden form field but LEAVE EMPTY. Spam-bots will usually fill every field. If the _spamCheck field is filled the form submission will be ignored.
     * @param {string} [subject] Optional subject of the email that will be sent.
     * @param {string} [successMessage] Optional success message to display if no _redirectTo present.
     * @param {string} [to] The email address that submitted form should be sent to. Either this or _toAlias must be present for a form to be successfully submitted..
     * @param {string} [toAlias] ID of an email alias to that form should be sent to. Aliases must be created before submission and can be used to hide an email address and reduce spam.
     * @param {string} [otherParameters] All other parameters or fields will be accepted and attached to the sent email. This includes files and any HTML form field with a name. These fields will become the body of the email that is sent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormControllerApi
     */
    FormControllerApi.prototype.submitForm = function (emailAddress, redirectTo, spamCheck, subject, successMessage, to, toAlias, otherParameters, options) {
        return exports.FormControllerApiFp(this.configuration).submitForm(emailAddress, redirectTo, spamCheck, subject, successMessage, to, toAlias, otherParameters, options)(this.fetch, this.basePath);
    };
    return FormControllerApi;
}(BaseAPI));
exports.FormControllerApi = FormControllerApi;
/**
 * GroupControllerApi - fetch parameter creator
 * @export
 */
var GroupControllerApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Add contacts to a group
         * @param {string} groupId groupId
         * @param {UpdateGroupContacts} updateGroupContactsOption updateGroupContactsOption
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addContactsToGroup: function (groupId, updateGroupContactsOption, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError('groupId', 'Required parameter groupId was null or undefined when calling addContactsToGroup.');
            }
            // verify required parameter 'updateGroupContactsOption' is not null or undefined
            if (updateGroupContactsOption === null ||
                updateGroupContactsOption === undefined) {
                throw new RequiredError('updateGroupContactsOption', 'Required parameter updateGroupContactsOption was null or undefined when calling addContactsToGroup.');
            }
            var localVarPath = "/groups/{groupId}/contacts".replace("{" + 'groupId' + "}", encodeURIComponent(String(groupId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'UpdateGroupContacts' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(updateGroupContactsOption || {})
                : updateGroupContactsOption || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a group
         * @param {CreateGroupOptions} createGroupOptions createGroupOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup: function (createGroupOptions, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'createGroupOptions' is not null or undefined
            if (createGroupOptions === null ||
                createGroupOptions === undefined) {
                throw new RequiredError('createGroupOptions', 'Required parameter createGroupOptions was null or undefined when calling createGroup.');
            }
            var localVarPath = "/groups";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'CreateGroupOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(createGroupOptions || {})
                : createGroupOptions || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete group
         * @param {string} groupId groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup: function (groupId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError('groupId', 'Required parameter groupId was null or undefined when calling deleteGroup.');
            }
            var localVarPath = "/groups/{groupId}".replace("{" + 'groupId' + "}", encodeURIComponent(String(groupId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Contact Groups in paginated format
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllGroups: function (page, size, sort, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/groups/paginated";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get group
         * @param {string} groupId groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup: function (groupId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError('groupId', 'Required parameter groupId was null or undefined when calling getGroup.');
            }
            var localVarPath = "/groups/{groupId}".replace("{" + 'groupId' + "}", encodeURIComponent(String(groupId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get group and contacts belonging to it
         * @param {string} groupId groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupWithContacts: function (groupId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError('groupId', 'Required parameter groupId was null or undefined when calling getGroupWithContacts.');
            }
            var localVarPath = "/groups/{groupId}/contacts".replace("{" + 'groupId' + "}", encodeURIComponent(String(groupId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get group and paginated contacts belonging to it
         * @param {string} groupId groupId
         * @param {number} [page] Optional page index in group contact pagination
         * @param {number} [size] Optional page size in group contact pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupWithContactsPaginated: function (groupId, page, size, sort, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError('groupId', 'Required parameter groupId was null or undefined when calling getGroupWithContactsPaginated.');
            }
            var localVarPath = "/groups/{groupId}/contacts-paginated".replace("{" + 'groupId' + "}", encodeURIComponent(String(groupId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/groups";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Remove contacts from a group
         * @param {string} groupId groupId
         * @param {UpdateGroupContacts} updateGroupContactsOption updateGroupContactsOption
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeContactsFromGroup: function (groupId, updateGroupContactsOption, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError('groupId', 'Required parameter groupId was null or undefined when calling removeContactsFromGroup.');
            }
            // verify required parameter 'updateGroupContactsOption' is not null or undefined
            if (updateGroupContactsOption === null ||
                updateGroupContactsOption === undefined) {
                throw new RequiredError('updateGroupContactsOption', 'Required parameter updateGroupContactsOption was null or undefined when calling removeContactsFromGroup.');
            }
            var localVarPath = "/groups/{groupId}/contacts".replace("{" + 'groupId' + "}", encodeURIComponent(String(groupId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'UpdateGroupContacts' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(updateGroupContactsOption || {})
                : updateGroupContactsOption || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.GroupControllerApiFetchParamCreator = GroupControllerApiFetchParamCreator;
/**
 * GroupControllerApi - functional programming interface
 * @export
 */
var GroupControllerApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Add contacts to a group
         * @param {string} groupId groupId
         * @param {UpdateGroupContacts} updateGroupContactsOption updateGroupContactsOption
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addContactsToGroup: function (groupId, updateGroupContactsOption, options) {
            var localVarFetchArgs = exports.GroupControllerApiFetchParamCreator(configuration).addContactsToGroup(groupId, updateGroupContactsOption, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Create a group
         * @param {CreateGroupOptions} createGroupOptions createGroupOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup: function (createGroupOptions, options) {
            var localVarFetchArgs = exports.GroupControllerApiFetchParamCreator(configuration).createGroup(createGroupOptions, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete group
         * @param {string} groupId groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup: function (groupId, options) {
            var localVarFetchArgs = exports.GroupControllerApiFetchParamCreator(configuration).deleteGroup(groupId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all Contact Groups in paginated format
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllGroups: function (page, size, sort, options) {
            var localVarFetchArgs = exports.GroupControllerApiFetchParamCreator(configuration).getAllGroups(page, size, sort, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get group
         * @param {string} groupId groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup: function (groupId, options) {
            var localVarFetchArgs = exports.GroupControllerApiFetchParamCreator(configuration).getGroup(groupId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get group and contacts belonging to it
         * @param {string} groupId groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupWithContacts: function (groupId, options) {
            var localVarFetchArgs = exports.GroupControllerApiFetchParamCreator(configuration).getGroupWithContacts(groupId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get group and paginated contacts belonging to it
         * @param {string} groupId groupId
         * @param {number} [page] Optional page index in group contact pagination
         * @param {number} [size] Optional page size in group contact pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupWithContactsPaginated: function (groupId, page, size, sort, options) {
            var localVarFetchArgs = exports.GroupControllerApiFetchParamCreator(configuration).getGroupWithContactsPaginated(groupId, page, size, sort, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups: function (options) {
            var localVarFetchArgs = exports.GroupControllerApiFetchParamCreator(configuration).getGroups(options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Remove contacts from a group
         * @param {string} groupId groupId
         * @param {UpdateGroupContacts} updateGroupContactsOption updateGroupContactsOption
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeContactsFromGroup: function (groupId, updateGroupContactsOption, options) {
            var localVarFetchArgs = exports.GroupControllerApiFetchParamCreator(configuration).removeContactsFromGroup(groupId, updateGroupContactsOption, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.GroupControllerApiFp = GroupControllerApiFp;
/**
 * GroupControllerApi - factory interface
 * @export
 */
var GroupControllerApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Add contacts to a group
         * @param {string} groupId groupId
         * @param {UpdateGroupContacts} updateGroupContactsOption updateGroupContactsOption
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addContactsToGroup: function (groupId, updateGroupContactsOption, options) {
            return exports.GroupControllerApiFp(configuration).addContactsToGroup(groupId, updateGroupContactsOption, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a group
         * @param {CreateGroupOptions} createGroupOptions createGroupOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup: function (createGroupOptions, options) {
            return exports.GroupControllerApiFp(configuration).createGroup(createGroupOptions, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete group
         * @param {string} groupId groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup: function (groupId, options) {
            return exports.GroupControllerApiFp(configuration).deleteGroup(groupId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get all Contact Groups in paginated format
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllGroups: function (page, size, sort, options) {
            return exports.GroupControllerApiFp(configuration).getAllGroups(page, size, sort, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get group
         * @param {string} groupId groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup: function (groupId, options) {
            return exports.GroupControllerApiFp(configuration).getGroup(groupId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get group and contacts belonging to it
         * @param {string} groupId groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupWithContacts: function (groupId, options) {
            return exports.GroupControllerApiFp(configuration).getGroupWithContacts(groupId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get group and paginated contacts belonging to it
         * @param {string} groupId groupId
         * @param {number} [page] Optional page index in group contact pagination
         * @param {number} [size] Optional page size in group contact pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupWithContactsPaginated: function (groupId, page, size, sort, options) {
            return exports.GroupControllerApiFp(configuration).getGroupWithContactsPaginated(groupId, page, size, sort, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get all groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups: function (options) {
            return exports.GroupControllerApiFp(configuration).getGroups(options)(fetch, basePath);
        },
        /**
         *
         * @summary Remove contacts from a group
         * @param {string} groupId groupId
         * @param {UpdateGroupContacts} updateGroupContactsOption updateGroupContactsOption
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeContactsFromGroup: function (groupId, updateGroupContactsOption, options) {
            return exports.GroupControllerApiFp(configuration).removeContactsFromGroup(groupId, updateGroupContactsOption, options)(fetch, basePath);
        },
    };
};
exports.GroupControllerApiFactory = GroupControllerApiFactory;
/**
 * GroupControllerApi - object-oriented interface
 * @export
 * @class GroupControllerApi
 * @extends {BaseAPI}
 */
var GroupControllerApi = /** @class */ (function (_super) {
    __extends(GroupControllerApi, _super);
    function GroupControllerApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Add contacts to a group
     * @param {string} groupId groupId
     * @param {UpdateGroupContacts} updateGroupContactsOption updateGroupContactsOption
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupControllerApi
     */
    GroupControllerApi.prototype.addContactsToGroup = function (groupId, updateGroupContactsOption, options) {
        return exports.GroupControllerApiFp(this.configuration).addContactsToGroup(groupId, updateGroupContactsOption, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Create a group
     * @param {CreateGroupOptions} createGroupOptions createGroupOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupControllerApi
     */
    GroupControllerApi.prototype.createGroup = function (createGroupOptions, options) {
        return exports.GroupControllerApiFp(this.configuration).createGroup(createGroupOptions, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Delete group
     * @param {string} groupId groupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupControllerApi
     */
    GroupControllerApi.prototype.deleteGroup = function (groupId, options) {
        return exports.GroupControllerApiFp(this.configuration).deleteGroup(groupId, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Get all Contact Groups in paginated format
     * @param {number} [page] Optional page index in inbox list pagination
     * @param {number} [size] Optional page size in inbox list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupControllerApi
     */
    GroupControllerApi.prototype.getAllGroups = function (page, size, sort, options) {
        return exports.GroupControllerApiFp(this.configuration).getAllGroups(page, size, sort, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Get group
     * @param {string} groupId groupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupControllerApi
     */
    GroupControllerApi.prototype.getGroup = function (groupId, options) {
        return exports.GroupControllerApiFp(this.configuration).getGroup(groupId, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Get group and contacts belonging to it
     * @param {string} groupId groupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupControllerApi
     */
    GroupControllerApi.prototype.getGroupWithContacts = function (groupId, options) {
        return exports.GroupControllerApiFp(this.configuration).getGroupWithContacts(groupId, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Get group and paginated contacts belonging to it
     * @param {string} groupId groupId
     * @param {number} [page] Optional page index in group contact pagination
     * @param {number} [size] Optional page size in group contact pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupControllerApi
     */
    GroupControllerApi.prototype.getGroupWithContactsPaginated = function (groupId, page, size, sort, options) {
        return exports.GroupControllerApiFp(this.configuration).getGroupWithContactsPaginated(groupId, page, size, sort, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Get all groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupControllerApi
     */
    GroupControllerApi.prototype.getGroups = function (options) {
        return exports.GroupControllerApiFp(this.configuration).getGroups(options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Remove contacts from a group
     * @param {string} groupId groupId
     * @param {UpdateGroupContacts} updateGroupContactsOption updateGroupContactsOption
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupControllerApi
     */
    GroupControllerApi.prototype.removeContactsFromGroup = function (groupId, updateGroupContactsOption, options) {
        return exports.GroupControllerApiFp(this.configuration).removeContactsFromGroup(groupId, updateGroupContactsOption, options)(this.fetch, this.basePath);
    };
    return GroupControllerApi;
}(BaseAPI));
exports.GroupControllerApi = GroupControllerApi;
/**
 * InboxControllerApi - fetch parameter creator
 * @export
 */
var InboxControllerApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Create a new inbox and with a randomized email address to send and receive from. Pass emailAddress parameter if you wish to use a specific email address. Creating an inbox is required before sending or receiving emails. If writing tests it is recommended that you create a new inbox during each test method so that it is unique and empty.
         * @summary Create an Inbox (email address)
         * @param {string} [description] Optional description for an inbox.
         * @param {string} [emailAddress] Optional email address including domain you wish inbox to use (eg: test123@mydomain.com). Only supports domains that you have registered and verified with MailSlurp using dashboard or &#x60;createDomain&#x60; method.
         * @param {Date} [expiresAt] Optional expires at timestamp. If your plan supports this feature you can specify when an inbox should expire. If left empty inbox will exist permanently or expire when your plan dictates
         * @param {boolean} [favourite] Is inbox favourited.
         * @param {string} [name] Optional name for an inbox.
         * @param {Array<string>} [tags] Optional tags for an inbox. Can be used for searching and filtering inboxes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInbox: function (description, emailAddress, expiresAt, favourite, name, tags, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/inboxes";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }
            if (emailAddress !== undefined) {
                localVarQueryParameter['emailAddress'] = emailAddress;
            }
            if (expiresAt !== undefined) {
                localVarQueryParameter['expiresAt'] = expiresAt.toISOString();
            }
            if (favourite !== undefined) {
                localVarQueryParameter['favourite'] = favourite;
            }
            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }
            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently delete all inboxes and associated email addresses. This will also delete all emails within the inboxes. Be careful as inboxes cannot be recovered once deleted. Note: deleting inboxes will not impact your usage limits. Monthly inbox creation limits are based on how many inboxes were created in the last 30 days, not how many inboxes you currently have.
         * @summary Delete all inboxes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllInboxes: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/inboxes";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently delete an inbox and associated email address aswell as all emails within the given inbox. This action cannot be undone. Note: deleting an inbox will not affect your account usage. Monthly inbox usage is based on how many inboxes you create within 30 days, not how many exist at time of request.
         * @summary Delete inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInbox: function (inboxId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError('inboxId', 'Required parameter inboxId was null or undefined when calling deleteInbox.');
            }
            var localVarPath = "/inboxes/{inboxId}".replace("{" + 'inboxId' + "}", encodeURIComponent(String(inboxId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List inboxes in paginated form. Allows for page index, page size, and sort direction. Can also filter by favourited or email address like pattern.
         * @summary List Inboxes Paginated
         * @param {boolean} [favourite] Optionally filter results for favourites only
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {string} [search] Optionally filter by search words partial matching ID, tags, name, and email address
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {string} [tag] Optionally filter by tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllInboxes: function (favourite, page, search, size, sort, tag, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/inboxes/paginated";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (favourite !== undefined) {
                localVarQueryParameter['favourite'] = favourite;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List emails that an inbox has received. Only emails that are sent to the inbox's email address will appear in the inbox. It may take several seconds for any email you send to an inbox's email address to appear in the inbox. To make this endpoint wait for a minimum number of emails use the `minCount` parameter. The server will retry the inbox database until the `minCount` is satisfied or the `retryTimeout` is reached
         * @summary Get emails in an Inbox
         * @param {string} inboxId Id of inbox that emails belongs to
         * @param {number} [limit] Limit the result set, ordered by received date time sort direction
         * @param {number} [minCount] Minimum acceptable email count. Will cause request to hang (and retry) until minCount is satisfied or retryTimeout is reached.
         * @param {number} [retryTimeout] Maximum milliseconds to spend retrying inbox database until minCount emails are returned
         * @param {Date} [since] Exclude emails received before this ISO 8601 date time
         * @param {'ASC' | 'DESC'} [sort] Sort the results by received date and direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmails: function (inboxId, limit, minCount, retryTimeout, since, sort, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError('inboxId', 'Required parameter inboxId was null or undefined when calling getEmails.');
            }
            var localVarPath = "/inboxes/{inboxId}/emails".replace("{" + 'inboxId' + "}", encodeURIComponent(String(inboxId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (minCount !== undefined) {
                localVarQueryParameter['minCount'] = minCount;
            }
            if (retryTimeout !== undefined) {
                localVarQueryParameter['retryTimeout'] = retryTimeout;
            }
            if (since !== undefined) {
                localVarQueryParameter['since'] = since.toISOString();
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an inbox's properties, including its email address and ID.
         * @summary Get Inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInbox: function (inboxId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError('inboxId', 'Required parameter inboxId was null or undefined when calling getInbox.');
            }
            var localVarPath = "/inboxes/{inboxId}".replace("{" + 'inboxId' + "}", encodeURIComponent(String(inboxId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a paginated list of emails in an inbox. Does not hold connections open.
         * @summary Get inbox emails paginated
         * @param {string} inboxId Id of inbox that emails belongs to
         * @param {number} [page] Optional page index in inbox emails list pagination
         * @param {number} [size] Optional page size in inbox emails list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxEmailsPaginated: function (inboxId, page, size, sort, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError('inboxId', 'Required parameter inboxId was null or undefined when calling getInboxEmailsPaginated.');
            }
            var localVarPath = "/inboxes/{inboxId}/emails/paginated".replace("{" + 'inboxId' + "}", encodeURIComponent(String(inboxId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an inbox's sent email receipts. Call individual sent email endpoints for more details. Note for privacy reasons the full body of sent emails is never stored. An MD5 hash hex is available for comparison instead.
         * @summary Get Inbox Sent Emails
         * @param {string} inboxId inboxId
         * @param {number} [page] Optional page index in inbox sent email list pagination
         * @param {number} [size] Optional page size in inbox sent email list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxSentEmails: function (inboxId, page, size, sort, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError('inboxId', 'Required parameter inboxId was null or undefined when calling getInboxSentEmails.');
            }
            var localVarPath = "/inboxes/{inboxId}/sent".replace("{" + 'inboxId' + "}", encodeURIComponent(String(inboxId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all inbox tags
         * @summary Get inbox tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxTags: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/inboxes/tags";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the inboxes you have created
         * @summary List Inboxes / Email Addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxes: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/inboxes";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send an email from an inbox's email address.  The request body should contain the `SendEmailOptions` that include recipients, attachments, body etc. See `SendEmailOptions` for all available properties. Note the `inboxId` refers to the inbox's id not the inbox's email address. See https://www.mailslurp.com/guides/ for more information on how to send emails. This method does not return a sent email entity due to legacy reasons. To send and get a sent email as returned response use the sister method `sendEmailAndConfirm`.
         * @summary Send Email
         * @param {string} inboxId ID of the inbox you want to send the email from
         * @param {SendEmailOptions} [sendEmailOptions] Options for the email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmail: function (inboxId, sendEmailOptions, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError('inboxId', 'Required parameter inboxId was null or undefined when calling sendEmail.');
            }
            var localVarPath = "/inboxes/{inboxId}".replace("{" + 'inboxId' + "}", encodeURIComponent(String(inboxId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'SendEmailOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(sendEmailOptions || {})
                : sendEmailOptions || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sister method for standard `sendEmail` method with the benefit of returning a `SentEmail` entity confirming the successful sending of the email with link the the sent object created for it.
         * @summary Send email and return sent confirmation
         * @param {string} inboxId ID of the inbox you want to send the email from
         * @param {SendEmailOptions} [sendEmailOptions] Options for the email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailAndConfirm: function (inboxId, sendEmailOptions, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError('inboxId', 'Required parameter inboxId was null or undefined when calling sendEmailAndConfirm.');
            }
            var localVarPath = "/inboxes/{inboxId}/confirm".replace("{" + 'inboxId' + "}", encodeURIComponent(String(inboxId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'SendEmailOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(sendEmailOptions || {})
                : sendEmailOptions || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set and return new favourite state for an inbox
         * @summary Set inbox favourited state
         * @param {string} inboxId inboxId
         * @param {SetInboxFavouritedOptions} setInboxFavouritedOptions setInboxFavouritedOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setInboxFavourited: function (inboxId, setInboxFavouritedOptions, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError('inboxId', 'Required parameter inboxId was null or undefined when calling setInboxFavourited.');
            }
            // verify required parameter 'setInboxFavouritedOptions' is not null or undefined
            if (setInboxFavouritedOptions === null ||
                setInboxFavouritedOptions === undefined) {
                throw new RequiredError('setInboxFavouritedOptions', 'Required parameter setInboxFavouritedOptions was null or undefined when calling setInboxFavourited.');
            }
            var localVarPath = "/inboxes/{inboxId}/favourite".replace("{" + 'inboxId' + "}", encodeURIComponent(String(inboxId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'SetInboxFavouritedOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(setInboxFavouritedOptions || {})
                : setInboxFavouritedOptions || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update editable fields on an inbox
         * @summary Update Inbox
         * @param {string} inboxId inboxId
         * @param {UpdateInboxOptions} updateInboxOptions updateInboxOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInbox: function (inboxId, updateInboxOptions, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError('inboxId', 'Required parameter inboxId was null or undefined when calling updateInbox.');
            }
            // verify required parameter 'updateInboxOptions' is not null or undefined
            if (updateInboxOptions === null ||
                updateInboxOptions === undefined) {
                throw new RequiredError('updateInboxOptions', 'Required parameter updateInboxOptions was null or undefined when calling updateInbox.');
            }
            var localVarPath = "/inboxes/{inboxId}".replace("{" + 'inboxId' + "}", encodeURIComponent(String(inboxId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'UpdateInboxOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(updateInboxOptions || {})
                : updateInboxOptions || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.InboxControllerApiFetchParamCreator = InboxControllerApiFetchParamCreator;
/**
 * InboxControllerApi - functional programming interface
 * @export
 */
var InboxControllerApiFp = function (configuration) {
    return {
        /**
         * Create a new inbox and with a randomized email address to send and receive from. Pass emailAddress parameter if you wish to use a specific email address. Creating an inbox is required before sending or receiving emails. If writing tests it is recommended that you create a new inbox during each test method so that it is unique and empty.
         * @summary Create an Inbox (email address)
         * @param {string} [description] Optional description for an inbox.
         * @param {string} [emailAddress] Optional email address including domain you wish inbox to use (eg: test123@mydomain.com). Only supports domains that you have registered and verified with MailSlurp using dashboard or &#x60;createDomain&#x60; method.
         * @param {Date} [expiresAt] Optional expires at timestamp. If your plan supports this feature you can specify when an inbox should expire. If left empty inbox will exist permanently or expire when your plan dictates
         * @param {boolean} [favourite] Is inbox favourited.
         * @param {string} [name] Optional name for an inbox.
         * @param {Array<string>} [tags] Optional tags for an inbox. Can be used for searching and filtering inboxes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInbox: function (description, emailAddress, expiresAt, favourite, name, tags, options) {
            var localVarFetchArgs = exports.InboxControllerApiFetchParamCreator(configuration).createInbox(description, emailAddress, expiresAt, favourite, name, tags, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Permanently delete all inboxes and associated email addresses. This will also delete all emails within the inboxes. Be careful as inboxes cannot be recovered once deleted. Note: deleting inboxes will not impact your usage limits. Monthly inbox creation limits are based on how many inboxes were created in the last 30 days, not how many inboxes you currently have.
         * @summary Delete all inboxes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllInboxes: function (options) {
            var localVarFetchArgs = exports.InboxControllerApiFetchParamCreator(configuration).deleteAllInboxes(options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Permanently delete an inbox and associated email address aswell as all emails within the given inbox. This action cannot be undone. Note: deleting an inbox will not affect your account usage. Monthly inbox usage is based on how many inboxes you create within 30 days, not how many exist at time of request.
         * @summary Delete inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInbox: function (inboxId, options) {
            var localVarFetchArgs = exports.InboxControllerApiFetchParamCreator(configuration).deleteInbox(inboxId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List inboxes in paginated form. Allows for page index, page size, and sort direction. Can also filter by favourited or email address like pattern.
         * @summary List Inboxes Paginated
         * @param {boolean} [favourite] Optionally filter results for favourites only
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {string} [search] Optionally filter by search words partial matching ID, tags, name, and email address
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {string} [tag] Optionally filter by tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllInboxes: function (favourite, page, search, size, sort, tag, options) {
            var localVarFetchArgs = exports.InboxControllerApiFetchParamCreator(configuration).getAllInboxes(favourite, page, search, size, sort, tag, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List emails that an inbox has received. Only emails that are sent to the inbox's email address will appear in the inbox. It may take several seconds for any email you send to an inbox's email address to appear in the inbox. To make this endpoint wait for a minimum number of emails use the `minCount` parameter. The server will retry the inbox database until the `minCount` is satisfied or the `retryTimeout` is reached
         * @summary Get emails in an Inbox
         * @param {string} inboxId Id of inbox that emails belongs to
         * @param {number} [limit] Limit the result set, ordered by received date time sort direction
         * @param {number} [minCount] Minimum acceptable email count. Will cause request to hang (and retry) until minCount is satisfied or retryTimeout is reached.
         * @param {number} [retryTimeout] Maximum milliseconds to spend retrying inbox database until minCount emails are returned
         * @param {Date} [since] Exclude emails received before this ISO 8601 date time
         * @param {'ASC' | 'DESC'} [sort] Sort the results by received date and direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmails: function (inboxId, limit, minCount, retryTimeout, since, sort, options) {
            var localVarFetchArgs = exports.InboxControllerApiFetchParamCreator(configuration).getEmails(inboxId, limit, minCount, retryTimeout, since, sort, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns an inbox's properties, including its email address and ID.
         * @summary Get Inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInbox: function (inboxId, options) {
            var localVarFetchArgs = exports.InboxControllerApiFetchParamCreator(configuration).getInbox(inboxId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a paginated list of emails in an inbox. Does not hold connections open.
         * @summary Get inbox emails paginated
         * @param {string} inboxId Id of inbox that emails belongs to
         * @param {number} [page] Optional page index in inbox emails list pagination
         * @param {number} [size] Optional page size in inbox emails list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxEmailsPaginated: function (inboxId, page, size, sort, options) {
            var localVarFetchArgs = exports.InboxControllerApiFetchParamCreator(configuration).getInboxEmailsPaginated(inboxId, page, size, sort, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns an inbox's sent email receipts. Call individual sent email endpoints for more details. Note for privacy reasons the full body of sent emails is never stored. An MD5 hash hex is available for comparison instead.
         * @summary Get Inbox Sent Emails
         * @param {string} inboxId inboxId
         * @param {number} [page] Optional page index in inbox sent email list pagination
         * @param {number} [size] Optional page size in inbox sent email list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxSentEmails: function (inboxId, page, size, sort, options) {
            var localVarFetchArgs = exports.InboxControllerApiFetchParamCreator(configuration).getInboxSentEmails(inboxId, page, size, sort, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all inbox tags
         * @summary Get inbox tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxTags: function (options) {
            var localVarFetchArgs = exports.InboxControllerApiFetchParamCreator(configuration).getInboxTags(options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List the inboxes you have created
         * @summary List Inboxes / Email Addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxes: function (options) {
            var localVarFetchArgs = exports.InboxControllerApiFetchParamCreator(configuration).getInboxes(options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Send an email from an inbox's email address.  The request body should contain the `SendEmailOptions` that include recipients, attachments, body etc. See `SendEmailOptions` for all available properties. Note the `inboxId` refers to the inbox's id not the inbox's email address. See https://www.mailslurp.com/guides/ for more information on how to send emails. This method does not return a sent email entity due to legacy reasons. To send and get a sent email as returned response use the sister method `sendEmailAndConfirm`.
         * @summary Send Email
         * @param {string} inboxId ID of the inbox you want to send the email from
         * @param {SendEmailOptions} [sendEmailOptions] Options for the email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmail: function (inboxId, sendEmailOptions, options) {
            var localVarFetchArgs = exports.InboxControllerApiFetchParamCreator(configuration).sendEmail(inboxId, sendEmailOptions, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Sister method for standard `sendEmail` method with the benefit of returning a `SentEmail` entity confirming the successful sending of the email with link the the sent object created for it.
         * @summary Send email and return sent confirmation
         * @param {string} inboxId ID of the inbox you want to send the email from
         * @param {SendEmailOptions} [sendEmailOptions] Options for the email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailAndConfirm: function (inboxId, sendEmailOptions, options) {
            var localVarFetchArgs = exports.InboxControllerApiFetchParamCreator(configuration).sendEmailAndConfirm(inboxId, sendEmailOptions, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Set and return new favourite state for an inbox
         * @summary Set inbox favourited state
         * @param {string} inboxId inboxId
         * @param {SetInboxFavouritedOptions} setInboxFavouritedOptions setInboxFavouritedOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setInboxFavourited: function (inboxId, setInboxFavouritedOptions, options) {
            var localVarFetchArgs = exports.InboxControllerApiFetchParamCreator(configuration).setInboxFavourited(inboxId, setInboxFavouritedOptions, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update editable fields on an inbox
         * @summary Update Inbox
         * @param {string} inboxId inboxId
         * @param {UpdateInboxOptions} updateInboxOptions updateInboxOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInbox: function (inboxId, updateInboxOptions, options) {
            var localVarFetchArgs = exports.InboxControllerApiFetchParamCreator(configuration).updateInbox(inboxId, updateInboxOptions, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.InboxControllerApiFp = InboxControllerApiFp;
/**
 * InboxControllerApi - factory interface
 * @export
 */
var InboxControllerApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Create a new inbox and with a randomized email address to send and receive from. Pass emailAddress parameter if you wish to use a specific email address. Creating an inbox is required before sending or receiving emails. If writing tests it is recommended that you create a new inbox during each test method so that it is unique and empty.
         * @summary Create an Inbox (email address)
         * @param {string} [description] Optional description for an inbox.
         * @param {string} [emailAddress] Optional email address including domain you wish inbox to use (eg: test123@mydomain.com). Only supports domains that you have registered and verified with MailSlurp using dashboard or &#x60;createDomain&#x60; method.
         * @param {Date} [expiresAt] Optional expires at timestamp. If your plan supports this feature you can specify when an inbox should expire. If left empty inbox will exist permanently or expire when your plan dictates
         * @param {boolean} [favourite] Is inbox favourited.
         * @param {string} [name] Optional name for an inbox.
         * @param {Array<string>} [tags] Optional tags for an inbox. Can be used for searching and filtering inboxes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInbox: function (description, emailAddress, expiresAt, favourite, name, tags, options) {
            return exports.InboxControllerApiFp(configuration).createInbox(description, emailAddress, expiresAt, favourite, name, tags, options)(fetch, basePath);
        },
        /**
         * Permanently delete all inboxes and associated email addresses. This will also delete all emails within the inboxes. Be careful as inboxes cannot be recovered once deleted. Note: deleting inboxes will not impact your usage limits. Monthly inbox creation limits are based on how many inboxes were created in the last 30 days, not how many inboxes you currently have.
         * @summary Delete all inboxes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllInboxes: function (options) {
            return exports.InboxControllerApiFp(configuration).deleteAllInboxes(options)(fetch, basePath);
        },
        /**
         * Permanently delete an inbox and associated email address aswell as all emails within the given inbox. This action cannot be undone. Note: deleting an inbox will not affect your account usage. Monthly inbox usage is based on how many inboxes you create within 30 days, not how many exist at time of request.
         * @summary Delete inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInbox: function (inboxId, options) {
            return exports.InboxControllerApiFp(configuration).deleteInbox(inboxId, options)(fetch, basePath);
        },
        /**
         * List inboxes in paginated form. Allows for page index, page size, and sort direction. Can also filter by favourited or email address like pattern.
         * @summary List Inboxes Paginated
         * @param {boolean} [favourite] Optionally filter results for favourites only
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {string} [search] Optionally filter by search words partial matching ID, tags, name, and email address
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {string} [tag] Optionally filter by tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllInboxes: function (favourite, page, search, size, sort, tag, options) {
            return exports.InboxControllerApiFp(configuration).getAllInboxes(favourite, page, search, size, sort, tag, options)(fetch, basePath);
        },
        /**
         * List emails that an inbox has received. Only emails that are sent to the inbox's email address will appear in the inbox. It may take several seconds for any email you send to an inbox's email address to appear in the inbox. To make this endpoint wait for a minimum number of emails use the `minCount` parameter. The server will retry the inbox database until the `minCount` is satisfied or the `retryTimeout` is reached
         * @summary Get emails in an Inbox
         * @param {string} inboxId Id of inbox that emails belongs to
         * @param {number} [limit] Limit the result set, ordered by received date time sort direction
         * @param {number} [minCount] Minimum acceptable email count. Will cause request to hang (and retry) until minCount is satisfied or retryTimeout is reached.
         * @param {number} [retryTimeout] Maximum milliseconds to spend retrying inbox database until minCount emails are returned
         * @param {Date} [since] Exclude emails received before this ISO 8601 date time
         * @param {'ASC' | 'DESC'} [sort] Sort the results by received date and direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmails: function (inboxId, limit, minCount, retryTimeout, since, sort, options) {
            return exports.InboxControllerApiFp(configuration).getEmails(inboxId, limit, minCount, retryTimeout, since, sort, options)(fetch, basePath);
        },
        /**
         * Returns an inbox's properties, including its email address and ID.
         * @summary Get Inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInbox: function (inboxId, options) {
            return exports.InboxControllerApiFp(configuration).getInbox(inboxId, options)(fetch, basePath);
        },
        /**
         * Get a paginated list of emails in an inbox. Does not hold connections open.
         * @summary Get inbox emails paginated
         * @param {string} inboxId Id of inbox that emails belongs to
         * @param {number} [page] Optional page index in inbox emails list pagination
         * @param {number} [size] Optional page size in inbox emails list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxEmailsPaginated: function (inboxId, page, size, sort, options) {
            return exports.InboxControllerApiFp(configuration).getInboxEmailsPaginated(inboxId, page, size, sort, options)(fetch, basePath);
        },
        /**
         * Returns an inbox's sent email receipts. Call individual sent email endpoints for more details. Note for privacy reasons the full body of sent emails is never stored. An MD5 hash hex is available for comparison instead.
         * @summary Get Inbox Sent Emails
         * @param {string} inboxId inboxId
         * @param {number} [page] Optional page index in inbox sent email list pagination
         * @param {number} [size] Optional page size in inbox sent email list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxSentEmails: function (inboxId, page, size, sort, options) {
            return exports.InboxControllerApiFp(configuration).getInboxSentEmails(inboxId, page, size, sort, options)(fetch, basePath);
        },
        /**
         * Get all inbox tags
         * @summary Get inbox tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxTags: function (options) {
            return exports.InboxControllerApiFp(configuration).getInboxTags(options)(fetch, basePath);
        },
        /**
         * List the inboxes you have created
         * @summary List Inboxes / Email Addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxes: function (options) {
            return exports.InboxControllerApiFp(configuration).getInboxes(options)(fetch, basePath);
        },
        /**
         * Send an email from an inbox's email address.  The request body should contain the `SendEmailOptions` that include recipients, attachments, body etc. See `SendEmailOptions` for all available properties. Note the `inboxId` refers to the inbox's id not the inbox's email address. See https://www.mailslurp.com/guides/ for more information on how to send emails. This method does not return a sent email entity due to legacy reasons. To send and get a sent email as returned response use the sister method `sendEmailAndConfirm`.
         * @summary Send Email
         * @param {string} inboxId ID of the inbox you want to send the email from
         * @param {SendEmailOptions} [sendEmailOptions] Options for the email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmail: function (inboxId, sendEmailOptions, options) {
            return exports.InboxControllerApiFp(configuration).sendEmail(inboxId, sendEmailOptions, options)(fetch, basePath);
        },
        /**
         * Sister method for standard `sendEmail` method with the benefit of returning a `SentEmail` entity confirming the successful sending of the email with link the the sent object created for it.
         * @summary Send email and return sent confirmation
         * @param {string} inboxId ID of the inbox you want to send the email from
         * @param {SendEmailOptions} [sendEmailOptions] Options for the email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailAndConfirm: function (inboxId, sendEmailOptions, options) {
            return exports.InboxControllerApiFp(configuration).sendEmailAndConfirm(inboxId, sendEmailOptions, options)(fetch, basePath);
        },
        /**
         * Set and return new favourite state for an inbox
         * @summary Set inbox favourited state
         * @param {string} inboxId inboxId
         * @param {SetInboxFavouritedOptions} setInboxFavouritedOptions setInboxFavouritedOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setInboxFavourited: function (inboxId, setInboxFavouritedOptions, options) {
            return exports.InboxControllerApiFp(configuration).setInboxFavourited(inboxId, setInboxFavouritedOptions, options)(fetch, basePath);
        },
        /**
         * Update editable fields on an inbox
         * @summary Update Inbox
         * @param {string} inboxId inboxId
         * @param {UpdateInboxOptions} updateInboxOptions updateInboxOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInbox: function (inboxId, updateInboxOptions, options) {
            return exports.InboxControllerApiFp(configuration).updateInbox(inboxId, updateInboxOptions, options)(fetch, basePath);
        },
    };
};
exports.InboxControllerApiFactory = InboxControllerApiFactory;
/**
 * InboxControllerApi - object-oriented interface
 * @export
 * @class InboxControllerApi
 * @extends {BaseAPI}
 */
var InboxControllerApi = /** @class */ (function (_super) {
    __extends(InboxControllerApi, _super);
    function InboxControllerApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Create a new inbox and with a randomized email address to send and receive from. Pass emailAddress parameter if you wish to use a specific email address. Creating an inbox is required before sending or receiving emails. If writing tests it is recommended that you create a new inbox during each test method so that it is unique and empty.
     * @summary Create an Inbox (email address)
     * @param {string} [description] Optional description for an inbox.
     * @param {string} [emailAddress] Optional email address including domain you wish inbox to use (eg: test123@mydomain.com). Only supports domains that you have registered and verified with MailSlurp using dashboard or &#x60;createDomain&#x60; method.
     * @param {Date} [expiresAt] Optional expires at timestamp. If your plan supports this feature you can specify when an inbox should expire. If left empty inbox will exist permanently or expire when your plan dictates
     * @param {boolean} [favourite] Is inbox favourited.
     * @param {string} [name] Optional name for an inbox.
     * @param {Array<string>} [tags] Optional tags for an inbox. Can be used for searching and filtering inboxes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    InboxControllerApi.prototype.createInbox = function (description, emailAddress, expiresAt, favourite, name, tags, options) {
        return exports.InboxControllerApiFp(this.configuration).createInbox(description, emailAddress, expiresAt, favourite, name, tags, options)(this.fetch, this.basePath);
    };
    /**
     * Permanently delete all inboxes and associated email addresses. This will also delete all emails within the inboxes. Be careful as inboxes cannot be recovered once deleted. Note: deleting inboxes will not impact your usage limits. Monthly inbox creation limits are based on how many inboxes were created in the last 30 days, not how many inboxes you currently have.
     * @summary Delete all inboxes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    InboxControllerApi.prototype.deleteAllInboxes = function (options) {
        return exports.InboxControllerApiFp(this.configuration).deleteAllInboxes(options)(this.fetch, this.basePath);
    };
    /**
     * Permanently delete an inbox and associated email address aswell as all emails within the given inbox. This action cannot be undone. Note: deleting an inbox will not affect your account usage. Monthly inbox usage is based on how many inboxes you create within 30 days, not how many exist at time of request.
     * @summary Delete inbox
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    InboxControllerApi.prototype.deleteInbox = function (inboxId, options) {
        return exports.InboxControllerApiFp(this.configuration).deleteInbox(inboxId, options)(this.fetch, this.basePath);
    };
    /**
     * List inboxes in paginated form. Allows for page index, page size, and sort direction. Can also filter by favourited or email address like pattern.
     * @summary List Inboxes Paginated
     * @param {boolean} [favourite] Optionally filter results for favourites only
     * @param {number} [page] Optional page index in inbox list pagination
     * @param {string} [search] Optionally filter by search words partial matching ID, tags, name, and email address
     * @param {number} [size] Optional page size in inbox list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {string} [tag] Optionally filter by tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    InboxControllerApi.prototype.getAllInboxes = function (favourite, page, search, size, sort, tag, options) {
        return exports.InboxControllerApiFp(this.configuration).getAllInboxes(favourite, page, search, size, sort, tag, options)(this.fetch, this.basePath);
    };
    /**
     * List emails that an inbox has received. Only emails that are sent to the inbox's email address will appear in the inbox. It may take several seconds for any email you send to an inbox's email address to appear in the inbox. To make this endpoint wait for a minimum number of emails use the `minCount` parameter. The server will retry the inbox database until the `minCount` is satisfied or the `retryTimeout` is reached
     * @summary Get emails in an Inbox
     * @param {string} inboxId Id of inbox that emails belongs to
     * @param {number} [limit] Limit the result set, ordered by received date time sort direction
     * @param {number} [minCount] Minimum acceptable email count. Will cause request to hang (and retry) until minCount is satisfied or retryTimeout is reached.
     * @param {number} [retryTimeout] Maximum milliseconds to spend retrying inbox database until minCount emails are returned
     * @param {Date} [since] Exclude emails received before this ISO 8601 date time
     * @param {'ASC' | 'DESC'} [sort] Sort the results by received date and direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    InboxControllerApi.prototype.getEmails = function (inboxId, limit, minCount, retryTimeout, since, sort, options) {
        return exports.InboxControllerApiFp(this.configuration).getEmails(inboxId, limit, minCount, retryTimeout, since, sort, options)(this.fetch, this.basePath);
    };
    /**
     * Returns an inbox's properties, including its email address and ID.
     * @summary Get Inbox
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    InboxControllerApi.prototype.getInbox = function (inboxId, options) {
        return exports.InboxControllerApiFp(this.configuration).getInbox(inboxId, options)(this.fetch, this.basePath);
    };
    /**
     * Get a paginated list of emails in an inbox. Does not hold connections open.
     * @summary Get inbox emails paginated
     * @param {string} inboxId Id of inbox that emails belongs to
     * @param {number} [page] Optional page index in inbox emails list pagination
     * @param {number} [size] Optional page size in inbox emails list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    InboxControllerApi.prototype.getInboxEmailsPaginated = function (inboxId, page, size, sort, options) {
        return exports.InboxControllerApiFp(this.configuration).getInboxEmailsPaginated(inboxId, page, size, sort, options)(this.fetch, this.basePath);
    };
    /**
     * Returns an inbox's sent email receipts. Call individual sent email endpoints for more details. Note for privacy reasons the full body of sent emails is never stored. An MD5 hash hex is available for comparison instead.
     * @summary Get Inbox Sent Emails
     * @param {string} inboxId inboxId
     * @param {number} [page] Optional page index in inbox sent email list pagination
     * @param {number} [size] Optional page size in inbox sent email list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    InboxControllerApi.prototype.getInboxSentEmails = function (inboxId, page, size, sort, options) {
        return exports.InboxControllerApiFp(this.configuration).getInboxSentEmails(inboxId, page, size, sort, options)(this.fetch, this.basePath);
    };
    /**
     * Get all inbox tags
     * @summary Get inbox tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    InboxControllerApi.prototype.getInboxTags = function (options) {
        return exports.InboxControllerApiFp(this.configuration).getInboxTags(options)(this.fetch, this.basePath);
    };
    /**
     * List the inboxes you have created
     * @summary List Inboxes / Email Addresses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    InboxControllerApi.prototype.getInboxes = function (options) {
        return exports.InboxControllerApiFp(this.configuration).getInboxes(options)(this.fetch, this.basePath);
    };
    /**
     * Send an email from an inbox's email address.  The request body should contain the `SendEmailOptions` that include recipients, attachments, body etc. See `SendEmailOptions` for all available properties. Note the `inboxId` refers to the inbox's id not the inbox's email address. See https://www.mailslurp.com/guides/ for more information on how to send emails. This method does not return a sent email entity due to legacy reasons. To send and get a sent email as returned response use the sister method `sendEmailAndConfirm`.
     * @summary Send Email
     * @param {string} inboxId ID of the inbox you want to send the email from
     * @param {SendEmailOptions} [sendEmailOptions] Options for the email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    InboxControllerApi.prototype.sendEmail = function (inboxId, sendEmailOptions, options) {
        return exports.InboxControllerApiFp(this.configuration).sendEmail(inboxId, sendEmailOptions, options)(this.fetch, this.basePath);
    };
    /**
     * Sister method for standard `sendEmail` method with the benefit of returning a `SentEmail` entity confirming the successful sending of the email with link the the sent object created for it.
     * @summary Send email and return sent confirmation
     * @param {string} inboxId ID of the inbox you want to send the email from
     * @param {SendEmailOptions} [sendEmailOptions] Options for the email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    InboxControllerApi.prototype.sendEmailAndConfirm = function (inboxId, sendEmailOptions, options) {
        return exports.InboxControllerApiFp(this.configuration).sendEmailAndConfirm(inboxId, sendEmailOptions, options)(this.fetch, this.basePath);
    };
    /**
     * Set and return new favourite state for an inbox
     * @summary Set inbox favourited state
     * @param {string} inboxId inboxId
     * @param {SetInboxFavouritedOptions} setInboxFavouritedOptions setInboxFavouritedOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    InboxControllerApi.prototype.setInboxFavourited = function (inboxId, setInboxFavouritedOptions, options) {
        return exports.InboxControllerApiFp(this.configuration).setInboxFavourited(inboxId, setInboxFavouritedOptions, options)(this.fetch, this.basePath);
    };
    /**
     * Update editable fields on an inbox
     * @summary Update Inbox
     * @param {string} inboxId inboxId
     * @param {UpdateInboxOptions} updateInboxOptions updateInboxOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    InboxControllerApi.prototype.updateInbox = function (inboxId, updateInboxOptions, options) {
        return exports.InboxControllerApiFp(this.configuration).updateInbox(inboxId, updateInboxOptions, options)(this.fetch, this.basePath);
    };
    return InboxControllerApi;
}(BaseAPI));
exports.InboxControllerApi = InboxControllerApi;
/**
 * MailServerControllerApi - fetch parameter creator
 * @export
 */
var MailServerControllerApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get DNS Mail Server records for a domain
         * @param {DescribeDomainOptions} describeOptions describeOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        describeMailServerDomain: function (describeOptions, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'describeOptions' is not null or undefined
            if (describeOptions === null || describeOptions === undefined) {
                throw new RequiredError('describeOptions', 'Required parameter describeOptions was null or undefined when calling describeMailServerDomain.');
            }
            var localVarPath = "/mail-server/describe/domain";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'DescribeDomainOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(describeOptions || {})
                : describeOptions || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Verify the existence of an email address at a given mail server.
         * @param {VerifyEmailAddressOptions} verifyOptions verifyOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmailAddress: function (verifyOptions, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'verifyOptions' is not null or undefined
            if (verifyOptions === null || verifyOptions === undefined) {
                throw new RequiredError('verifyOptions', 'Required parameter verifyOptions was null or undefined when calling verifyEmailAddress.');
            }
            var localVarPath = "/mail-server/verify/email-address";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'VerifyEmailAddressOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(verifyOptions || {})
                : verifyOptions || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.MailServerControllerApiFetchParamCreator = MailServerControllerApiFetchParamCreator;
/**
 * MailServerControllerApi - functional programming interface
 * @export
 */
var MailServerControllerApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Get DNS Mail Server records for a domain
         * @param {DescribeDomainOptions} describeOptions describeOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        describeMailServerDomain: function (describeOptions, options) {
            var localVarFetchArgs = exports.MailServerControllerApiFetchParamCreator(configuration).describeMailServerDomain(describeOptions, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Verify the existence of an email address at a given mail server.
         * @param {VerifyEmailAddressOptions} verifyOptions verifyOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmailAddress: function (verifyOptions, options) {
            var localVarFetchArgs = exports.MailServerControllerApiFetchParamCreator(configuration).verifyEmailAddress(verifyOptions, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.MailServerControllerApiFp = MailServerControllerApiFp;
/**
 * MailServerControllerApi - factory interface
 * @export
 */
var MailServerControllerApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Get DNS Mail Server records for a domain
         * @param {DescribeDomainOptions} describeOptions describeOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        describeMailServerDomain: function (describeOptions, options) {
            return exports.MailServerControllerApiFp(configuration).describeMailServerDomain(describeOptions, options)(fetch, basePath);
        },
        /**
         *
         * @summary Verify the existence of an email address at a given mail server.
         * @param {VerifyEmailAddressOptions} verifyOptions verifyOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmailAddress: function (verifyOptions, options) {
            return exports.MailServerControllerApiFp(configuration).verifyEmailAddress(verifyOptions, options)(fetch, basePath);
        },
    };
};
exports.MailServerControllerApiFactory = MailServerControllerApiFactory;
/**
 * MailServerControllerApi - object-oriented interface
 * @export
 * @class MailServerControllerApi
 * @extends {BaseAPI}
 */
var MailServerControllerApi = /** @class */ (function (_super) {
    __extends(MailServerControllerApi, _super);
    function MailServerControllerApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Get DNS Mail Server records for a domain
     * @param {DescribeDomainOptions} describeOptions describeOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailServerControllerApi
     */
    MailServerControllerApi.prototype.describeMailServerDomain = function (describeOptions, options) {
        return exports.MailServerControllerApiFp(this.configuration).describeMailServerDomain(describeOptions, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Verify the existence of an email address at a given mail server.
     * @param {VerifyEmailAddressOptions} verifyOptions verifyOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailServerControllerApi
     */
    MailServerControllerApi.prototype.verifyEmailAddress = function (verifyOptions, options) {
        return exports.MailServerControllerApiFp(this.configuration).verifyEmailAddress(verifyOptions, options)(this.fetch, this.basePath);
    };
    return MailServerControllerApi;
}(BaseAPI));
exports.MailServerControllerApi = MailServerControllerApi;
/**
 * SentEmailsControllerApi - fetch parameter creator
 * @export
 */
var SentEmailsControllerApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get sent email receipt
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSentEmail: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling getSentEmail.');
            }
            var localVarPath = "/sent/{id}".replace("{" + 'id' + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all sent emails in paginated form
         * @param {string} [inboxId] Optional inboxId to filter sender of sent emails by
         * @param {number} [page] Optional page index in inbox sent email list pagination
         * @param {number} [size] Optional page size in inbox sent email list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSentEmails: function (inboxId, page, size, sort, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/sent";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (inboxId !== undefined) {
                localVarQueryParameter['inboxId'] = inboxId;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.SentEmailsControllerApiFetchParamCreator = SentEmailsControllerApiFetchParamCreator;
/**
 * SentEmailsControllerApi - functional programming interface
 * @export
 */
var SentEmailsControllerApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Get sent email receipt
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSentEmail: function (id, options) {
            var localVarFetchArgs = exports.SentEmailsControllerApiFetchParamCreator(configuration).getSentEmail(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all sent emails in paginated form
         * @param {string} [inboxId] Optional inboxId to filter sender of sent emails by
         * @param {number} [page] Optional page index in inbox sent email list pagination
         * @param {number} [size] Optional page size in inbox sent email list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSentEmails: function (inboxId, page, size, sort, options) {
            var localVarFetchArgs = exports.SentEmailsControllerApiFetchParamCreator(configuration).getSentEmails(inboxId, page, size, sort, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.SentEmailsControllerApiFp = SentEmailsControllerApiFp;
/**
 * SentEmailsControllerApi - factory interface
 * @export
 */
var SentEmailsControllerApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Get sent email receipt
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSentEmail: function (id, options) {
            return exports.SentEmailsControllerApiFp(configuration).getSentEmail(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get all sent emails in paginated form
         * @param {string} [inboxId] Optional inboxId to filter sender of sent emails by
         * @param {number} [page] Optional page index in inbox sent email list pagination
         * @param {number} [size] Optional page size in inbox sent email list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSentEmails: function (inboxId, page, size, sort, options) {
            return exports.SentEmailsControllerApiFp(configuration).getSentEmails(inboxId, page, size, sort, options)(fetch, basePath);
        },
    };
};
exports.SentEmailsControllerApiFactory = SentEmailsControllerApiFactory;
/**
 * SentEmailsControllerApi - object-oriented interface
 * @export
 * @class SentEmailsControllerApi
 * @extends {BaseAPI}
 */
var SentEmailsControllerApi = /** @class */ (function (_super) {
    __extends(SentEmailsControllerApi, _super);
    function SentEmailsControllerApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Get sent email receipt
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SentEmailsControllerApi
     */
    SentEmailsControllerApi.prototype.getSentEmail = function (id, options) {
        return exports.SentEmailsControllerApiFp(this.configuration).getSentEmail(id, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Get all sent emails in paginated form
     * @param {string} [inboxId] Optional inboxId to filter sender of sent emails by
     * @param {number} [page] Optional page index in inbox sent email list pagination
     * @param {number} [size] Optional page size in inbox sent email list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SentEmailsControllerApi
     */
    SentEmailsControllerApi.prototype.getSentEmails = function (inboxId, page, size, sort, options) {
        return exports.SentEmailsControllerApiFp(this.configuration).getSentEmails(inboxId, page, size, sort, options)(this.fetch, this.basePath);
    };
    return SentEmailsControllerApi;
}(BaseAPI));
exports.SentEmailsControllerApi = SentEmailsControllerApi;
/**
 * TemplateControllerApi - fetch parameter creator
 * @export
 */
var TemplateControllerApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Create a Template
         * @param {CreateTemplateOptions} createTemplateOptions createTemplateOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTemplate: function (createTemplateOptions, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'createTemplateOptions' is not null or undefined
            if (createTemplateOptions === null ||
                createTemplateOptions === undefined) {
                throw new RequiredError('createTemplateOptions', 'Required parameter createTemplateOptions was null or undefined when calling createTemplate.');
            }
            var localVarPath = "/templates";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'CreateTemplateOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(createTemplateOptions || {})
                : createTemplateOptions || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete Template
         * @param {string} templateId TemplateId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTemplate: function (templateId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'templateId' is not null or undefined
            if (templateId === null || templateId === undefined) {
                throw new RequiredError('templateId', 'Required parameter templateId was null or undefined when calling deleteTemplate.');
            }
            var localVarPath = "/templates/{TemplateId}".replace("{" + 'TemplateId' + "}", encodeURIComponent(String(templateId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Templates in paginated format
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTemplates: function (page, size, sort, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/templates/paginated";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Template
         * @param {string} templateId TemplateId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplate: function (templateId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'templateId' is not null or undefined
            if (templateId === null || templateId === undefined) {
                throw new RequiredError('templateId', 'Required parameter templateId was null or undefined when calling getTemplate.');
            }
            var localVarPath = "/templates/{TemplateId}".replace("{" + 'TemplateId' + "}", encodeURIComponent(String(templateId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplates: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/templates";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.TemplateControllerApiFetchParamCreator = TemplateControllerApiFetchParamCreator;
/**
 * TemplateControllerApi - functional programming interface
 * @export
 */
var TemplateControllerApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Create a Template
         * @param {CreateTemplateOptions} createTemplateOptions createTemplateOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTemplate: function (createTemplateOptions, options) {
            var localVarFetchArgs = exports.TemplateControllerApiFetchParamCreator(configuration).createTemplate(createTemplateOptions, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete Template
         * @param {string} templateId TemplateId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTemplate: function (templateId, options) {
            var localVarFetchArgs = exports.TemplateControllerApiFetchParamCreator(configuration).deleteTemplate(templateId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all Templates in paginated format
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTemplates: function (page, size, sort, options) {
            var localVarFetchArgs = exports.TemplateControllerApiFetchParamCreator(configuration).getAllTemplates(page, size, sort, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get Template
         * @param {string} templateId TemplateId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplate: function (templateId, options) {
            var localVarFetchArgs = exports.TemplateControllerApiFetchParamCreator(configuration).getTemplate(templateId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplates: function (options) {
            var localVarFetchArgs = exports.TemplateControllerApiFetchParamCreator(configuration).getTemplates(options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.TemplateControllerApiFp = TemplateControllerApiFp;
/**
 * TemplateControllerApi - factory interface
 * @export
 */
var TemplateControllerApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Create a Template
         * @param {CreateTemplateOptions} createTemplateOptions createTemplateOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTemplate: function (createTemplateOptions, options) {
            return exports.TemplateControllerApiFp(configuration).createTemplate(createTemplateOptions, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete Template
         * @param {string} templateId TemplateId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTemplate: function (templateId, options) {
            return exports.TemplateControllerApiFp(configuration).deleteTemplate(templateId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get all Templates in paginated format
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTemplates: function (page, size, sort, options) {
            return exports.TemplateControllerApiFp(configuration).getAllTemplates(page, size, sort, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get Template
         * @param {string} templateId TemplateId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplate: function (templateId, options) {
            return exports.TemplateControllerApiFp(configuration).getTemplate(templateId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get all Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplates: function (options) {
            return exports.TemplateControllerApiFp(configuration).getTemplates(options)(fetch, basePath);
        },
    };
};
exports.TemplateControllerApiFactory = TemplateControllerApiFactory;
/**
 * TemplateControllerApi - object-oriented interface
 * @export
 * @class TemplateControllerApi
 * @extends {BaseAPI}
 */
var TemplateControllerApi = /** @class */ (function (_super) {
    __extends(TemplateControllerApi, _super);
    function TemplateControllerApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Create a Template
     * @param {CreateTemplateOptions} createTemplateOptions createTemplateOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateControllerApi
     */
    TemplateControllerApi.prototype.createTemplate = function (createTemplateOptions, options) {
        return exports.TemplateControllerApiFp(this.configuration).createTemplate(createTemplateOptions, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Delete Template
     * @param {string} templateId TemplateId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateControllerApi
     */
    TemplateControllerApi.prototype.deleteTemplate = function (templateId, options) {
        return exports.TemplateControllerApiFp(this.configuration).deleteTemplate(templateId, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Get all Templates in paginated format
     * @param {number} [page] Optional page index in inbox list pagination
     * @param {number} [size] Optional page size in inbox list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateControllerApi
     */
    TemplateControllerApi.prototype.getAllTemplates = function (page, size, sort, options) {
        return exports.TemplateControllerApiFp(this.configuration).getAllTemplates(page, size, sort, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Get Template
     * @param {string} templateId TemplateId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateControllerApi
     */
    TemplateControllerApi.prototype.getTemplate = function (templateId, options) {
        return exports.TemplateControllerApiFp(this.configuration).getTemplate(templateId, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Get all Templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateControllerApi
     */
    TemplateControllerApi.prototype.getTemplates = function (options) {
        return exports.TemplateControllerApiFp(this.configuration).getTemplates(options)(this.fetch, this.basePath);
    };
    return TemplateControllerApi;
}(BaseAPI));
exports.TemplateControllerApi = TemplateControllerApi;
/**
 * WaitForControllerApi - fetch parameter creator
 * @export
 */
var WaitForControllerApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Generic waitFor method that will wait until an inbox meets given conditions or return immediately if already met
         * @summary Wait for conditions to be met
         * @param {WaitForConditions} [waitForConditions] Conditions to wait for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitFor: function (waitForConditions, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/waitFor";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'WaitForConditions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(waitForConditions || {})
                : waitForConditions || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If inbox contains count or more emails at time of request then return count worth of emails. If not wait until the count is reached and return those or return an error if timeout is exceeded.
         * @summary Wait for and return count number of emails
         * @param {number} [count] Number of emails to wait for. Must be greater that 1
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {boolean} [unreadOnly] Optional filter for unread only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForEmailCount: function (count, inboxId, timeout, unreadOnly, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/waitForEmailCount";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (inboxId !== undefined) {
                localVarQueryParameter['inboxId'] = inboxId;
            }
            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }
            if (unreadOnly !== undefined) {
                localVarQueryParameter['unreadOnly'] = unreadOnly;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox set `unreadOnly=true` or see the other receive methods such as `waitForNthEmail` or `waitForEmailCount`.
         * @summary Fetch inbox's latest email or if empty wait for an email to arrive
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {boolean} [unreadOnly] Optional filter for unread only.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForLatestEmail: function (inboxId, timeout, unreadOnly, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/waitForLatestEmail";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (inboxId !== undefined) {
                localVarQueryParameter['inboxId'] = inboxId;
            }
            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }
            if (unreadOnly !== undefined) {
                localVarQueryParameter['unreadOnly'] = unreadOnly;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Perform a search of emails in an inbox with the given patterns. If results match expected count then return or else retry the search until results are found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the `MatchOptions` object for options.
         * @summary Wait or return list of emails that match simple matching patterns
         * @param {MatchOptions} matchOptions matchOptions
         * @param {number} [count] Number of emails to wait for. Must be greater that 1
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {boolean} [unreadOnly] Optional filter for unread only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForMatchingEmail: function (matchOptions, count, inboxId, timeout, unreadOnly, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'matchOptions' is not null or undefined
            if (matchOptions === null || matchOptions === undefined) {
                throw new RequiredError('matchOptions', 'Required parameter matchOptions was null or undefined when calling waitForMatchingEmail.');
            }
            var localVarPath = "/waitForMatchingEmails";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (inboxId !== undefined) {
                localVarQueryParameter['inboxId'] = inboxId;
            }
            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }
            if (unreadOnly !== undefined) {
                localVarQueryParameter['unreadOnly'] = unreadOnly;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'MatchOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(matchOptions || {})
                : matchOptions || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If nth email is already present in inbox then return it. If not hold the connection open until timeout expires or the nth email is received and returned.
         * @summary Wait for or fetch the email with a given index in the inbox specified
         * @param {string} [inboxId] Id of the inbox you are fetching emails from
         * @param {number} [index] Zero based index of the email to wait for. If an inbox has 1 email already and you want to wait for the 2nd email pass index&#x3D;1
         * @param {number} [timeout] Max milliseconds to wait for the nth email if not already present
         * @param {boolean} [unreadOnly] Optional filter for unread only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForNthEmail: function (inboxId, index, timeout, unreadOnly, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/waitForNthEmail";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (inboxId !== undefined) {
                localVarQueryParameter['inboxId'] = inboxId;
            }
            if (index !== undefined) {
                localVarQueryParameter['index'] = index;
            }
            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }
            if (unreadOnly !== undefined) {
                localVarQueryParameter['unreadOnly'] = unreadOnly;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.WaitForControllerApiFetchParamCreator = WaitForControllerApiFetchParamCreator;
/**
 * WaitForControllerApi - functional programming interface
 * @export
 */
var WaitForControllerApiFp = function (configuration) {
    return {
        /**
         * Generic waitFor method that will wait until an inbox meets given conditions or return immediately if already met
         * @summary Wait for conditions to be met
         * @param {WaitForConditions} [waitForConditions] Conditions to wait for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitFor: function (waitForConditions, options) {
            var localVarFetchArgs = exports.WaitForControllerApiFetchParamCreator(configuration).waitFor(waitForConditions, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * If inbox contains count or more emails at time of request then return count worth of emails. If not wait until the count is reached and return those or return an error if timeout is exceeded.
         * @summary Wait for and return count number of emails
         * @param {number} [count] Number of emails to wait for. Must be greater that 1
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {boolean} [unreadOnly] Optional filter for unread only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForEmailCount: function (count, inboxId, timeout, unreadOnly, options) {
            var localVarFetchArgs = exports.WaitForControllerApiFetchParamCreator(configuration).waitForEmailCount(count, inboxId, timeout, unreadOnly, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox set `unreadOnly=true` or see the other receive methods such as `waitForNthEmail` or `waitForEmailCount`.
         * @summary Fetch inbox's latest email or if empty wait for an email to arrive
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {boolean} [unreadOnly] Optional filter for unread only.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForLatestEmail: function (inboxId, timeout, unreadOnly, options) {
            var localVarFetchArgs = exports.WaitForControllerApiFetchParamCreator(configuration).waitForLatestEmail(inboxId, timeout, unreadOnly, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Perform a search of emails in an inbox with the given patterns. If results match expected count then return or else retry the search until results are found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the `MatchOptions` object for options.
         * @summary Wait or return list of emails that match simple matching patterns
         * @param {MatchOptions} matchOptions matchOptions
         * @param {number} [count] Number of emails to wait for. Must be greater that 1
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {boolean} [unreadOnly] Optional filter for unread only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForMatchingEmail: function (matchOptions, count, inboxId, timeout, unreadOnly, options) {
            var localVarFetchArgs = exports.WaitForControllerApiFetchParamCreator(configuration).waitForMatchingEmail(matchOptions, count, inboxId, timeout, unreadOnly, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * If nth email is already present in inbox then return it. If not hold the connection open until timeout expires or the nth email is received and returned.
         * @summary Wait for or fetch the email with a given index in the inbox specified
         * @param {string} [inboxId] Id of the inbox you are fetching emails from
         * @param {number} [index] Zero based index of the email to wait for. If an inbox has 1 email already and you want to wait for the 2nd email pass index&#x3D;1
         * @param {number} [timeout] Max milliseconds to wait for the nth email if not already present
         * @param {boolean} [unreadOnly] Optional filter for unread only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForNthEmail: function (inboxId, index, timeout, unreadOnly, options) {
            var localVarFetchArgs = exports.WaitForControllerApiFetchParamCreator(configuration).waitForNthEmail(inboxId, index, timeout, unreadOnly, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.WaitForControllerApiFp = WaitForControllerApiFp;
/**
 * WaitForControllerApi - factory interface
 * @export
 */
var WaitForControllerApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Generic waitFor method that will wait until an inbox meets given conditions or return immediately if already met
         * @summary Wait for conditions to be met
         * @param {WaitForConditions} [waitForConditions] Conditions to wait for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitFor: function (waitForConditions, options) {
            return exports.WaitForControllerApiFp(configuration).waitFor(waitForConditions, options)(fetch, basePath);
        },
        /**
         * If inbox contains count or more emails at time of request then return count worth of emails. If not wait until the count is reached and return those or return an error if timeout is exceeded.
         * @summary Wait for and return count number of emails
         * @param {number} [count] Number of emails to wait for. Must be greater that 1
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {boolean} [unreadOnly] Optional filter for unread only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForEmailCount: function (count, inboxId, timeout, unreadOnly, options) {
            return exports.WaitForControllerApiFp(configuration).waitForEmailCount(count, inboxId, timeout, unreadOnly, options)(fetch, basePath);
        },
        /**
         * Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox set `unreadOnly=true` or see the other receive methods such as `waitForNthEmail` or `waitForEmailCount`.
         * @summary Fetch inbox's latest email or if empty wait for an email to arrive
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {boolean} [unreadOnly] Optional filter for unread only.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForLatestEmail: function (inboxId, timeout, unreadOnly, options) {
            return exports.WaitForControllerApiFp(configuration).waitForLatestEmail(inboxId, timeout, unreadOnly, options)(fetch, basePath);
        },
        /**
         * Perform a search of emails in an inbox with the given patterns. If results match expected count then return or else retry the search until results are found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the `MatchOptions` object for options.
         * @summary Wait or return list of emails that match simple matching patterns
         * @param {MatchOptions} matchOptions matchOptions
         * @param {number} [count] Number of emails to wait for. Must be greater that 1
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {boolean} [unreadOnly] Optional filter for unread only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForMatchingEmail: function (matchOptions, count, inboxId, timeout, unreadOnly, options) {
            return exports.WaitForControllerApiFp(configuration).waitForMatchingEmail(matchOptions, count, inboxId, timeout, unreadOnly, options)(fetch, basePath);
        },
        /**
         * If nth email is already present in inbox then return it. If not hold the connection open until timeout expires or the nth email is received and returned.
         * @summary Wait for or fetch the email with a given index in the inbox specified
         * @param {string} [inboxId] Id of the inbox you are fetching emails from
         * @param {number} [index] Zero based index of the email to wait for. If an inbox has 1 email already and you want to wait for the 2nd email pass index&#x3D;1
         * @param {number} [timeout] Max milliseconds to wait for the nth email if not already present
         * @param {boolean} [unreadOnly] Optional filter for unread only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForNthEmail: function (inboxId, index, timeout, unreadOnly, options) {
            return exports.WaitForControllerApiFp(configuration).waitForNthEmail(inboxId, index, timeout, unreadOnly, options)(fetch, basePath);
        },
    };
};
exports.WaitForControllerApiFactory = WaitForControllerApiFactory;
/**
 * WaitForControllerApi - object-oriented interface
 * @export
 * @class WaitForControllerApi
 * @extends {BaseAPI}
 */
var WaitForControllerApi = /** @class */ (function (_super) {
    __extends(WaitForControllerApi, _super);
    function WaitForControllerApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Generic waitFor method that will wait until an inbox meets given conditions or return immediately if already met
     * @summary Wait for conditions to be met
     * @param {WaitForConditions} [waitForConditions] Conditions to wait for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitForControllerApi
     */
    WaitForControllerApi.prototype.waitFor = function (waitForConditions, options) {
        return exports.WaitForControllerApiFp(this.configuration).waitFor(waitForConditions, options)(this.fetch, this.basePath);
    };
    /**
     * If inbox contains count or more emails at time of request then return count worth of emails. If not wait until the count is reached and return those or return an error if timeout is exceeded.
     * @summary Wait for and return count number of emails
     * @param {number} [count] Number of emails to wait for. Must be greater that 1
     * @param {string} [inboxId] Id of the inbox we are fetching emails from
     * @param {number} [timeout] Max milliseconds to wait
     * @param {boolean} [unreadOnly] Optional filter for unread only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitForControllerApi
     */
    WaitForControllerApi.prototype.waitForEmailCount = function (count, inboxId, timeout, unreadOnly, options) {
        return exports.WaitForControllerApiFp(this.configuration).waitForEmailCount(count, inboxId, timeout, unreadOnly, options)(this.fetch, this.basePath);
    };
    /**
     * Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox set `unreadOnly=true` or see the other receive methods such as `waitForNthEmail` or `waitForEmailCount`.
     * @summary Fetch inbox's latest email or if empty wait for an email to arrive
     * @param {string} [inboxId] Id of the inbox we are fetching emails from
     * @param {number} [timeout] Max milliseconds to wait
     * @param {boolean} [unreadOnly] Optional filter for unread only.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitForControllerApi
     */
    WaitForControllerApi.prototype.waitForLatestEmail = function (inboxId, timeout, unreadOnly, options) {
        return exports.WaitForControllerApiFp(this.configuration).waitForLatestEmail(inboxId, timeout, unreadOnly, options)(this.fetch, this.basePath);
    };
    /**
     * Perform a search of emails in an inbox with the given patterns. If results match expected count then return or else retry the search until results are found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the `MatchOptions` object for options.
     * @summary Wait or return list of emails that match simple matching patterns
     * @param {MatchOptions} matchOptions matchOptions
     * @param {number} [count] Number of emails to wait for. Must be greater that 1
     * @param {string} [inboxId] Id of the inbox we are fetching emails from
     * @param {number} [timeout] Max milliseconds to wait
     * @param {boolean} [unreadOnly] Optional filter for unread only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitForControllerApi
     */
    WaitForControllerApi.prototype.waitForMatchingEmail = function (matchOptions, count, inboxId, timeout, unreadOnly, options) {
        return exports.WaitForControllerApiFp(this.configuration).waitForMatchingEmail(matchOptions, count, inboxId, timeout, unreadOnly, options)(this.fetch, this.basePath);
    };
    /**
     * If nth email is already present in inbox then return it. If not hold the connection open until timeout expires or the nth email is received and returned.
     * @summary Wait for or fetch the email with a given index in the inbox specified
     * @param {string} [inboxId] Id of the inbox you are fetching emails from
     * @param {number} [index] Zero based index of the email to wait for. If an inbox has 1 email already and you want to wait for the 2nd email pass index&#x3D;1
     * @param {number} [timeout] Max milliseconds to wait for the nth email if not already present
     * @param {boolean} [unreadOnly] Optional filter for unread only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitForControllerApi
     */
    WaitForControllerApi.prototype.waitForNthEmail = function (inboxId, index, timeout, unreadOnly, options) {
        return exports.WaitForControllerApiFp(this.configuration).waitForNthEmail(inboxId, index, timeout, unreadOnly, options)(this.fetch, this.basePath);
    };
    return WaitForControllerApi;
}(BaseAPI));
exports.WaitForControllerApi = WaitForControllerApi;
/**
 * WebhookControllerApi - fetch parameter creator
 * @export
 */
var WebhookControllerApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Get notified whenever an inbox receives an email via a WebHook URL. An emailID will be posted to this URL every time an email is received for this inbox. The URL must be publicly reachable by the MailSlurp server. You can provide basicAuth values if you wish to secure this endpoint.
         * @summary Attach a WebHook URL to an inbox
         * @param {string} inboxId inboxId
         * @param {CreateWebhookOptions} webhookOptions webhookOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook: function (inboxId, webhookOptions, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError('inboxId', 'Required parameter inboxId was null or undefined when calling createWebhook.');
            }
            // verify required parameter 'webhookOptions' is not null or undefined
            if (webhookOptions === null || webhookOptions === undefined) {
                throw new RequiredError('webhookOptions', 'Required parameter webhookOptions was null or undefined when calling createWebhook.');
            }
            var localVarPath = "/inboxes/{inboxId}/webhooks".replace("{" + 'inboxId' + "}", encodeURIComponent(String(inboxId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'CreateWebhookOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(webhookOptions || {})
                : webhookOptions || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete and disable a Webhook for an Inbox
         * @param {string} inboxId inboxId
         * @param {string} webhookId webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook: function (inboxId, webhookId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError('inboxId', 'Required parameter inboxId was null or undefined when calling deleteWebhook.');
            }
            // verify required parameter 'webhookId' is not null or undefined
            if (webhookId === null || webhookId === undefined) {
                throw new RequiredError('webhookId', 'Required parameter webhookId was null or undefined when calling deleteWebhook.');
            }
            var localVarPath = "/inboxes/{inboxId}/webhooks/{webhookId}"
                .replace("{" + 'inboxId' + "}", encodeURIComponent(String(inboxId)))
                .replace("{" + 'webhookId' + "}", encodeURIComponent(String(webhookId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List webhooks in paginated form. Allows for page index, page size, and sort direction.
         * @summary List Webhooks Paginated
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWebhooks: function (page, size, sort, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/webhooks/paginated";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a webhook for an Inbox
         * @param {string} webhookId webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook: function (webhookId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'webhookId' is not null or undefined
            if (webhookId === null || webhookId === undefined) {
                throw new RequiredError('webhookId', 'Required parameter webhookId was null or undefined when calling getWebhook.');
            }
            var localVarPath = "/webhooks/{webhookId}".replace("{" + 'webhookId' + "}", encodeURIComponent(String(webhookId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Webhooks for an Inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks: function (inboxId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError('inboxId', 'Required parameter inboxId was null or undefined when calling getWebhooks.');
            }
            var localVarPath = "/inboxes/{inboxId}/webhooks".replace("{" + 'inboxId' + "}", encodeURIComponent(String(inboxId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Send webhook test data
         * @param {string} webhookId webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTestData: function (webhookId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'webhookId' is not null or undefined
            if (webhookId === null || webhookId === undefined) {
                throw new RequiredError('webhookId', 'Required parameter webhookId was null or undefined when calling sendTestData.');
            }
            var localVarPath = "/webhooks/{webhookId}/test".replace("{" + 'webhookId' + "}", encodeURIComponent(String(webhookId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.WebhookControllerApiFetchParamCreator = WebhookControllerApiFetchParamCreator;
/**
 * WebhookControllerApi - functional programming interface
 * @export
 */
var WebhookControllerApiFp = function (configuration) {
    return {
        /**
         * Get notified whenever an inbox receives an email via a WebHook URL. An emailID will be posted to this URL every time an email is received for this inbox. The URL must be publicly reachable by the MailSlurp server. You can provide basicAuth values if you wish to secure this endpoint.
         * @summary Attach a WebHook URL to an inbox
         * @param {string} inboxId inboxId
         * @param {CreateWebhookOptions} webhookOptions webhookOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook: function (inboxId, webhookOptions, options) {
            var localVarFetchArgs = exports.WebhookControllerApiFetchParamCreator(configuration).createWebhook(inboxId, webhookOptions, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete and disable a Webhook for an Inbox
         * @param {string} inboxId inboxId
         * @param {string} webhookId webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook: function (inboxId, webhookId, options) {
            var localVarFetchArgs = exports.WebhookControllerApiFetchParamCreator(configuration).deleteWebhook(inboxId, webhookId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List webhooks in paginated form. Allows for page index, page size, and sort direction.
         * @summary List Webhooks Paginated
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWebhooks: function (page, size, sort, options) {
            var localVarFetchArgs = exports.WebhookControllerApiFetchParamCreator(configuration).getAllWebhooks(page, size, sort, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get a webhook for an Inbox
         * @param {string} webhookId webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook: function (webhookId, options) {
            var localVarFetchArgs = exports.WebhookControllerApiFetchParamCreator(configuration).getWebhook(webhookId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all Webhooks for an Inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks: function (inboxId, options) {
            var localVarFetchArgs = exports.WebhookControllerApiFetchParamCreator(configuration).getWebhooks(inboxId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Send webhook test data
         * @param {string} webhookId webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTestData: function (webhookId, options) {
            var localVarFetchArgs = exports.WebhookControllerApiFetchParamCreator(configuration).sendTestData(webhookId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.WebhookControllerApiFp = WebhookControllerApiFp;
/**
 * WebhookControllerApi - factory interface
 * @export
 */
var WebhookControllerApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Get notified whenever an inbox receives an email via a WebHook URL. An emailID will be posted to this URL every time an email is received for this inbox. The URL must be publicly reachable by the MailSlurp server. You can provide basicAuth values if you wish to secure this endpoint.
         * @summary Attach a WebHook URL to an inbox
         * @param {string} inboxId inboxId
         * @param {CreateWebhookOptions} webhookOptions webhookOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook: function (inboxId, webhookOptions, options) {
            return exports.WebhookControllerApiFp(configuration).createWebhook(inboxId, webhookOptions, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete and disable a Webhook for an Inbox
         * @param {string} inboxId inboxId
         * @param {string} webhookId webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook: function (inboxId, webhookId, options) {
            return exports.WebhookControllerApiFp(configuration).deleteWebhook(inboxId, webhookId, options)(fetch, basePath);
        },
        /**
         * List webhooks in paginated form. Allows for page index, page size, and sort direction.
         * @summary List Webhooks Paginated
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWebhooks: function (page, size, sort, options) {
            return exports.WebhookControllerApiFp(configuration).getAllWebhooks(page, size, sort, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get a webhook for an Inbox
         * @param {string} webhookId webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook: function (webhookId, options) {
            return exports.WebhookControllerApiFp(configuration).getWebhook(webhookId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get all Webhooks for an Inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks: function (inboxId, options) {
            return exports.WebhookControllerApiFp(configuration).getWebhooks(inboxId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Send webhook test data
         * @param {string} webhookId webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTestData: function (webhookId, options) {
            return exports.WebhookControllerApiFp(configuration).sendTestData(webhookId, options)(fetch, basePath);
        },
    };
};
exports.WebhookControllerApiFactory = WebhookControllerApiFactory;
/**
 * WebhookControllerApi - object-oriented interface
 * @export
 * @class WebhookControllerApi
 * @extends {BaseAPI}
 */
var WebhookControllerApi = /** @class */ (function (_super) {
    __extends(WebhookControllerApi, _super);
    function WebhookControllerApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Get notified whenever an inbox receives an email via a WebHook URL. An emailID will be posted to this URL every time an email is received for this inbox. The URL must be publicly reachable by the MailSlurp server. You can provide basicAuth values if you wish to secure this endpoint.
     * @summary Attach a WebHook URL to an inbox
     * @param {string} inboxId inboxId
     * @param {CreateWebhookOptions} webhookOptions webhookOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookControllerApi
     */
    WebhookControllerApi.prototype.createWebhook = function (inboxId, webhookOptions, options) {
        return exports.WebhookControllerApiFp(this.configuration).createWebhook(inboxId, webhookOptions, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Delete and disable a Webhook for an Inbox
     * @param {string} inboxId inboxId
     * @param {string} webhookId webhookId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookControllerApi
     */
    WebhookControllerApi.prototype.deleteWebhook = function (inboxId, webhookId, options) {
        return exports.WebhookControllerApiFp(this.configuration).deleteWebhook(inboxId, webhookId, options)(this.fetch, this.basePath);
    };
    /**
     * List webhooks in paginated form. Allows for page index, page size, and sort direction.
     * @summary List Webhooks Paginated
     * @param {number} [page] Optional page index in inbox list pagination
     * @param {number} [size] Optional page size in inbox list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookControllerApi
     */
    WebhookControllerApi.prototype.getAllWebhooks = function (page, size, sort, options) {
        return exports.WebhookControllerApiFp(this.configuration).getAllWebhooks(page, size, sort, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Get a webhook for an Inbox
     * @param {string} webhookId webhookId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookControllerApi
     */
    WebhookControllerApi.prototype.getWebhook = function (webhookId, options) {
        return exports.WebhookControllerApiFp(this.configuration).getWebhook(webhookId, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Get all Webhooks for an Inbox
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookControllerApi
     */
    WebhookControllerApi.prototype.getWebhooks = function (inboxId, options) {
        return exports.WebhookControllerApiFp(this.configuration).getWebhooks(inboxId, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Send webhook test data
     * @param {string} webhookId webhookId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookControllerApi
     */
    WebhookControllerApi.prototype.sendTestData = function (webhookId, options) {
        return exports.WebhookControllerApiFp(this.configuration).sendTestData(webhookId, options)(this.fetch, this.basePath);
    };
    return WebhookControllerApi;
}(BaseAPI));
exports.WebhookControllerApi = WebhookControllerApi;
