"use strict";
/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * MailSlurp API
 * MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.   ## Resources - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://www.mailslurp.com/docs/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * OpenAPI spec version: b7d91d146fc4a93fc187437a89e4808f7920cce1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FormControllerApiFetchParamCreator = exports.ExpiredControllerApi = exports.ExpiredControllerApiFactory = exports.ExpiredControllerApiFp = exports.ExpiredControllerApiFetchParamCreator = exports.EmailControllerApi = exports.EmailControllerApiFactory = exports.EmailControllerApiFp = exports.EmailControllerApiFetchParamCreator = exports.DomainControllerApi = exports.DomainControllerApiFactory = exports.DomainControllerApiFp = exports.DomainControllerApiFetchParamCreator = exports.ContactControllerApi = exports.ContactControllerApiFactory = exports.ContactControllerApiFp = exports.ContactControllerApiFetchParamCreator = exports.CommonActionsControllerApi = exports.CommonActionsControllerApiFactory = exports.CommonActionsControllerApiFp = exports.CommonActionsControllerApiFetchParamCreator = exports.BulkActionsControllerApi = exports.BulkActionsControllerApiFactory = exports.BulkActionsControllerApiFp = exports.BulkActionsControllerApiFetchParamCreator = exports.AttachmentControllerApi = exports.AttachmentControllerApiFactory = exports.AttachmentControllerApiFp = exports.AttachmentControllerApiFetchParamCreator = exports.AliasControllerApi = exports.AliasControllerApiFactory = exports.AliasControllerApiFp = exports.AliasControllerApiFetchParamCreator = exports.WebhookTestRequest = exports.WebhookPayload = exports.WebhookDto = exports.WaitForConditions = exports.TemplateVariable = exports.SendEmailOptions = exports.ReplyToEmailOptions = exports.ReplyToAliasEmailOptions = exports.MatchOption = exports.DomainNameRecord = exports.DNSLookupResult = exports.DNSLookupOptions = exports.CreateInboxDto = exports.CreateDomainOptions = exports.RequiredError = exports.BaseAPI = exports.COLLECTION_FORMATS = void 0;
exports.WebhookControllerApi = exports.WebhookControllerApiFactory = exports.WebhookControllerApiFp = exports.WebhookControllerApiFetchParamCreator = exports.WaitForControllerApi = exports.WaitForControllerApiFactory = exports.WaitForControllerApiFp = exports.WaitForControllerApiFetchParamCreator = exports.TemplateControllerApi = exports.TemplateControllerApiFactory = exports.TemplateControllerApiFp = exports.TemplateControllerApiFetchParamCreator = exports.SentEmailsControllerApi = exports.SentEmailsControllerApiFactory = exports.SentEmailsControllerApiFp = exports.SentEmailsControllerApiFetchParamCreator = exports.MissedEmailControllerApi = exports.MissedEmailControllerApiFactory = exports.MissedEmailControllerApiFp = exports.MissedEmailControllerApiFetchParamCreator = exports.MailServerControllerApi = exports.MailServerControllerApiFactory = exports.MailServerControllerApiFp = exports.MailServerControllerApiFetchParamCreator = exports.InboxControllerApi = exports.InboxControllerApiFactory = exports.InboxControllerApiFp = exports.InboxControllerApiFetchParamCreator = exports.GroupControllerApi = exports.GroupControllerApiFactory = exports.GroupControllerApiFp = exports.GroupControllerApiFetchParamCreator = exports.FormControllerApi = exports.FormControllerApiFactory = exports.FormControllerApiFp = void 0;
var url = __importStar(require("url"));
var portableFetch = __importStar(require("portable-fetch"));
var BASE_PATH = 'https://api.mailslurp.com'.replace(/\/+$/, '');
/**
 *
 * @export
 */
exports.COLLECTION_FORMATS = {
    csv: ',',
    ssv: ' ',
    tsv: '\t',
    pipes: '|',
};
/**
 *
 * @export
 * @class BaseAPI
 */
var BaseAPI = /** @class */ (function () {
    function BaseAPI(configuration, basePath, fetch) {
        if (basePath === void 0) { basePath = BASE_PATH; }
        if (fetch === void 0) { fetch = portableFetch; }
        this.basePath = basePath;
        this.fetch = fetch;
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
    return BaseAPI;
}());
exports.BaseAPI = BaseAPI;
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
var RequiredError = /** @class */ (function (_super) {
    __extends(RequiredError, _super);
    function RequiredError(field, msg) {
        var _this = _super.call(this, msg) || this;
        _this.field = field;
        return _this;
    }
    return RequiredError;
}(Error));
exports.RequiredError = RequiredError;
/**
 * @export
 * @namespace CreateDomainOptions
 */
var CreateDomainOptions;
(function (CreateDomainOptions) {
    /**
     * @export
     * @enum {string}
     */
    var DomainTypeEnum;
    (function (DomainTypeEnum) {
        DomainTypeEnum[DomainTypeEnum["HTTPINBOX"] = 'HTTP_INBOX'] = "HTTPINBOX";
        DomainTypeEnum[DomainTypeEnum["SMTPDOMAIN"] = 'SMTP_DOMAIN'] = "SMTPDOMAIN";
    })(DomainTypeEnum = CreateDomainOptions.DomainTypeEnum || (CreateDomainOptions.DomainTypeEnum = {}));
})(CreateDomainOptions = exports.CreateDomainOptions || (exports.CreateDomainOptions = {}));
/**
 * @export
 * @namespace CreateInboxDto
 */
var CreateInboxDto;
(function (CreateInboxDto) {
    /**
     * @export
     * @enum {string}
     */
    var InboxTypeEnum;
    (function (InboxTypeEnum) {
        InboxTypeEnum[InboxTypeEnum["HTTPINBOX"] = 'HTTP_INBOX'] = "HTTPINBOX";
        InboxTypeEnum[InboxTypeEnum["SMTPINBOX"] = 'SMTP_INBOX'] = "SMTPINBOX";
    })(InboxTypeEnum = CreateInboxDto.InboxTypeEnum || (CreateInboxDto.InboxTypeEnum = {}));
})(CreateInboxDto = exports.CreateInboxDto || (exports.CreateInboxDto = {}));
/**
 * @export
 * @namespace DNSLookupOptions
 */
var DNSLookupOptions;
(function (DNSLookupOptions) {
    /**
     * @export
     * @enum {string}
     */
    var RecordTypesEnum;
    (function (RecordTypesEnum) {
        RecordTypesEnum[RecordTypesEnum["A"] = 'A'] = "A";
        RecordTypesEnum[RecordTypesEnum["NS"] = 'NS'] = "NS";
        RecordTypesEnum[RecordTypesEnum["MD"] = 'MD'] = "MD";
        RecordTypesEnum[RecordTypesEnum["MF"] = 'MF'] = "MF";
        RecordTypesEnum[RecordTypesEnum["CNAME"] = 'CNAME'] = "CNAME";
        RecordTypesEnum[RecordTypesEnum["SOA"] = 'SOA'] = "SOA";
        RecordTypesEnum[RecordTypesEnum["MB"] = 'MB'] = "MB";
        RecordTypesEnum[RecordTypesEnum["MG"] = 'MG'] = "MG";
        RecordTypesEnum[RecordTypesEnum["MR"] = 'MR'] = "MR";
        RecordTypesEnum[RecordTypesEnum["NULL"] = 'NULL'] = "NULL";
        RecordTypesEnum[RecordTypesEnum["WKS"] = 'WKS'] = "WKS";
        RecordTypesEnum[RecordTypesEnum["PTR"] = 'PTR'] = "PTR";
        RecordTypesEnum[RecordTypesEnum["HINFO"] = 'HINFO'] = "HINFO";
        RecordTypesEnum[RecordTypesEnum["MINFO"] = 'MINFO'] = "MINFO";
        RecordTypesEnum[RecordTypesEnum["MX"] = 'MX'] = "MX";
        RecordTypesEnum[RecordTypesEnum["TXT"] = 'TXT'] = "TXT";
        RecordTypesEnum[RecordTypesEnum["RP"] = 'RP'] = "RP";
        RecordTypesEnum[RecordTypesEnum["AFSDB"] = 'AFSDB'] = "AFSDB";
        RecordTypesEnum[RecordTypesEnum["X25"] = 'X25'] = "X25";
        RecordTypesEnum[RecordTypesEnum["ISDN"] = 'ISDN'] = "ISDN";
        RecordTypesEnum[RecordTypesEnum["RT"] = 'RT'] = "RT";
        RecordTypesEnum[RecordTypesEnum["NSAP"] = 'NSAP'] = "NSAP";
        RecordTypesEnum[RecordTypesEnum["NSAPPTR"] = 'NSAP_PTR'] = "NSAPPTR";
        RecordTypesEnum[RecordTypesEnum["SIG"] = 'SIG'] = "SIG";
        RecordTypesEnum[RecordTypesEnum["KEY"] = 'KEY'] = "KEY";
        RecordTypesEnum[RecordTypesEnum["PX"] = 'PX'] = "PX";
        RecordTypesEnum[RecordTypesEnum["GPOS"] = 'GPOS'] = "GPOS";
        RecordTypesEnum[RecordTypesEnum["AAAA"] = 'AAAA'] = "AAAA";
        RecordTypesEnum[RecordTypesEnum["LOC"] = 'LOC'] = "LOC";
        RecordTypesEnum[RecordTypesEnum["NXT"] = 'NXT'] = "NXT";
        RecordTypesEnum[RecordTypesEnum["EID"] = 'EID'] = "EID";
        RecordTypesEnum[RecordTypesEnum["NIMLOC"] = 'NIMLOC'] = "NIMLOC";
        RecordTypesEnum[RecordTypesEnum["SRV"] = 'SRV'] = "SRV";
        RecordTypesEnum[RecordTypesEnum["ATMA"] = 'ATMA'] = "ATMA";
        RecordTypesEnum[RecordTypesEnum["NAPTR"] = 'NAPTR'] = "NAPTR";
        RecordTypesEnum[RecordTypesEnum["KX"] = 'KX'] = "KX";
        RecordTypesEnum[RecordTypesEnum["CERT"] = 'CERT'] = "CERT";
        RecordTypesEnum[RecordTypesEnum["A6"] = 'A6'] = "A6";
        RecordTypesEnum[RecordTypesEnum["DNAME"] = 'DNAME'] = "DNAME";
        RecordTypesEnum[RecordTypesEnum["SINK"] = 'SINK'] = "SINK";
        RecordTypesEnum[RecordTypesEnum["OPT"] = 'OPT'] = "OPT";
        RecordTypesEnum[RecordTypesEnum["APL"] = 'APL'] = "APL";
        RecordTypesEnum[RecordTypesEnum["DS"] = 'DS'] = "DS";
        RecordTypesEnum[RecordTypesEnum["SSHFP"] = 'SSHFP'] = "SSHFP";
        RecordTypesEnum[RecordTypesEnum["IPSECKEY"] = 'IPSECKEY'] = "IPSECKEY";
        RecordTypesEnum[RecordTypesEnum["RRSIG"] = 'RRSIG'] = "RRSIG";
        RecordTypesEnum[RecordTypesEnum["NSEC"] = 'NSEC'] = "NSEC";
        RecordTypesEnum[RecordTypesEnum["DNSKEY"] = 'DNSKEY'] = "DNSKEY";
        RecordTypesEnum[RecordTypesEnum["DHCID"] = 'DHCID'] = "DHCID";
        RecordTypesEnum[RecordTypesEnum["NSEC3"] = 'NSEC3'] = "NSEC3";
        RecordTypesEnum[RecordTypesEnum["NSEC3PARAM"] = 'NSEC3PARAM'] = "NSEC3PARAM";
        RecordTypesEnum[RecordTypesEnum["TLSA"] = 'TLSA'] = "TLSA";
        RecordTypesEnum[RecordTypesEnum["SMIMEA"] = 'SMIMEA'] = "SMIMEA";
        RecordTypesEnum[RecordTypesEnum["HIP"] = 'HIP'] = "HIP";
        RecordTypesEnum[RecordTypesEnum["NINFO"] = 'NINFO'] = "NINFO";
        RecordTypesEnum[RecordTypesEnum["RKEY"] = 'RKEY'] = "RKEY";
        RecordTypesEnum[RecordTypesEnum["TALINK"] = 'TALINK'] = "TALINK";
        RecordTypesEnum[RecordTypesEnum["CDS"] = 'CDS'] = "CDS";
        RecordTypesEnum[RecordTypesEnum["CDNSKEY"] = 'CDNSKEY'] = "CDNSKEY";
        RecordTypesEnum[RecordTypesEnum["OPENPGPKEY"] = 'OPENPGPKEY'] = "OPENPGPKEY";
        RecordTypesEnum[RecordTypesEnum["CSYNC"] = 'CSYNC'] = "CSYNC";
        RecordTypesEnum[RecordTypesEnum["ZONEMD"] = 'ZONEMD'] = "ZONEMD";
        RecordTypesEnum[RecordTypesEnum["SVCB"] = 'SVCB'] = "SVCB";
        RecordTypesEnum[RecordTypesEnum["HTTPS"] = 'HTTPS'] = "HTTPS";
        RecordTypesEnum[RecordTypesEnum["SPF"] = 'SPF'] = "SPF";
        RecordTypesEnum[RecordTypesEnum["UINFO"] = 'UINFO'] = "UINFO";
        RecordTypesEnum[RecordTypesEnum["UID"] = 'UID'] = "UID";
        RecordTypesEnum[RecordTypesEnum["GID"] = 'GID'] = "GID";
        RecordTypesEnum[RecordTypesEnum["UNSPEC"] = 'UNSPEC'] = "UNSPEC";
        RecordTypesEnum[RecordTypesEnum["NID"] = 'NID'] = "NID";
        RecordTypesEnum[RecordTypesEnum["L32"] = 'L32'] = "L32";
        RecordTypesEnum[RecordTypesEnum["L64"] = 'L64'] = "L64";
        RecordTypesEnum[RecordTypesEnum["LP"] = 'LP'] = "LP";
        RecordTypesEnum[RecordTypesEnum["EUI48"] = 'EUI48'] = "EUI48";
        RecordTypesEnum[RecordTypesEnum["EUI64"] = 'EUI64'] = "EUI64";
        RecordTypesEnum[RecordTypesEnum["TKEY"] = 'TKEY'] = "TKEY";
        RecordTypesEnum[RecordTypesEnum["TSIG"] = 'TSIG'] = "TSIG";
        RecordTypesEnum[RecordTypesEnum["IXFR"] = 'IXFR'] = "IXFR";
        RecordTypesEnum[RecordTypesEnum["AXFR"] = 'AXFR'] = "AXFR";
        RecordTypesEnum[RecordTypesEnum["MAILB"] = 'MAILB'] = "MAILB";
        RecordTypesEnum[RecordTypesEnum["MAILA"] = 'MAILA'] = "MAILA";
        RecordTypesEnum[RecordTypesEnum["ANY"] = 'ANY'] = "ANY";
        RecordTypesEnum[RecordTypesEnum["URI"] = 'URI'] = "URI";
        RecordTypesEnum[RecordTypesEnum["CAA"] = 'CAA'] = "CAA";
        RecordTypesEnum[RecordTypesEnum["AVC"] = 'AVC'] = "AVC";
        RecordTypesEnum[RecordTypesEnum["DOA"] = 'DOA'] = "DOA";
        RecordTypesEnum[RecordTypesEnum["AMTRELAY"] = 'AMTRELAY'] = "AMTRELAY";
        RecordTypesEnum[RecordTypesEnum["TA"] = 'TA'] = "TA";
        RecordTypesEnum[RecordTypesEnum["DLV"] = 'DLV'] = "DLV";
    })(RecordTypesEnum = DNSLookupOptions.RecordTypesEnum || (DNSLookupOptions.RecordTypesEnum = {}));
})(DNSLookupOptions = exports.DNSLookupOptions || (exports.DNSLookupOptions = {}));
/**
 * @export
 * @namespace DNSLookupResult
 */
var DNSLookupResult;
(function (DNSLookupResult) {
    /**
     * @export
     * @enum {string}
     */
    var RecordTypeEnum;
    (function (RecordTypeEnum) {
        RecordTypeEnum[RecordTypeEnum["A"] = 'A'] = "A";
        RecordTypeEnum[RecordTypeEnum["NS"] = 'NS'] = "NS";
        RecordTypeEnum[RecordTypeEnum["MD"] = 'MD'] = "MD";
        RecordTypeEnum[RecordTypeEnum["MF"] = 'MF'] = "MF";
        RecordTypeEnum[RecordTypeEnum["CNAME"] = 'CNAME'] = "CNAME";
        RecordTypeEnum[RecordTypeEnum["SOA"] = 'SOA'] = "SOA";
        RecordTypeEnum[RecordTypeEnum["MB"] = 'MB'] = "MB";
        RecordTypeEnum[RecordTypeEnum["MG"] = 'MG'] = "MG";
        RecordTypeEnum[RecordTypeEnum["MR"] = 'MR'] = "MR";
        RecordTypeEnum[RecordTypeEnum["NULL"] = 'NULL'] = "NULL";
        RecordTypeEnum[RecordTypeEnum["WKS"] = 'WKS'] = "WKS";
        RecordTypeEnum[RecordTypeEnum["PTR"] = 'PTR'] = "PTR";
        RecordTypeEnum[RecordTypeEnum["HINFO"] = 'HINFO'] = "HINFO";
        RecordTypeEnum[RecordTypeEnum["MINFO"] = 'MINFO'] = "MINFO";
        RecordTypeEnum[RecordTypeEnum["MX"] = 'MX'] = "MX";
        RecordTypeEnum[RecordTypeEnum["TXT"] = 'TXT'] = "TXT";
        RecordTypeEnum[RecordTypeEnum["RP"] = 'RP'] = "RP";
        RecordTypeEnum[RecordTypeEnum["AFSDB"] = 'AFSDB'] = "AFSDB";
        RecordTypeEnum[RecordTypeEnum["X25"] = 'X25'] = "X25";
        RecordTypeEnum[RecordTypeEnum["ISDN"] = 'ISDN'] = "ISDN";
        RecordTypeEnum[RecordTypeEnum["RT"] = 'RT'] = "RT";
        RecordTypeEnum[RecordTypeEnum["NSAP"] = 'NSAP'] = "NSAP";
        RecordTypeEnum[RecordTypeEnum["NSAPPTR"] = 'NSAP_PTR'] = "NSAPPTR";
        RecordTypeEnum[RecordTypeEnum["SIG"] = 'SIG'] = "SIG";
        RecordTypeEnum[RecordTypeEnum["KEY"] = 'KEY'] = "KEY";
        RecordTypeEnum[RecordTypeEnum["PX"] = 'PX'] = "PX";
        RecordTypeEnum[RecordTypeEnum["GPOS"] = 'GPOS'] = "GPOS";
        RecordTypeEnum[RecordTypeEnum["AAAA"] = 'AAAA'] = "AAAA";
        RecordTypeEnum[RecordTypeEnum["LOC"] = 'LOC'] = "LOC";
        RecordTypeEnum[RecordTypeEnum["NXT"] = 'NXT'] = "NXT";
        RecordTypeEnum[RecordTypeEnum["EID"] = 'EID'] = "EID";
        RecordTypeEnum[RecordTypeEnum["NIMLOC"] = 'NIMLOC'] = "NIMLOC";
        RecordTypeEnum[RecordTypeEnum["SRV"] = 'SRV'] = "SRV";
        RecordTypeEnum[RecordTypeEnum["ATMA"] = 'ATMA'] = "ATMA";
        RecordTypeEnum[RecordTypeEnum["NAPTR"] = 'NAPTR'] = "NAPTR";
        RecordTypeEnum[RecordTypeEnum["KX"] = 'KX'] = "KX";
        RecordTypeEnum[RecordTypeEnum["CERT"] = 'CERT'] = "CERT";
        RecordTypeEnum[RecordTypeEnum["A6"] = 'A6'] = "A6";
        RecordTypeEnum[RecordTypeEnum["DNAME"] = 'DNAME'] = "DNAME";
        RecordTypeEnum[RecordTypeEnum["SINK"] = 'SINK'] = "SINK";
        RecordTypeEnum[RecordTypeEnum["OPT"] = 'OPT'] = "OPT";
        RecordTypeEnum[RecordTypeEnum["APL"] = 'APL'] = "APL";
        RecordTypeEnum[RecordTypeEnum["DS"] = 'DS'] = "DS";
        RecordTypeEnum[RecordTypeEnum["SSHFP"] = 'SSHFP'] = "SSHFP";
        RecordTypeEnum[RecordTypeEnum["IPSECKEY"] = 'IPSECKEY'] = "IPSECKEY";
        RecordTypeEnum[RecordTypeEnum["RRSIG"] = 'RRSIG'] = "RRSIG";
        RecordTypeEnum[RecordTypeEnum["NSEC"] = 'NSEC'] = "NSEC";
        RecordTypeEnum[RecordTypeEnum["DNSKEY"] = 'DNSKEY'] = "DNSKEY";
        RecordTypeEnum[RecordTypeEnum["DHCID"] = 'DHCID'] = "DHCID";
        RecordTypeEnum[RecordTypeEnum["NSEC3"] = 'NSEC3'] = "NSEC3";
        RecordTypeEnum[RecordTypeEnum["NSEC3PARAM"] = 'NSEC3PARAM'] = "NSEC3PARAM";
        RecordTypeEnum[RecordTypeEnum["TLSA"] = 'TLSA'] = "TLSA";
        RecordTypeEnum[RecordTypeEnum["SMIMEA"] = 'SMIMEA'] = "SMIMEA";
        RecordTypeEnum[RecordTypeEnum["HIP"] = 'HIP'] = "HIP";
        RecordTypeEnum[RecordTypeEnum["NINFO"] = 'NINFO'] = "NINFO";
        RecordTypeEnum[RecordTypeEnum["RKEY"] = 'RKEY'] = "RKEY";
        RecordTypeEnum[RecordTypeEnum["TALINK"] = 'TALINK'] = "TALINK";
        RecordTypeEnum[RecordTypeEnum["CDS"] = 'CDS'] = "CDS";
        RecordTypeEnum[RecordTypeEnum["CDNSKEY"] = 'CDNSKEY'] = "CDNSKEY";
        RecordTypeEnum[RecordTypeEnum["OPENPGPKEY"] = 'OPENPGPKEY'] = "OPENPGPKEY";
        RecordTypeEnum[RecordTypeEnum["CSYNC"] = 'CSYNC'] = "CSYNC";
        RecordTypeEnum[RecordTypeEnum["ZONEMD"] = 'ZONEMD'] = "ZONEMD";
        RecordTypeEnum[RecordTypeEnum["SVCB"] = 'SVCB'] = "SVCB";
        RecordTypeEnum[RecordTypeEnum["HTTPS"] = 'HTTPS'] = "HTTPS";
        RecordTypeEnum[RecordTypeEnum["SPF"] = 'SPF'] = "SPF";
        RecordTypeEnum[RecordTypeEnum["UINFO"] = 'UINFO'] = "UINFO";
        RecordTypeEnum[RecordTypeEnum["UID"] = 'UID'] = "UID";
        RecordTypeEnum[RecordTypeEnum["GID"] = 'GID'] = "GID";
        RecordTypeEnum[RecordTypeEnum["UNSPEC"] = 'UNSPEC'] = "UNSPEC";
        RecordTypeEnum[RecordTypeEnum["NID"] = 'NID'] = "NID";
        RecordTypeEnum[RecordTypeEnum["L32"] = 'L32'] = "L32";
        RecordTypeEnum[RecordTypeEnum["L64"] = 'L64'] = "L64";
        RecordTypeEnum[RecordTypeEnum["LP"] = 'LP'] = "LP";
        RecordTypeEnum[RecordTypeEnum["EUI48"] = 'EUI48'] = "EUI48";
        RecordTypeEnum[RecordTypeEnum["EUI64"] = 'EUI64'] = "EUI64";
        RecordTypeEnum[RecordTypeEnum["TKEY"] = 'TKEY'] = "TKEY";
        RecordTypeEnum[RecordTypeEnum["TSIG"] = 'TSIG'] = "TSIG";
        RecordTypeEnum[RecordTypeEnum["IXFR"] = 'IXFR'] = "IXFR";
        RecordTypeEnum[RecordTypeEnum["AXFR"] = 'AXFR'] = "AXFR";
        RecordTypeEnum[RecordTypeEnum["MAILB"] = 'MAILB'] = "MAILB";
        RecordTypeEnum[RecordTypeEnum["MAILA"] = 'MAILA'] = "MAILA";
        RecordTypeEnum[RecordTypeEnum["ANY"] = 'ANY'] = "ANY";
        RecordTypeEnum[RecordTypeEnum["URI"] = 'URI'] = "URI";
        RecordTypeEnum[RecordTypeEnum["CAA"] = 'CAA'] = "CAA";
        RecordTypeEnum[RecordTypeEnum["AVC"] = 'AVC'] = "AVC";
        RecordTypeEnum[RecordTypeEnum["DOA"] = 'DOA'] = "DOA";
        RecordTypeEnum[RecordTypeEnum["AMTRELAY"] = 'AMTRELAY'] = "AMTRELAY";
        RecordTypeEnum[RecordTypeEnum["TA"] = 'TA'] = "TA";
        RecordTypeEnum[RecordTypeEnum["DLV"] = 'DLV'] = "DLV";
    })(RecordTypeEnum = DNSLookupResult.RecordTypeEnum || (DNSLookupResult.RecordTypeEnum = {}));
})(DNSLookupResult = exports.DNSLookupResult || (exports.DNSLookupResult = {}));
/**
 * @export
 * @namespace DomainNameRecord
 */
var DomainNameRecord;
(function (DomainNameRecord) {
    /**
     * @export
     * @enum {string}
     */
    var RecordTypeEnum;
    (function (RecordTypeEnum) {
        RecordTypeEnum[RecordTypeEnum["A"] = 'A'] = "A";
        RecordTypeEnum[RecordTypeEnum["NS"] = 'NS'] = "NS";
        RecordTypeEnum[RecordTypeEnum["MD"] = 'MD'] = "MD";
        RecordTypeEnum[RecordTypeEnum["MF"] = 'MF'] = "MF";
        RecordTypeEnum[RecordTypeEnum["CNAME"] = 'CNAME'] = "CNAME";
        RecordTypeEnum[RecordTypeEnum["SOA"] = 'SOA'] = "SOA";
        RecordTypeEnum[RecordTypeEnum["MB"] = 'MB'] = "MB";
        RecordTypeEnum[RecordTypeEnum["MG"] = 'MG'] = "MG";
        RecordTypeEnum[RecordTypeEnum["MR"] = 'MR'] = "MR";
        RecordTypeEnum[RecordTypeEnum["NULL"] = 'NULL'] = "NULL";
        RecordTypeEnum[RecordTypeEnum["WKS"] = 'WKS'] = "WKS";
        RecordTypeEnum[RecordTypeEnum["PTR"] = 'PTR'] = "PTR";
        RecordTypeEnum[RecordTypeEnum["HINFO"] = 'HINFO'] = "HINFO";
        RecordTypeEnum[RecordTypeEnum["MINFO"] = 'MINFO'] = "MINFO";
        RecordTypeEnum[RecordTypeEnum["MX"] = 'MX'] = "MX";
        RecordTypeEnum[RecordTypeEnum["TXT"] = 'TXT'] = "TXT";
        RecordTypeEnum[RecordTypeEnum["RP"] = 'RP'] = "RP";
        RecordTypeEnum[RecordTypeEnum["AFSDB"] = 'AFSDB'] = "AFSDB";
        RecordTypeEnum[RecordTypeEnum["X25"] = 'X25'] = "X25";
        RecordTypeEnum[RecordTypeEnum["ISDN"] = 'ISDN'] = "ISDN";
        RecordTypeEnum[RecordTypeEnum["RT"] = 'RT'] = "RT";
        RecordTypeEnum[RecordTypeEnum["NSAP"] = 'NSAP'] = "NSAP";
        RecordTypeEnum[RecordTypeEnum["NSAPPTR"] = 'NSAP_PTR'] = "NSAPPTR";
        RecordTypeEnum[RecordTypeEnum["SIG"] = 'SIG'] = "SIG";
        RecordTypeEnum[RecordTypeEnum["KEY"] = 'KEY'] = "KEY";
        RecordTypeEnum[RecordTypeEnum["PX"] = 'PX'] = "PX";
        RecordTypeEnum[RecordTypeEnum["GPOS"] = 'GPOS'] = "GPOS";
        RecordTypeEnum[RecordTypeEnum["AAAA"] = 'AAAA'] = "AAAA";
        RecordTypeEnum[RecordTypeEnum["LOC"] = 'LOC'] = "LOC";
        RecordTypeEnum[RecordTypeEnum["NXT"] = 'NXT'] = "NXT";
        RecordTypeEnum[RecordTypeEnum["EID"] = 'EID'] = "EID";
        RecordTypeEnum[RecordTypeEnum["NIMLOC"] = 'NIMLOC'] = "NIMLOC";
        RecordTypeEnum[RecordTypeEnum["SRV"] = 'SRV'] = "SRV";
        RecordTypeEnum[RecordTypeEnum["ATMA"] = 'ATMA'] = "ATMA";
        RecordTypeEnum[RecordTypeEnum["NAPTR"] = 'NAPTR'] = "NAPTR";
        RecordTypeEnum[RecordTypeEnum["KX"] = 'KX'] = "KX";
        RecordTypeEnum[RecordTypeEnum["CERT"] = 'CERT'] = "CERT";
        RecordTypeEnum[RecordTypeEnum["A6"] = 'A6'] = "A6";
        RecordTypeEnum[RecordTypeEnum["DNAME"] = 'DNAME'] = "DNAME";
        RecordTypeEnum[RecordTypeEnum["SINK"] = 'SINK'] = "SINK";
        RecordTypeEnum[RecordTypeEnum["OPT"] = 'OPT'] = "OPT";
        RecordTypeEnum[RecordTypeEnum["APL"] = 'APL'] = "APL";
        RecordTypeEnum[RecordTypeEnum["DS"] = 'DS'] = "DS";
        RecordTypeEnum[RecordTypeEnum["SSHFP"] = 'SSHFP'] = "SSHFP";
        RecordTypeEnum[RecordTypeEnum["IPSECKEY"] = 'IPSECKEY'] = "IPSECKEY";
        RecordTypeEnum[RecordTypeEnum["RRSIG"] = 'RRSIG'] = "RRSIG";
        RecordTypeEnum[RecordTypeEnum["NSEC"] = 'NSEC'] = "NSEC";
        RecordTypeEnum[RecordTypeEnum["DNSKEY"] = 'DNSKEY'] = "DNSKEY";
        RecordTypeEnum[RecordTypeEnum["DHCID"] = 'DHCID'] = "DHCID";
        RecordTypeEnum[RecordTypeEnum["NSEC3"] = 'NSEC3'] = "NSEC3";
        RecordTypeEnum[RecordTypeEnum["NSEC3PARAM"] = 'NSEC3PARAM'] = "NSEC3PARAM";
        RecordTypeEnum[RecordTypeEnum["TLSA"] = 'TLSA'] = "TLSA";
        RecordTypeEnum[RecordTypeEnum["SMIMEA"] = 'SMIMEA'] = "SMIMEA";
        RecordTypeEnum[RecordTypeEnum["HIP"] = 'HIP'] = "HIP";
        RecordTypeEnum[RecordTypeEnum["NINFO"] = 'NINFO'] = "NINFO";
        RecordTypeEnum[RecordTypeEnum["RKEY"] = 'RKEY'] = "RKEY";
        RecordTypeEnum[RecordTypeEnum["TALINK"] = 'TALINK'] = "TALINK";
        RecordTypeEnum[RecordTypeEnum["CDS"] = 'CDS'] = "CDS";
        RecordTypeEnum[RecordTypeEnum["CDNSKEY"] = 'CDNSKEY'] = "CDNSKEY";
        RecordTypeEnum[RecordTypeEnum["OPENPGPKEY"] = 'OPENPGPKEY'] = "OPENPGPKEY";
        RecordTypeEnum[RecordTypeEnum["CSYNC"] = 'CSYNC'] = "CSYNC";
        RecordTypeEnum[RecordTypeEnum["ZONEMD"] = 'ZONEMD'] = "ZONEMD";
        RecordTypeEnum[RecordTypeEnum["SVCB"] = 'SVCB'] = "SVCB";
        RecordTypeEnum[RecordTypeEnum["HTTPS"] = 'HTTPS'] = "HTTPS";
        RecordTypeEnum[RecordTypeEnum["SPF"] = 'SPF'] = "SPF";
        RecordTypeEnum[RecordTypeEnum["UINFO"] = 'UINFO'] = "UINFO";
        RecordTypeEnum[RecordTypeEnum["UID"] = 'UID'] = "UID";
        RecordTypeEnum[RecordTypeEnum["GID"] = 'GID'] = "GID";
        RecordTypeEnum[RecordTypeEnum["UNSPEC"] = 'UNSPEC'] = "UNSPEC";
        RecordTypeEnum[RecordTypeEnum["NID"] = 'NID'] = "NID";
        RecordTypeEnum[RecordTypeEnum["L32"] = 'L32'] = "L32";
        RecordTypeEnum[RecordTypeEnum["L64"] = 'L64'] = "L64";
        RecordTypeEnum[RecordTypeEnum["LP"] = 'LP'] = "LP";
        RecordTypeEnum[RecordTypeEnum["EUI48"] = 'EUI48'] = "EUI48";
        RecordTypeEnum[RecordTypeEnum["EUI64"] = 'EUI64'] = "EUI64";
        RecordTypeEnum[RecordTypeEnum["TKEY"] = 'TKEY'] = "TKEY";
        RecordTypeEnum[RecordTypeEnum["TSIG"] = 'TSIG'] = "TSIG";
        RecordTypeEnum[RecordTypeEnum["IXFR"] = 'IXFR'] = "IXFR";
        RecordTypeEnum[RecordTypeEnum["AXFR"] = 'AXFR'] = "AXFR";
        RecordTypeEnum[RecordTypeEnum["MAILB"] = 'MAILB'] = "MAILB";
        RecordTypeEnum[RecordTypeEnum["MAILA"] = 'MAILA'] = "MAILA";
        RecordTypeEnum[RecordTypeEnum["ANY"] = 'ANY'] = "ANY";
        RecordTypeEnum[RecordTypeEnum["URI"] = 'URI'] = "URI";
        RecordTypeEnum[RecordTypeEnum["CAA"] = 'CAA'] = "CAA";
        RecordTypeEnum[RecordTypeEnum["AVC"] = 'AVC'] = "AVC";
        RecordTypeEnum[RecordTypeEnum["DOA"] = 'DOA'] = "DOA";
        RecordTypeEnum[RecordTypeEnum["AMTRELAY"] = 'AMTRELAY'] = "AMTRELAY";
        RecordTypeEnum[RecordTypeEnum["TA"] = 'TA'] = "TA";
        RecordTypeEnum[RecordTypeEnum["DLV"] = 'DLV'] = "DLV";
    })(RecordTypeEnum = DomainNameRecord.RecordTypeEnum || (DomainNameRecord.RecordTypeEnum = {}));
})(DomainNameRecord = exports.DomainNameRecord || (exports.DomainNameRecord = {}));
/**
 * @export
 * @namespace MatchOption
 */
var MatchOption;
(function (MatchOption) {
    /**
     * @export
     * @enum {string}
     */
    var FieldEnum;
    (function (FieldEnum) {
        FieldEnum[FieldEnum["SUBJECT"] = 'SUBJECT'] = "SUBJECT";
        FieldEnum[FieldEnum["TO"] = 'TO'] = "TO";
        FieldEnum[FieldEnum["BCC"] = 'BCC'] = "BCC";
        FieldEnum[FieldEnum["CC"] = 'CC'] = "CC";
        FieldEnum[FieldEnum["FROM"] = 'FROM'] = "FROM";
    })(FieldEnum = MatchOption.FieldEnum || (MatchOption.FieldEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    var ShouldEnum;
    (function (ShouldEnum) {
        ShouldEnum[ShouldEnum["CONTAIN"] = 'CONTAIN'] = "CONTAIN";
        ShouldEnum[ShouldEnum["EQUAL"] = 'EQUAL'] = "EQUAL";
    })(ShouldEnum = MatchOption.ShouldEnum || (MatchOption.ShouldEnum = {}));
})(MatchOption = exports.MatchOption || (exports.MatchOption = {}));
/**
 * @export
 * @namespace ReplyToAliasEmailOptions
 */
var ReplyToAliasEmailOptions;
(function (ReplyToAliasEmailOptions) {
    /**
     * @export
     * @enum {string}
     */
    var SendStrategyEnum;
    (function (SendStrategyEnum) {
        SendStrategyEnum[SendStrategyEnum["SINGLEMESSAGE"] = 'SINGLE_MESSAGE'] = "SINGLEMESSAGE";
    })(SendStrategyEnum = ReplyToAliasEmailOptions.SendStrategyEnum || (ReplyToAliasEmailOptions.SendStrategyEnum = {}));
})(ReplyToAliasEmailOptions = exports.ReplyToAliasEmailOptions || (exports.ReplyToAliasEmailOptions = {}));
/**
 * @export
 * @namespace ReplyToEmailOptions
 */
var ReplyToEmailOptions;
(function (ReplyToEmailOptions) {
    /**
     * @export
     * @enum {string}
     */
    var SendStrategyEnum;
    (function (SendStrategyEnum) {
        SendStrategyEnum[SendStrategyEnum["SINGLEMESSAGE"] = 'SINGLE_MESSAGE'] = "SINGLEMESSAGE";
    })(SendStrategyEnum = ReplyToEmailOptions.SendStrategyEnum || (ReplyToEmailOptions.SendStrategyEnum = {}));
})(ReplyToEmailOptions = exports.ReplyToEmailOptions || (exports.ReplyToEmailOptions = {}));
/**
 * @export
 * @namespace SendEmailOptions
 */
var SendEmailOptions;
(function (SendEmailOptions) {
    /**
     * @export
     * @enum {string}
     */
    var SendStrategyEnum;
    (function (SendStrategyEnum) {
        SendStrategyEnum[SendStrategyEnum["SINGLEMESSAGE"] = 'SINGLE_MESSAGE'] = "SINGLEMESSAGE";
    })(SendStrategyEnum = SendEmailOptions.SendStrategyEnum || (SendEmailOptions.SendStrategyEnum = {}));
})(SendEmailOptions = exports.SendEmailOptions || (exports.SendEmailOptions = {}));
/**
 * @export
 * @namespace TemplateVariable
 */
var TemplateVariable;
(function (TemplateVariable) {
    /**
     * @export
     * @enum {string}
     */
    var VariableTypeEnum;
    (function (VariableTypeEnum) {
        VariableTypeEnum[VariableTypeEnum["STRING"] = 'STRING'] = "STRING";
    })(VariableTypeEnum = TemplateVariable.VariableTypeEnum || (TemplateVariable.VariableTypeEnum = {}));
})(TemplateVariable = exports.TemplateVariable || (exports.TemplateVariable = {}));
/**
 * @export
 * @namespace WaitForConditions
 */
var WaitForConditions;
(function (WaitForConditions) {
    /**
     * @export
     * @enum {string}
     */
    var CountTypeEnum;
    (function (CountTypeEnum) {
        CountTypeEnum[CountTypeEnum["EXACTLY"] = 'EXACTLY'] = "EXACTLY";
        CountTypeEnum[CountTypeEnum["ATLEAST"] = 'ATLEAST'] = "ATLEAST";
    })(CountTypeEnum = WaitForConditions.CountTypeEnum || (WaitForConditions.CountTypeEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    var SortDirectionEnum;
    (function (SortDirectionEnum) {
        SortDirectionEnum[SortDirectionEnum["ASC"] = 'ASC'] = "ASC";
        SortDirectionEnum[SortDirectionEnum["DESC"] = 'DESC'] = "DESC";
    })(SortDirectionEnum = WaitForConditions.SortDirectionEnum || (WaitForConditions.SortDirectionEnum = {}));
})(WaitForConditions = exports.WaitForConditions || (exports.WaitForConditions = {}));
/**
 * @export
 * @namespace WebhookDto
 */
var WebhookDto;
(function (WebhookDto) {
    /**
     * @export
     * @enum {string}
     */
    var MethodEnum;
    (function (MethodEnum) {
        MethodEnum[MethodEnum["GET"] = 'GET'] = "GET";
        MethodEnum[MethodEnum["HEAD"] = 'HEAD'] = "HEAD";
        MethodEnum[MethodEnum["POST"] = 'POST'] = "POST";
        MethodEnum[MethodEnum["PUT"] = 'PUT'] = "PUT";
        MethodEnum[MethodEnum["PATCH"] = 'PATCH'] = "PATCH";
        MethodEnum[MethodEnum["DELETE"] = 'DELETE'] = "DELETE";
        MethodEnum[MethodEnum["OPTIONS"] = 'OPTIONS'] = "OPTIONS";
        MethodEnum[MethodEnum["TRACE"] = 'TRACE'] = "TRACE";
    })(MethodEnum = WebhookDto.MethodEnum || (WebhookDto.MethodEnum = {}));
})(WebhookDto = exports.WebhookDto || (exports.WebhookDto = {}));
/**
 * @export
 * @namespace WebhookPayload
 */
var WebhookPayload;
(function (WebhookPayload) {
    /**
     * @export
     * @enum {string}
     */
    var EventNameEnum;
    (function (EventNameEnum) {
        EventNameEnum[EventNameEnum["EMAILRECEIVED"] = 'EMAIL_RECEIVED'] = "EMAILRECEIVED";
    })(EventNameEnum = WebhookPayload.EventNameEnum || (WebhookPayload.EventNameEnum = {}));
})(WebhookPayload = exports.WebhookPayload || (exports.WebhookPayload = {}));
/**
 * @export
 * @namespace WebhookTestRequest
 */
var WebhookTestRequest;
(function (WebhookTestRequest) {
    /**
     * @export
     * @enum {string}
     */
    var MethodEnum;
    (function (MethodEnum) {
        MethodEnum[MethodEnum["GET"] = 'GET'] = "GET";
        MethodEnum[MethodEnum["HEAD"] = 'HEAD'] = "HEAD";
        MethodEnum[MethodEnum["POST"] = 'POST'] = "POST";
        MethodEnum[MethodEnum["PUT"] = 'PUT'] = "PUT";
        MethodEnum[MethodEnum["PATCH"] = 'PATCH'] = "PATCH";
        MethodEnum[MethodEnum["DELETE"] = 'DELETE'] = "DELETE";
        MethodEnum[MethodEnum["OPTIONS"] = 'OPTIONS'] = "OPTIONS";
        MethodEnum[MethodEnum["TRACE"] = 'TRACE'] = "TRACE";
    })(MethodEnum = WebhookTestRequest.MethodEnum || (WebhookTestRequest.MethodEnum = {}));
})(WebhookTestRequest = exports.WebhookTestRequest || (exports.WebhookTestRequest = {}));
/**
 * AliasControllerApi - fetch parameter creator
 * @export
 */
var AliasControllerApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Email aliases use a MailSlurp randomly generated email address (or a custom domain inbox that you provide) to mask or proxy a real email address. Emails sent to the alias address will be forwarded to the hidden email address it was created for. If you want to send a reply use the threadId attached
         * @summary Create an email alias. Must be verified by clicking link inside verification email that will be sent to the address. Once verified the alias will be active.
         * @param {CreateAliasOptions} createAliasOptions createAliasOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlias: function (createAliasOptions, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'createAliasOptions' is not null or undefined
            if (createAliasOptions === null ||
                createAliasOptions === undefined) {
                throw new RequiredError('createAliasOptions', 'Required parameter createAliasOptions was null or undefined when calling createAlias.');
            }
            var localVarPath = "/aliases";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'CreateAliasOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(createAliasOptions || {})
                : createAliasOptions || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete an email alias
         * @param {string} aliasId aliasId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlias: function (aliasId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'aliasId' is not null or undefined
            if (aliasId === null || aliasId === undefined) {
                throw new RequiredError('aliasId', 'Required parameter aliasId was null or undefined when calling deleteAlias.');
            }
            var localVarPath = "/aliases/{aliasId}".replace("{" + 'aliasId' + "}", encodeURIComponent(String(aliasId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an email alias by ID
         * @summary Get an email alias
         * @param {string} aliasId aliasId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlias: function (aliasId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'aliasId' is not null or undefined
            if (aliasId === null || aliasId === undefined) {
                throw new RequiredError('aliasId', 'Required parameter aliasId was null or undefined when calling getAlias.');
            }
            var localVarPath = "/aliases/{aliasId}".replace("{" + 'aliasId' + "}", encodeURIComponent(String(aliasId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get paginated emails for an alias by ID
         * @summary Get emails for an alias
         * @param {string} aliasId aliasId
         * @param {number} [page] Optional page index alias email list pagination
         * @param {number} [size] Optional page size alias email list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAliasEmails: function (aliasId, page, size, sort, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'aliasId' is not null or undefined
            if (aliasId === null || aliasId === undefined) {
                throw new RequiredError('aliasId', 'Required parameter aliasId was null or undefined when calling getAliasEmails.');
            }
            var localVarPath = "/aliases/{aliasId}/emails".replace("{" + 'aliasId' + "}", encodeURIComponent(String(aliasId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns threads created for an email alias in paginated form
         * @summary Get threads created for an alias
         * @param {string} aliasId aliasId
         * @param {number} [page] Optional page index in thread list pagination
         * @param {number} [size] Optional page size in thread list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAliasThreads: function (aliasId, page, size, sort, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'aliasId' is not null or undefined
            if (aliasId === null || aliasId === undefined) {
                throw new RequiredError('aliasId', 'Required parameter aliasId was null or undefined when calling getAliasThreads.');
            }
            var localVarPath = "/aliases/{aliasId}/threads".replace("{" + 'aliasId' + "}", encodeURIComponent(String(aliasId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all email aliases in paginated form
         * @summary Get all email aliases you have created
         * @param {number} [page] Optional page index in alias list pagination
         * @param {number} [size] Optional page size in alias list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAliases: function (page, size, sort, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/aliases";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send the reply to the email sender or reply-to and include same subject cc bcc etc. Reply to an email and the contents will be sent with the existing subject to the emails `to`, `cc`, and `bcc`.
         * @summary Reply to an email
         * @param {string} aliasId ID of the alias that email belongs to
         * @param {string} emailId ID of the email that should be replied to
         * @param {ReplyToAliasEmailOptions} replyToAliasEmailOptions replyToAliasEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replyToAliasEmail: function (aliasId, emailId, replyToAliasEmailOptions, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'aliasId' is not null or undefined
            if (aliasId === null || aliasId === undefined) {
                throw new RequiredError('aliasId', 'Required parameter aliasId was null or undefined when calling replyToAliasEmail.');
            }
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError('emailId', 'Required parameter emailId was null or undefined when calling replyToAliasEmail.');
            }
            // verify required parameter 'replyToAliasEmailOptions' is not null or undefined
            if (replyToAliasEmailOptions === null ||
                replyToAliasEmailOptions === undefined) {
                throw new RequiredError('replyToAliasEmailOptions', 'Required parameter replyToAliasEmailOptions was null or undefined when calling replyToAliasEmail.');
            }
            var localVarPath = "/aliases/{aliasId}/emails/{emailId}"
                .replace("{" + 'aliasId' + "}", encodeURIComponent(String(aliasId)))
                .replace("{" + 'emailId' + "}", encodeURIComponent(String(emailId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'ReplyToAliasEmailOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(replyToAliasEmailOptions || {})
                : replyToAliasEmailOptions || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send an email from an alias. Replies to the email will be forwarded to the alias masked email address
         * @summary Send an email from an alias inbox
         * @param {string} aliasId aliasId
         * @param {SendEmailOptions} [sendEmailOptions] Options for the email to be sent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendAliasEmail: function (aliasId, sendEmailOptions, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'aliasId' is not null or undefined
            if (aliasId === null || aliasId === undefined) {
                throw new RequiredError('aliasId', 'Required parameter aliasId was null or undefined when calling sendAliasEmail.');
            }
            var localVarPath = "/aliases/{aliasId}/emails".replace("{" + 'aliasId' + "}", encodeURIComponent(String(aliasId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'SendEmailOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(sendEmailOptions || {})
                : sendEmailOptions || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update an email alias
         * @param {string} aliasId aliasId
         * @param {UpdateAliasOptions} updateAliasOptions updateAliasOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlias: function (aliasId, updateAliasOptions, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'aliasId' is not null or undefined
            if (aliasId === null || aliasId === undefined) {
                throw new RequiredError('aliasId', 'Required parameter aliasId was null or undefined when calling updateAlias.');
            }
            // verify required parameter 'updateAliasOptions' is not null or undefined
            if (updateAliasOptions === null ||
                updateAliasOptions === undefined) {
                throw new RequiredError('updateAliasOptions', 'Required parameter updateAliasOptions was null or undefined when calling updateAlias.');
            }
            var localVarPath = "/aliases/{aliasId}".replace("{" + 'aliasId' + "}", encodeURIComponent(String(aliasId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'UpdateAliasOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(updateAliasOptions || {})
                : updateAliasOptions || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.AliasControllerApiFetchParamCreator = AliasControllerApiFetchParamCreator;
/**
 * AliasControllerApi - functional programming interface
 * @export
 */
var AliasControllerApiFp = function (configuration) {
    return {
        /**
         * Email aliases use a MailSlurp randomly generated email address (or a custom domain inbox that you provide) to mask or proxy a real email address. Emails sent to the alias address will be forwarded to the hidden email address it was created for. If you want to send a reply use the threadId attached
         * @summary Create an email alias. Must be verified by clicking link inside verification email that will be sent to the address. Once verified the alias will be active.
         * @param {CreateAliasOptions} createAliasOptions createAliasOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlias: function (createAliasOptions, options) {
            var localVarFetchArgs = exports.AliasControllerApiFetchParamCreator(configuration).createAlias(createAliasOptions, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete an email alias
         * @param {string} aliasId aliasId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlias: function (aliasId, options) {
            var localVarFetchArgs = exports.AliasControllerApiFetchParamCreator(configuration).deleteAlias(aliasId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get an email alias by ID
         * @summary Get an email alias
         * @param {string} aliasId aliasId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlias: function (aliasId, options) {
            var localVarFetchArgs = exports.AliasControllerApiFetchParamCreator(configuration).getAlias(aliasId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get paginated emails for an alias by ID
         * @summary Get emails for an alias
         * @param {string} aliasId aliasId
         * @param {number} [page] Optional page index alias email list pagination
         * @param {number} [size] Optional page size alias email list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAliasEmails: function (aliasId, page, size, sort, options) {
            var localVarFetchArgs = exports.AliasControllerApiFetchParamCreator(configuration).getAliasEmails(aliasId, page, size, sort, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns threads created for an email alias in paginated form
         * @summary Get threads created for an alias
         * @param {string} aliasId aliasId
         * @param {number} [page] Optional page index in thread list pagination
         * @param {number} [size] Optional page size in thread list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAliasThreads: function (aliasId, page, size, sort, options) {
            var localVarFetchArgs = exports.AliasControllerApiFetchParamCreator(configuration).getAliasThreads(aliasId, page, size, sort, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all email aliases in paginated form
         * @summary Get all email aliases you have created
         * @param {number} [page] Optional page index in alias list pagination
         * @param {number} [size] Optional page size in alias list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAliases: function (page, size, sort, options) {
            var localVarFetchArgs = exports.AliasControllerApiFetchParamCreator(configuration).getAliases(page, size, sort, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Send the reply to the email sender or reply-to and include same subject cc bcc etc. Reply to an email and the contents will be sent with the existing subject to the emails `to`, `cc`, and `bcc`.
         * @summary Reply to an email
         * @param {string} aliasId ID of the alias that email belongs to
         * @param {string} emailId ID of the email that should be replied to
         * @param {ReplyToAliasEmailOptions} replyToAliasEmailOptions replyToAliasEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replyToAliasEmail: function (aliasId, emailId, replyToAliasEmailOptions, options) {
            var localVarFetchArgs = exports.AliasControllerApiFetchParamCreator(configuration).replyToAliasEmail(aliasId, emailId, replyToAliasEmailOptions, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Send an email from an alias. Replies to the email will be forwarded to the alias masked email address
         * @summary Send an email from an alias inbox
         * @param {string} aliasId aliasId
         * @param {SendEmailOptions} [sendEmailOptions] Options for the email to be sent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendAliasEmail: function (aliasId, sendEmailOptions, options) {
            var localVarFetchArgs = exports.AliasControllerApiFetchParamCreator(configuration).sendAliasEmail(aliasId, sendEmailOptions, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update an email alias
         * @param {string} aliasId aliasId
         * @param {UpdateAliasOptions} updateAliasOptions updateAliasOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlias: function (aliasId, updateAliasOptions, options) {
            var localVarFetchArgs = exports.AliasControllerApiFetchParamCreator(configuration).updateAlias(aliasId, updateAliasOptions, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.AliasControllerApiFp = AliasControllerApiFp;
/**
 * AliasControllerApi - factory interface
 * @export
 */
var AliasControllerApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Email aliases use a MailSlurp randomly generated email address (or a custom domain inbox that you provide) to mask or proxy a real email address. Emails sent to the alias address will be forwarded to the hidden email address it was created for. If you want to send a reply use the threadId attached
         * @summary Create an email alias. Must be verified by clicking link inside verification email that will be sent to the address. Once verified the alias will be active.
         * @param {CreateAliasOptions} createAliasOptions createAliasOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlias: function (createAliasOptions, options) {
            return exports.AliasControllerApiFp(configuration).createAlias(createAliasOptions, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete an email alias
         * @param {string} aliasId aliasId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlias: function (aliasId, options) {
            return exports.AliasControllerApiFp(configuration).deleteAlias(aliasId, options)(fetch, basePath);
        },
        /**
         * Get an email alias by ID
         * @summary Get an email alias
         * @param {string} aliasId aliasId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlias: function (aliasId, options) {
            return exports.AliasControllerApiFp(configuration).getAlias(aliasId, options)(fetch, basePath);
        },
        /**
         * Get paginated emails for an alias by ID
         * @summary Get emails for an alias
         * @param {string} aliasId aliasId
         * @param {number} [page] Optional page index alias email list pagination
         * @param {number} [size] Optional page size alias email list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAliasEmails: function (aliasId, page, size, sort, options) {
            return exports.AliasControllerApiFp(configuration).getAliasEmails(aliasId, page, size, sort, options)(fetch, basePath);
        },
        /**
         * Returns threads created for an email alias in paginated form
         * @summary Get threads created for an alias
         * @param {string} aliasId aliasId
         * @param {number} [page] Optional page index in thread list pagination
         * @param {number} [size] Optional page size in thread list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAliasThreads: function (aliasId, page, size, sort, options) {
            return exports.AliasControllerApiFp(configuration).getAliasThreads(aliasId, page, size, sort, options)(fetch, basePath);
        },
        /**
         * Get all email aliases in paginated form
         * @summary Get all email aliases you have created
         * @param {number} [page] Optional page index in alias list pagination
         * @param {number} [size] Optional page size in alias list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAliases: function (page, size, sort, options) {
            return exports.AliasControllerApiFp(configuration).getAliases(page, size, sort, options)(fetch, basePath);
        },
        /**
         * Send the reply to the email sender or reply-to and include same subject cc bcc etc. Reply to an email and the contents will be sent with the existing subject to the emails `to`, `cc`, and `bcc`.
         * @summary Reply to an email
         * @param {string} aliasId ID of the alias that email belongs to
         * @param {string} emailId ID of the email that should be replied to
         * @param {ReplyToAliasEmailOptions} replyToAliasEmailOptions replyToAliasEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replyToAliasEmail: function (aliasId, emailId, replyToAliasEmailOptions, options) {
            return exports.AliasControllerApiFp(configuration).replyToAliasEmail(aliasId, emailId, replyToAliasEmailOptions, options)(fetch, basePath);
        },
        /**
         * Send an email from an alias. Replies to the email will be forwarded to the alias masked email address
         * @summary Send an email from an alias inbox
         * @param {string} aliasId aliasId
         * @param {SendEmailOptions} [sendEmailOptions] Options for the email to be sent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendAliasEmail: function (aliasId, sendEmailOptions, options) {
            return exports.AliasControllerApiFp(configuration).sendAliasEmail(aliasId, sendEmailOptions, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an email alias
         * @param {string} aliasId aliasId
         * @param {UpdateAliasOptions} updateAliasOptions updateAliasOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlias: function (aliasId, updateAliasOptions, options) {
            return exports.AliasControllerApiFp(configuration).updateAlias(aliasId, updateAliasOptions, options)(fetch, basePath);
        },
    };
};
exports.AliasControllerApiFactory = AliasControllerApiFactory;
/**
 * AliasControllerApi - object-oriented interface
 * @export
 * @class AliasControllerApi
 * @extends {BaseAPI}
 */
var AliasControllerApi = /** @class */ (function (_super) {
    __extends(AliasControllerApi, _super);
    function AliasControllerApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Email aliases use a MailSlurp randomly generated email address (or a custom domain inbox that you provide) to mask or proxy a real email address. Emails sent to the alias address will be forwarded to the hidden email address it was created for. If you want to send a reply use the threadId attached
     * @summary Create an email alias. Must be verified by clicking link inside verification email that will be sent to the address. Once verified the alias will be active.
     * @param {CreateAliasOptions} createAliasOptions createAliasOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasControllerApi
     */
    AliasControllerApi.prototype.createAlias = function (createAliasOptions, options) {
        return exports.AliasControllerApiFp(this.configuration).createAlias(createAliasOptions, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Delete an email alias
     * @param {string} aliasId aliasId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasControllerApi
     */
    AliasControllerApi.prototype.deleteAlias = function (aliasId, options) {
        return exports.AliasControllerApiFp(this.configuration).deleteAlias(aliasId, options)(this.fetch, this.basePath);
    };
    /**
     * Get an email alias by ID
     * @summary Get an email alias
     * @param {string} aliasId aliasId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasControllerApi
     */
    AliasControllerApi.prototype.getAlias = function (aliasId, options) {
        return exports.AliasControllerApiFp(this.configuration).getAlias(aliasId, options)(this.fetch, this.basePath);
    };
    /**
     * Get paginated emails for an alias by ID
     * @summary Get emails for an alias
     * @param {string} aliasId aliasId
     * @param {number} [page] Optional page index alias email list pagination
     * @param {number} [size] Optional page size alias email list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasControllerApi
     */
    AliasControllerApi.prototype.getAliasEmails = function (aliasId, page, size, sort, options) {
        return exports.AliasControllerApiFp(this.configuration).getAliasEmails(aliasId, page, size, sort, options)(this.fetch, this.basePath);
    };
    /**
     * Returns threads created for an email alias in paginated form
     * @summary Get threads created for an alias
     * @param {string} aliasId aliasId
     * @param {number} [page] Optional page index in thread list pagination
     * @param {number} [size] Optional page size in thread list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasControllerApi
     */
    AliasControllerApi.prototype.getAliasThreads = function (aliasId, page, size, sort, options) {
        return exports.AliasControllerApiFp(this.configuration).getAliasThreads(aliasId, page, size, sort, options)(this.fetch, this.basePath);
    };
    /**
     * Get all email aliases in paginated form
     * @summary Get all email aliases you have created
     * @param {number} [page] Optional page index in alias list pagination
     * @param {number} [size] Optional page size in alias list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasControllerApi
     */
    AliasControllerApi.prototype.getAliases = function (page, size, sort, options) {
        return exports.AliasControllerApiFp(this.configuration).getAliases(page, size, sort, options)(this.fetch, this.basePath);
    };
    /**
     * Send the reply to the email sender or reply-to and include same subject cc bcc etc. Reply to an email and the contents will be sent with the existing subject to the emails `to`, `cc`, and `bcc`.
     * @summary Reply to an email
     * @param {string} aliasId ID of the alias that email belongs to
     * @param {string} emailId ID of the email that should be replied to
     * @param {ReplyToAliasEmailOptions} replyToAliasEmailOptions replyToAliasEmailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasControllerApi
     */
    AliasControllerApi.prototype.replyToAliasEmail = function (aliasId, emailId, replyToAliasEmailOptions, options) {
        return exports.AliasControllerApiFp(this.configuration).replyToAliasEmail(aliasId, emailId, replyToAliasEmailOptions, options)(this.fetch, this.basePath);
    };
    /**
     * Send an email from an alias. Replies to the email will be forwarded to the alias masked email address
     * @summary Send an email from an alias inbox
     * @param {string} aliasId aliasId
     * @param {SendEmailOptions} [sendEmailOptions] Options for the email to be sent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasControllerApi
     */
    AliasControllerApi.prototype.sendAliasEmail = function (aliasId, sendEmailOptions, options) {
        return exports.AliasControllerApiFp(this.configuration).sendAliasEmail(aliasId, sendEmailOptions, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Update an email alias
     * @param {string} aliasId aliasId
     * @param {UpdateAliasOptions} updateAliasOptions updateAliasOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasControllerApi
     */
    AliasControllerApi.prototype.updateAlias = function (aliasId, updateAliasOptions, options) {
        return exports.AliasControllerApiFp(this.configuration).updateAlias(aliasId, updateAliasOptions, options)(this.fetch, this.basePath);
    };
    return AliasControllerApi;
}(BaseAPI));
exports.AliasControllerApi = AliasControllerApi;
/**
 * AttachmentControllerApi - fetch parameter creator
 * @export
 */
var AttachmentControllerApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Returns the specified attachment for a given email as a base 64 encoded string. The response type is application/json. This method is similar to the `downloadAttachment` method but allows some clients to get around issues with binary responses.
         * @summary Get email attachment as base64 encoded string as alternative to binary responses. To read the content decode the Base64 encoded contents.
         * @param {string} attachmentId ID of attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachmentAsBase64Encoded: function (attachmentId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError('attachmentId', 'Required parameter attachmentId was null or undefined when calling downloadAttachmentAsBase64Encoded.');
            }
            var localVarPath = "/attachments/{attachmentId}/base64".replace("{" + 'attachmentId' + "}", encodeURIComponent(String(attachmentId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified attachment for a given email as a stream / array of bytes. You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
         * @summary Download attachments. Get email attachment bytes. If you have trouble with byte responses try the `downloadAttachmentBase64` response endpoints.
         * @param {string} attachmentId ID of attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachmentAsBytes: function (attachmentId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError('attachmentId', 'Required parameter attachmentId was null or undefined when calling downloadAttachmentAsBytes.');
            }
            var localVarPath = "/attachments/{attachmentId}/bytes".replace("{" + 'attachmentId' + "}", encodeURIComponent(String(attachmentId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the metadata for an attachment. It is saved separately to the content of the attachment. Contains properties `name` and `content-type` and `content-length` in bytes for a given attachment.
         * @summary Get email attachment metadata information
         * @param {string} attachmentId ID of attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachmentInfo: function (attachmentId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError('attachmentId', 'Required parameter attachmentId was null or undefined when calling getAttachmentInfo.');
            }
            var localVarPath = "/attachments/{attachmentId}/metadata".replace("{" + 'attachmentId' + "}", encodeURIComponent(String(attachmentId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Email attachments are essentially files with meta data. Files are byte arrays and the meta data is a content type and a filename. These properties allow email clients to display the filename and icon etc. When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment ID and use it with subsequent email sending. For legacy reasons the ID is returned as the first element in an array. Only a single ID is ever returned. To send the attachments pass a list of attachment IDs with `SendEmailOptions` when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
         * @summary Upload an attachment for sending using base64 file encoding. Returns an array whose first element is the ID of the uploaded attachment.
         * @param {UploadAttachmentOptions} uploadOptions uploadOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAttachment: function (uploadOptions, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'uploadOptions' is not null or undefined
            if (uploadOptions === null || uploadOptions === undefined) {
                throw new RequiredError('uploadOptions', 'Required parameter uploadOptions was null or undefined when calling uploadAttachment.');
            }
            var localVarPath = "/attachments";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'UploadAttachmentOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(uploadOptions || {})
                : uploadOptions || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Email attachments are essentially files with meta data. Files are byte arrays and the meta data is a content type and a filename. These properties allow email clients to display the filename and icon etc. When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment ID and use it with subsequent email sending. For legacy reasons the ID is returned as the first element in an array. Only a single ID is ever returned. To send the attachments pass a list of attachment IDs with `SendEmailOptions` when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
         * @summary Upload an attachment for sending using file byte stream input octet stream. Returns an array whose first element is the ID of the uploaded attachment.
         * @param {string} [string] Optional contentType for file. For instance &#x60;application/pdf&#x60;
         * @param {string} [byteArray] Byte array request body
         * @param {string} [filename] Optional filename to save upload with
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAttachmentBytes: function (string, byteArray, filename, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/attachments/bytes";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (string !== undefined) {
                localVarQueryParameter['String'] = string;
            }
            if (filename !== undefined) {
                localVarQueryParameter['filename'] = filename;
            }
            localVarHeaderParameter['Content-Type'] =
                'application/octet-stream';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'string' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(byteArray || {})
                : byteArray || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Email attachments are essentially files with meta data. Files are byte arrays and the meta data is a content type and a filename. These properties allow email clients to display the filename and icon etc. When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment ID and use it with subsequent email sending. For legacy reasons the ID is returned as the first element in an array. Only a single ID is ever returned. To send the attachments pass a list of attachment IDs with `SendEmailOptions` when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
         * @summary Upload an attachment for sending using a Multipart Form request. Returns an array whose first element is the ID of the uploaded attachment.
         * @param {any} file file
         * @param {string} [contentType] Optional content type of attachment
         * @param {string} [contentTypeHeader] Optional content type header of attachment
         * @param {string} [filename] Optional name of file
         * @param {string} [xFilename] Optional content type header of attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMultipartForm: function (file, contentType, contentTypeHeader, filename, xFilename, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file', 'Required parameter file was null or undefined when calling uploadMultipartForm.');
            }
            var localVarPath = "/attachments/multipart";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            var localVarFormParams = new url.URLSearchParams();
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (contentType !== undefined) {
                localVarQueryParameter['contentType'] = contentType;
            }
            if (filename !== undefined) {
                localVarQueryParameter['filename'] = filename;
            }
            if (xFilename !== undefined) {
                localVarQueryParameter['x-filename'] = xFilename;
            }
            if (file !== undefined) {
                localVarFormParams.set('file', file);
            }
            localVarHeaderParameter['Content-Type'] =
                'application/x-www-form-urlencoded';
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();
            var needsSerialization = 'string' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(contentTypeHeader || {})
                : contentTypeHeader || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.AttachmentControllerApiFetchParamCreator = AttachmentControllerApiFetchParamCreator;
/**
 * AttachmentControllerApi - functional programming interface
 * @export
 */
var AttachmentControllerApiFp = function (configuration) {
    return {
        /**
         * Returns the specified attachment for a given email as a base 64 encoded string. The response type is application/json. This method is similar to the `downloadAttachment` method but allows some clients to get around issues with binary responses.
         * @summary Get email attachment as base64 encoded string as alternative to binary responses. To read the content decode the Base64 encoded contents.
         * @param {string} attachmentId ID of attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachmentAsBase64Encoded: function (attachmentId, options) {
            var localVarFetchArgs = exports.AttachmentControllerApiFetchParamCreator(configuration).downloadAttachmentAsBase64Encoded(attachmentId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the specified attachment for a given email as a stream / array of bytes. You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
         * @summary Download attachments. Get email attachment bytes. If you have trouble with byte responses try the `downloadAttachmentBase64` response endpoints.
         * @param {string} attachmentId ID of attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachmentAsBytes: function (attachmentId, options) {
            var localVarFetchArgs = exports.AttachmentControllerApiFetchParamCreator(configuration).downloadAttachmentAsBytes(attachmentId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the metadata for an attachment. It is saved separately to the content of the attachment. Contains properties `name` and `content-type` and `content-length` in bytes for a given attachment.
         * @summary Get email attachment metadata information
         * @param {string} attachmentId ID of attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachmentInfo: function (attachmentId, options) {
            var localVarFetchArgs = exports.AttachmentControllerApiFetchParamCreator(configuration).getAttachmentInfo(attachmentId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Email attachments are essentially files with meta data. Files are byte arrays and the meta data is a content type and a filename. These properties allow email clients to display the filename and icon etc. When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment ID and use it with subsequent email sending. For legacy reasons the ID is returned as the first element in an array. Only a single ID is ever returned. To send the attachments pass a list of attachment IDs with `SendEmailOptions` when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
         * @summary Upload an attachment for sending using base64 file encoding. Returns an array whose first element is the ID of the uploaded attachment.
         * @param {UploadAttachmentOptions} uploadOptions uploadOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAttachment: function (uploadOptions, options) {
            var localVarFetchArgs = exports.AttachmentControllerApiFetchParamCreator(configuration).uploadAttachment(uploadOptions, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Email attachments are essentially files with meta data. Files are byte arrays and the meta data is a content type and a filename. These properties allow email clients to display the filename and icon etc. When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment ID and use it with subsequent email sending. For legacy reasons the ID is returned as the first element in an array. Only a single ID is ever returned. To send the attachments pass a list of attachment IDs with `SendEmailOptions` when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
         * @summary Upload an attachment for sending using file byte stream input octet stream. Returns an array whose first element is the ID of the uploaded attachment.
         * @param {string} [string] Optional contentType for file. For instance &#x60;application/pdf&#x60;
         * @param {string} [byteArray] Byte array request body
         * @param {string} [filename] Optional filename to save upload with
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAttachmentBytes: function (string, byteArray, filename, options) {
            var localVarFetchArgs = exports.AttachmentControllerApiFetchParamCreator(configuration).uploadAttachmentBytes(string, byteArray, filename, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Email attachments are essentially files with meta data. Files are byte arrays and the meta data is a content type and a filename. These properties allow email clients to display the filename and icon etc. When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment ID and use it with subsequent email sending. For legacy reasons the ID is returned as the first element in an array. Only a single ID is ever returned. To send the attachments pass a list of attachment IDs with `SendEmailOptions` when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
         * @summary Upload an attachment for sending using a Multipart Form request. Returns an array whose first element is the ID of the uploaded attachment.
         * @param {any} file file
         * @param {string} [contentType] Optional content type of attachment
         * @param {string} [contentTypeHeader] Optional content type header of attachment
         * @param {string} [filename] Optional name of file
         * @param {string} [xFilename] Optional content type header of attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMultipartForm: function (file, contentType, contentTypeHeader, filename, xFilename, options) {
            var localVarFetchArgs = exports.AttachmentControllerApiFetchParamCreator(configuration).uploadMultipartForm(file, contentType, contentTypeHeader, filename, xFilename, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.AttachmentControllerApiFp = AttachmentControllerApiFp;
/**
 * AttachmentControllerApi - factory interface
 * @export
 */
var AttachmentControllerApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Returns the specified attachment for a given email as a base 64 encoded string. The response type is application/json. This method is similar to the `downloadAttachment` method but allows some clients to get around issues with binary responses.
         * @summary Get email attachment as base64 encoded string as alternative to binary responses. To read the content decode the Base64 encoded contents.
         * @param {string} attachmentId ID of attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachmentAsBase64Encoded: function (attachmentId, options) {
            return exports.AttachmentControllerApiFp(configuration).downloadAttachmentAsBase64Encoded(attachmentId, options)(fetch, basePath);
        },
        /**
         * Returns the specified attachment for a given email as a stream / array of bytes. You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
         * @summary Download attachments. Get email attachment bytes. If you have trouble with byte responses try the `downloadAttachmentBase64` response endpoints.
         * @param {string} attachmentId ID of attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachmentAsBytes: function (attachmentId, options) {
            return exports.AttachmentControllerApiFp(configuration).downloadAttachmentAsBytes(attachmentId, options)(fetch, basePath);
        },
        /**
         * Returns the metadata for an attachment. It is saved separately to the content of the attachment. Contains properties `name` and `content-type` and `content-length` in bytes for a given attachment.
         * @summary Get email attachment metadata information
         * @param {string} attachmentId ID of attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachmentInfo: function (attachmentId, options) {
            return exports.AttachmentControllerApiFp(configuration).getAttachmentInfo(attachmentId, options)(fetch, basePath);
        },
        /**
         * Email attachments are essentially files with meta data. Files are byte arrays and the meta data is a content type and a filename. These properties allow email clients to display the filename and icon etc. When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment ID and use it with subsequent email sending. For legacy reasons the ID is returned as the first element in an array. Only a single ID is ever returned. To send the attachments pass a list of attachment IDs with `SendEmailOptions` when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
         * @summary Upload an attachment for sending using base64 file encoding. Returns an array whose first element is the ID of the uploaded attachment.
         * @param {UploadAttachmentOptions} uploadOptions uploadOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAttachment: function (uploadOptions, options) {
            return exports.AttachmentControllerApiFp(configuration).uploadAttachment(uploadOptions, options)(fetch, basePath);
        },
        /**
         * Email attachments are essentially files with meta data. Files are byte arrays and the meta data is a content type and a filename. These properties allow email clients to display the filename and icon etc. When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment ID and use it with subsequent email sending. For legacy reasons the ID is returned as the first element in an array. Only a single ID is ever returned. To send the attachments pass a list of attachment IDs with `SendEmailOptions` when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
         * @summary Upload an attachment for sending using file byte stream input octet stream. Returns an array whose first element is the ID of the uploaded attachment.
         * @param {string} [string] Optional contentType for file. For instance &#x60;application/pdf&#x60;
         * @param {string} [byteArray] Byte array request body
         * @param {string} [filename] Optional filename to save upload with
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAttachmentBytes: function (string, byteArray, filename, options) {
            return exports.AttachmentControllerApiFp(configuration).uploadAttachmentBytes(string, byteArray, filename, options)(fetch, basePath);
        },
        /**
         * Email attachments are essentially files with meta data. Files are byte arrays and the meta data is a content type and a filename. These properties allow email clients to display the filename and icon etc. When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment ID and use it with subsequent email sending. For legacy reasons the ID is returned as the first element in an array. Only a single ID is ever returned. To send the attachments pass a list of attachment IDs with `SendEmailOptions` when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
         * @summary Upload an attachment for sending using a Multipart Form request. Returns an array whose first element is the ID of the uploaded attachment.
         * @param {any} file file
         * @param {string} [contentType] Optional content type of attachment
         * @param {string} [contentTypeHeader] Optional content type header of attachment
         * @param {string} [filename] Optional name of file
         * @param {string} [xFilename] Optional content type header of attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMultipartForm: function (file, contentType, contentTypeHeader, filename, xFilename, options) {
            return exports.AttachmentControllerApiFp(configuration).uploadMultipartForm(file, contentType, contentTypeHeader, filename, xFilename, options)(fetch, basePath);
        },
    };
};
exports.AttachmentControllerApiFactory = AttachmentControllerApiFactory;
/**
 * AttachmentControllerApi - object-oriented interface
 * @export
 * @class AttachmentControllerApi
 * @extends {BaseAPI}
 */
var AttachmentControllerApi = /** @class */ (function (_super) {
    __extends(AttachmentControllerApi, _super);
    function AttachmentControllerApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns the specified attachment for a given email as a base 64 encoded string. The response type is application/json. This method is similar to the `downloadAttachment` method but allows some clients to get around issues with binary responses.
     * @summary Get email attachment as base64 encoded string as alternative to binary responses. To read the content decode the Base64 encoded contents.
     * @param {string} attachmentId ID of attachment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentControllerApi
     */
    AttachmentControllerApi.prototype.downloadAttachmentAsBase64Encoded = function (attachmentId, options) {
        return exports.AttachmentControllerApiFp(this.configuration).downloadAttachmentAsBase64Encoded(attachmentId, options)(this.fetch, this.basePath);
    };
    /**
     * Returns the specified attachment for a given email as a stream / array of bytes. You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
     * @summary Download attachments. Get email attachment bytes. If you have trouble with byte responses try the `downloadAttachmentBase64` response endpoints.
     * @param {string} attachmentId ID of attachment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentControllerApi
     */
    AttachmentControllerApi.prototype.downloadAttachmentAsBytes = function (attachmentId, options) {
        return exports.AttachmentControllerApiFp(this.configuration).downloadAttachmentAsBytes(attachmentId, options)(this.fetch, this.basePath);
    };
    /**
     * Returns the metadata for an attachment. It is saved separately to the content of the attachment. Contains properties `name` and `content-type` and `content-length` in bytes for a given attachment.
     * @summary Get email attachment metadata information
     * @param {string} attachmentId ID of attachment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentControllerApi
     */
    AttachmentControllerApi.prototype.getAttachmentInfo = function (attachmentId, options) {
        return exports.AttachmentControllerApiFp(this.configuration).getAttachmentInfo(attachmentId, options)(this.fetch, this.basePath);
    };
    /**
     * Email attachments are essentially files with meta data. Files are byte arrays and the meta data is a content type and a filename. These properties allow email clients to display the filename and icon etc. When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment ID and use it with subsequent email sending. For legacy reasons the ID is returned as the first element in an array. Only a single ID is ever returned. To send the attachments pass a list of attachment IDs with `SendEmailOptions` when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
     * @summary Upload an attachment for sending using base64 file encoding. Returns an array whose first element is the ID of the uploaded attachment.
     * @param {UploadAttachmentOptions} uploadOptions uploadOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentControllerApi
     */
    AttachmentControllerApi.prototype.uploadAttachment = function (uploadOptions, options) {
        return exports.AttachmentControllerApiFp(this.configuration).uploadAttachment(uploadOptions, options)(this.fetch, this.basePath);
    };
    /**
     * Email attachments are essentially files with meta data. Files are byte arrays and the meta data is a content type and a filename. These properties allow email clients to display the filename and icon etc. When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment ID and use it with subsequent email sending. For legacy reasons the ID is returned as the first element in an array. Only a single ID is ever returned. To send the attachments pass a list of attachment IDs with `SendEmailOptions` when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
     * @summary Upload an attachment for sending using file byte stream input octet stream. Returns an array whose first element is the ID of the uploaded attachment.
     * @param {string} [string] Optional contentType for file. For instance &#x60;application/pdf&#x60;
     * @param {string} [byteArray] Byte array request body
     * @param {string} [filename] Optional filename to save upload with
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentControllerApi
     */
    AttachmentControllerApi.prototype.uploadAttachmentBytes = function (string, byteArray, filename, options) {
        return exports.AttachmentControllerApiFp(this.configuration).uploadAttachmentBytes(string, byteArray, filename, options)(this.fetch, this.basePath);
    };
    /**
     * Email attachments are essentially files with meta data. Files are byte arrays and the meta data is a content type and a filename. These properties allow email clients to display the filename and icon etc. When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment ID and use it with subsequent email sending. For legacy reasons the ID is returned as the first element in an array. Only a single ID is ever returned. To send the attachments pass a list of attachment IDs with `SendEmailOptions` when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
     * @summary Upload an attachment for sending using a Multipart Form request. Returns an array whose first element is the ID of the uploaded attachment.
     * @param {any} file file
     * @param {string} [contentType] Optional content type of attachment
     * @param {string} [contentTypeHeader] Optional content type header of attachment
     * @param {string} [filename] Optional name of file
     * @param {string} [xFilename] Optional content type header of attachment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentControllerApi
     */
    AttachmentControllerApi.prototype.uploadMultipartForm = function (file, contentType, contentTypeHeader, filename, xFilename, options) {
        return exports.AttachmentControllerApiFp(this.configuration).uploadMultipartForm(file, contentType, contentTypeHeader, filename, xFilename, options)(this.fetch, this.basePath);
    };
    return AttachmentControllerApi;
}(BaseAPI));
exports.AttachmentControllerApi = AttachmentControllerApi;
/**
 * BulkActionsControllerApi - fetch parameter creator
 * @export
 */
var BulkActionsControllerApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Bulk create Inboxes (email addresses)
         * @param {number} count Number of inboxes to be created in bulk
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkCreateInboxes: function (count, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'count' is not null or undefined
            if (count === null || count === undefined) {
                throw new RequiredError('count', 'Required parameter count was null or undefined when calling bulkCreateInboxes.');
            }
            var localVarPath = "/bulk/inboxes";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Bulk Delete Inboxes
         * @param {Array<string>} ids ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkDeleteInboxes: function (ids, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'ids' is not null or undefined
            if (ids === null || ids === undefined) {
                throw new RequiredError('ids', 'Required parameter ids was null or undefined when calling bulkDeleteInboxes.');
            }
            var localVarPath = "/bulk/inboxes";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'Array&lt;string&gt;' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(ids || {})
                : ids || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Bulk Send Emails
         * @param {BulkSendEmailOptions} bulkSendEmailOptions bulkSendEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkSendEmails: function (bulkSendEmailOptions, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'bulkSendEmailOptions' is not null or undefined
            if (bulkSendEmailOptions === null ||
                bulkSendEmailOptions === undefined) {
                throw new RequiredError('bulkSendEmailOptions', 'Required parameter bulkSendEmailOptions was null or undefined when calling bulkSendEmails.');
            }
            var localVarPath = "/bulk/send";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'BulkSendEmailOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(bulkSendEmailOptions || {})
                : bulkSendEmailOptions || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.BulkActionsControllerApiFetchParamCreator = BulkActionsControllerApiFetchParamCreator;
/**
 * BulkActionsControllerApi - functional programming interface
 * @export
 */
var BulkActionsControllerApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Bulk create Inboxes (email addresses)
         * @param {number} count Number of inboxes to be created in bulk
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkCreateInboxes: function (count, options) {
            var localVarFetchArgs = exports.BulkActionsControllerApiFetchParamCreator(configuration).bulkCreateInboxes(count, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Bulk Delete Inboxes
         * @param {Array<string>} ids ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkDeleteInboxes: function (ids, options) {
            var localVarFetchArgs = exports.BulkActionsControllerApiFetchParamCreator(configuration).bulkDeleteInboxes(ids, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Bulk Send Emails
         * @param {BulkSendEmailOptions} bulkSendEmailOptions bulkSendEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkSendEmails: function (bulkSendEmailOptions, options) {
            var localVarFetchArgs = exports.BulkActionsControllerApiFetchParamCreator(configuration).bulkSendEmails(bulkSendEmailOptions, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.BulkActionsControllerApiFp = BulkActionsControllerApiFp;
/**
 * BulkActionsControllerApi - factory interface
 * @export
 */
var BulkActionsControllerApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Bulk create Inboxes (email addresses)
         * @param {number} count Number of inboxes to be created in bulk
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkCreateInboxes: function (count, options) {
            return exports.BulkActionsControllerApiFp(configuration).bulkCreateInboxes(count, options)(fetch, basePath);
        },
        /**
         *
         * @summary Bulk Delete Inboxes
         * @param {Array<string>} ids ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkDeleteInboxes: function (ids, options) {
            return exports.BulkActionsControllerApiFp(configuration).bulkDeleteInboxes(ids, options)(fetch, basePath);
        },
        /**
         *
         * @summary Bulk Send Emails
         * @param {BulkSendEmailOptions} bulkSendEmailOptions bulkSendEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkSendEmails: function (bulkSendEmailOptions, options) {
            return exports.BulkActionsControllerApiFp(configuration).bulkSendEmails(bulkSendEmailOptions, options)(fetch, basePath);
        },
    };
};
exports.BulkActionsControllerApiFactory = BulkActionsControllerApiFactory;
/**
 * BulkActionsControllerApi - object-oriented interface
 * @export
 * @class BulkActionsControllerApi
 * @extends {BaseAPI}
 */
var BulkActionsControllerApi = /** @class */ (function (_super) {
    __extends(BulkActionsControllerApi, _super);
    function BulkActionsControllerApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Bulk create Inboxes (email addresses)
     * @param {number} count Number of inboxes to be created in bulk
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BulkActionsControllerApi
     */
    BulkActionsControllerApi.prototype.bulkCreateInboxes = function (count, options) {
        return exports.BulkActionsControllerApiFp(this.configuration).bulkCreateInboxes(count, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Bulk Delete Inboxes
     * @param {Array<string>} ids ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BulkActionsControllerApi
     */
    BulkActionsControllerApi.prototype.bulkDeleteInboxes = function (ids, options) {
        return exports.BulkActionsControllerApiFp(this.configuration).bulkDeleteInboxes(ids, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Bulk Send Emails
     * @param {BulkSendEmailOptions} bulkSendEmailOptions bulkSendEmailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BulkActionsControllerApi
     */
    BulkActionsControllerApi.prototype.bulkSendEmails = function (bulkSendEmailOptions, options) {
        return exports.BulkActionsControllerApiFp(this.configuration).bulkSendEmails(bulkSendEmailOptions, options)(this.fetch, this.basePath);
    };
    return BulkActionsControllerApi;
}(BaseAPI));
exports.BulkActionsControllerApi = BulkActionsControllerApi;
/**
 * CommonActionsControllerApi - fetch parameter creator
 * @export
 */
var CommonActionsControllerApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Returns an Inbox with an `id` and an `emailAddress`
         * @summary Create new random inbox
         * @param {boolean} [allowTeamAccess] allowTeamAccess
         * @param {Date} [expiresAt] expiresAt
         * @param {number} [expiresIn] expiresIn
         * @param {boolean} [useDomainPool] useDomainPool
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewEmailAddress: function (allowTeamAccess, expiresAt, expiresIn, useDomainPool, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/createInbox";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (allowTeamAccess !== undefined) {
                localVarQueryParameter['allowTeamAccess'] = allowTeamAccess;
            }
            if (expiresAt !== undefined) {
                localVarQueryParameter['expiresAt'] = expiresAt.toISOString();
            }
            if (expiresIn !== undefined) {
                localVarQueryParameter['expiresIn'] = expiresIn;
            }
            if (useDomainPool !== undefined) {
                localVarQueryParameter['useDomainPool'] = useDomainPool;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an Inbox with an `id` and an `emailAddress`
         * @summary Create new random inbox
         * @param {boolean} [allowTeamAccess] allowTeamAccess
         * @param {Date} [expiresAt] expiresAt
         * @param {number} [expiresIn] expiresIn
         * @param {boolean} [useDomainPool] useDomainPool
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewEmailAddress1: function (allowTeamAccess, expiresAt, expiresIn, useDomainPool, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/newEmailAddress";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (allowTeamAccess !== undefined) {
                localVarQueryParameter['allowTeamAccess'] = allowTeamAccess;
            }
            if (expiresAt !== undefined) {
                localVarQueryParameter['expiresAt'] = expiresAt.toISOString();
            }
            if (expiresIn !== undefined) {
                localVarQueryParameter['expiresIn'] = expiresIn;
            }
            if (useDomainPool !== undefined) {
                localVarQueryParameter['useDomainPool'] = useDomainPool;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes all emails
         * @summary Delete all emails in an inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emptyInbox: function (inboxId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError('inboxId', 'Required parameter inboxId was null or undefined when calling emptyInbox.');
            }
            var localVarPath = "/emptyInbox";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (inboxId !== undefined) {
                localVarQueryParameter['inboxId'] = inboxId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If no senderId or inboxId provided a random email address will be used to send from.
         * @summary Send an email
         * @param {SimpleSendEmailOptions} emailOptions emailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailSimple: function (emailOptions, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'emailOptions' is not null or undefined
            if (emailOptions === null || emailOptions === undefined) {
                throw new RequiredError('emailOptions', 'Required parameter emailOptions was null or undefined when calling sendEmailSimple.');
            }
            var localVarPath = "/sendEmail";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'SimpleSendEmailOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(emailOptions || {})
                : emailOptions || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.CommonActionsControllerApiFetchParamCreator = CommonActionsControllerApiFetchParamCreator;
/**
 * CommonActionsControllerApi - functional programming interface
 * @export
 */
var CommonActionsControllerApiFp = function (configuration) {
    return {
        /**
         * Returns an Inbox with an `id` and an `emailAddress`
         * @summary Create new random inbox
         * @param {boolean} [allowTeamAccess] allowTeamAccess
         * @param {Date} [expiresAt] expiresAt
         * @param {number} [expiresIn] expiresIn
         * @param {boolean} [useDomainPool] useDomainPool
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewEmailAddress: function (allowTeamAccess, expiresAt, expiresIn, useDomainPool, options) {
            var localVarFetchArgs = exports.CommonActionsControllerApiFetchParamCreator(configuration).createNewEmailAddress(allowTeamAccess, expiresAt, expiresIn, useDomainPool, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns an Inbox with an `id` and an `emailAddress`
         * @summary Create new random inbox
         * @param {boolean} [allowTeamAccess] allowTeamAccess
         * @param {Date} [expiresAt] expiresAt
         * @param {number} [expiresIn] expiresIn
         * @param {boolean} [useDomainPool] useDomainPool
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewEmailAddress1: function (allowTeamAccess, expiresAt, expiresIn, useDomainPool, options) {
            var localVarFetchArgs = exports.CommonActionsControllerApiFetchParamCreator(configuration).createNewEmailAddress1(allowTeamAccess, expiresAt, expiresIn, useDomainPool, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes all emails
         * @summary Delete all emails in an inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emptyInbox: function (inboxId, options) {
            var localVarFetchArgs = exports.CommonActionsControllerApiFetchParamCreator(configuration).emptyInbox(inboxId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * If no senderId or inboxId provided a random email address will be used to send from.
         * @summary Send an email
         * @param {SimpleSendEmailOptions} emailOptions emailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailSimple: function (emailOptions, options) {
            var localVarFetchArgs = exports.CommonActionsControllerApiFetchParamCreator(configuration).sendEmailSimple(emailOptions, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.CommonActionsControllerApiFp = CommonActionsControllerApiFp;
/**
 * CommonActionsControllerApi - factory interface
 * @export
 */
var CommonActionsControllerApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Returns an Inbox with an `id` and an `emailAddress`
         * @summary Create new random inbox
         * @param {boolean} [allowTeamAccess] allowTeamAccess
         * @param {Date} [expiresAt] expiresAt
         * @param {number} [expiresIn] expiresIn
         * @param {boolean} [useDomainPool] useDomainPool
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewEmailAddress: function (allowTeamAccess, expiresAt, expiresIn, useDomainPool, options) {
            return exports.CommonActionsControllerApiFp(configuration).createNewEmailAddress(allowTeamAccess, expiresAt, expiresIn, useDomainPool, options)(fetch, basePath);
        },
        /**
         * Returns an Inbox with an `id` and an `emailAddress`
         * @summary Create new random inbox
         * @param {boolean} [allowTeamAccess] allowTeamAccess
         * @param {Date} [expiresAt] expiresAt
         * @param {number} [expiresIn] expiresIn
         * @param {boolean} [useDomainPool] useDomainPool
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewEmailAddress1: function (allowTeamAccess, expiresAt, expiresIn, useDomainPool, options) {
            return exports.CommonActionsControllerApiFp(configuration).createNewEmailAddress1(allowTeamAccess, expiresAt, expiresIn, useDomainPool, options)(fetch, basePath);
        },
        /**
         * Deletes all emails
         * @summary Delete all emails in an inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emptyInbox: function (inboxId, options) {
            return exports.CommonActionsControllerApiFp(configuration).emptyInbox(inboxId, options)(fetch, basePath);
        },
        /**
         * If no senderId or inboxId provided a random email address will be used to send from.
         * @summary Send an email
         * @param {SimpleSendEmailOptions} emailOptions emailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailSimple: function (emailOptions, options) {
            return exports.CommonActionsControllerApiFp(configuration).sendEmailSimple(emailOptions, options)(fetch, basePath);
        },
    };
};
exports.CommonActionsControllerApiFactory = CommonActionsControllerApiFactory;
/**
 * CommonActionsControllerApi - object-oriented interface
 * @export
 * @class CommonActionsControllerApi
 * @extends {BaseAPI}
 */
var CommonActionsControllerApi = /** @class */ (function (_super) {
    __extends(CommonActionsControllerApi, _super);
    function CommonActionsControllerApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns an Inbox with an `id` and an `emailAddress`
     * @summary Create new random inbox
     * @param {boolean} [allowTeamAccess] allowTeamAccess
     * @param {Date} [expiresAt] expiresAt
     * @param {number} [expiresIn] expiresIn
     * @param {boolean} [useDomainPool] useDomainPool
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonActionsControllerApi
     */
    CommonActionsControllerApi.prototype.createNewEmailAddress = function (allowTeamAccess, expiresAt, expiresIn, useDomainPool, options) {
        return exports.CommonActionsControllerApiFp(this.configuration).createNewEmailAddress(allowTeamAccess, expiresAt, expiresIn, useDomainPool, options)(this.fetch, this.basePath);
    };
    /**
     * Returns an Inbox with an `id` and an `emailAddress`
     * @summary Create new random inbox
     * @param {boolean} [allowTeamAccess] allowTeamAccess
     * @param {Date} [expiresAt] expiresAt
     * @param {number} [expiresIn] expiresIn
     * @param {boolean} [useDomainPool] useDomainPool
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonActionsControllerApi
     */
    CommonActionsControllerApi.prototype.createNewEmailAddress1 = function (allowTeamAccess, expiresAt, expiresIn, useDomainPool, options) {
        return exports.CommonActionsControllerApiFp(this.configuration).createNewEmailAddress1(allowTeamAccess, expiresAt, expiresIn, useDomainPool, options)(this.fetch, this.basePath);
    };
    /**
     * Deletes all emails
     * @summary Delete all emails in an inbox
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonActionsControllerApi
     */
    CommonActionsControllerApi.prototype.emptyInbox = function (inboxId, options) {
        return exports.CommonActionsControllerApiFp(this.configuration).emptyInbox(inboxId, options)(this.fetch, this.basePath);
    };
    /**
     * If no senderId or inboxId provided a random email address will be used to send from.
     * @summary Send an email
     * @param {SimpleSendEmailOptions} emailOptions emailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonActionsControllerApi
     */
    CommonActionsControllerApi.prototype.sendEmailSimple = function (emailOptions, options) {
        return exports.CommonActionsControllerApiFp(this.configuration).sendEmailSimple(emailOptions, options)(this.fetch, this.basePath);
    };
    return CommonActionsControllerApi;
}(BaseAPI));
exports.CommonActionsControllerApi = CommonActionsControllerApi;
/**
 * ContactControllerApi - fetch parameter creator
 * @export
 */
var ContactControllerApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Create a contact
         * @param {CreateContactOptions} createContactOptions createContactOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContact: function (createContactOptions, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'createContactOptions' is not null or undefined
            if (createContactOptions === null ||
                createContactOptions === undefined) {
                throw new RequiredError('createContactOptions', 'Required parameter createContactOptions was null or undefined when calling createContact.');
            }
            var localVarPath = "/contacts";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'CreateContactOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(createContactOptions || {})
                : createContactOptions || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete contact
         * @param {string} contactId contactId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContact: function (contactId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'contactId' is not null or undefined
            if (contactId === null || contactId === undefined) {
                throw new RequiredError('contactId', 'Required parameter contactId was null or undefined when calling deleteContact.');
            }
            var localVarPath = "/contacts/{contactId}".replace("{" + 'contactId' + "}", encodeURIComponent(String(contactId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all contacts
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllContacts: function (page, size, sort, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/contacts/paginated";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get contact
         * @param {string} contactId contactId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContact: function (contactId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'contactId' is not null or undefined
            if (contactId === null || contactId === undefined) {
                throw new RequiredError('contactId', 'Required parameter contactId was null or undefined when calling getContact.');
            }
            var localVarPath = "/contacts/{contactId}".replace("{" + 'contactId' + "}", encodeURIComponent(String(contactId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all contacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContacts: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/contacts";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.ContactControllerApiFetchParamCreator = ContactControllerApiFetchParamCreator;
/**
 * ContactControllerApi - functional programming interface
 * @export
 */
var ContactControllerApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Create a contact
         * @param {CreateContactOptions} createContactOptions createContactOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContact: function (createContactOptions, options) {
            var localVarFetchArgs = exports.ContactControllerApiFetchParamCreator(configuration).createContact(createContactOptions, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete contact
         * @param {string} contactId contactId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContact: function (contactId, options) {
            var localVarFetchArgs = exports.ContactControllerApiFetchParamCreator(configuration).deleteContact(contactId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all contacts
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllContacts: function (page, size, sort, options) {
            var localVarFetchArgs = exports.ContactControllerApiFetchParamCreator(configuration).getAllContacts(page, size, sort, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get contact
         * @param {string} contactId contactId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContact: function (contactId, options) {
            var localVarFetchArgs = exports.ContactControllerApiFetchParamCreator(configuration).getContact(contactId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all contacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContacts: function (options) {
            var localVarFetchArgs = exports.ContactControllerApiFetchParamCreator(configuration).getContacts(options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.ContactControllerApiFp = ContactControllerApiFp;
/**
 * ContactControllerApi - factory interface
 * @export
 */
var ContactControllerApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Create a contact
         * @param {CreateContactOptions} createContactOptions createContactOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContact: function (createContactOptions, options) {
            return exports.ContactControllerApiFp(configuration).createContact(createContactOptions, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete contact
         * @param {string} contactId contactId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContact: function (contactId, options) {
            return exports.ContactControllerApiFp(configuration).deleteContact(contactId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get all contacts
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllContacts: function (page, size, sort, options) {
            return exports.ContactControllerApiFp(configuration).getAllContacts(page, size, sort, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get contact
         * @param {string} contactId contactId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContact: function (contactId, options) {
            return exports.ContactControllerApiFp(configuration).getContact(contactId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get all contacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContacts: function (options) {
            return exports.ContactControllerApiFp(configuration).getContacts(options)(fetch, basePath);
        },
    };
};
exports.ContactControllerApiFactory = ContactControllerApiFactory;
/**
 * ContactControllerApi - object-oriented interface
 * @export
 * @class ContactControllerApi
 * @extends {BaseAPI}
 */
var ContactControllerApi = /** @class */ (function (_super) {
    __extends(ContactControllerApi, _super);
    function ContactControllerApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Create a contact
     * @param {CreateContactOptions} createContactOptions createContactOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactControllerApi
     */
    ContactControllerApi.prototype.createContact = function (createContactOptions, options) {
        return exports.ContactControllerApiFp(this.configuration).createContact(createContactOptions, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Delete contact
     * @param {string} contactId contactId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactControllerApi
     */
    ContactControllerApi.prototype.deleteContact = function (contactId, options) {
        return exports.ContactControllerApiFp(this.configuration).deleteContact(contactId, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Get all contacts
     * @param {number} [page] Optional page index in inbox list pagination
     * @param {number} [size] Optional page size in inbox list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactControllerApi
     */
    ContactControllerApi.prototype.getAllContacts = function (page, size, sort, options) {
        return exports.ContactControllerApiFp(this.configuration).getAllContacts(page, size, sort, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Get contact
     * @param {string} contactId contactId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactControllerApi
     */
    ContactControllerApi.prototype.getContact = function (contactId, options) {
        return exports.ContactControllerApiFp(this.configuration).getContact(contactId, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Get all contacts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactControllerApi
     */
    ContactControllerApi.prototype.getContacts = function (options) {
        return exports.ContactControllerApiFp(this.configuration).getContacts(options)(this.fetch, this.basePath);
    };
    return ContactControllerApi;
}(BaseAPI));
exports.ContactControllerApi = ContactControllerApi;
/**
 * DomainControllerApi - fetch parameter creator
 * @export
 */
var DomainControllerApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Add a catch all inbox to a domain so that any emails sent to it that cannot be matched will be sent to the catch all inbox generated
         * @summary Add catch all wild card inbox to domain
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDomainWildcardCatchAll: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling addDomainWildcardCatchAll.');
            }
            var localVarPath = "/domains/{id}/wildcard".replace("{" + 'id' + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Link a domain that you own with MailSlurp so you can create email addresses using it. Endpoint returns DNS records used for validation. You must add these verification records to your host provider's DNS setup to verify the domain.
         * @summary Create Domain
         * @param {CreateDomainOptions} domainOptions domainOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDomain: function (domainOptions, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'domainOptions' is not null or undefined
            if (domainOptions === null || domainOptions === undefined) {
                throw new RequiredError('domainOptions', 'Required parameter domainOptions was null or undefined when calling createDomain.');
            }
            var localVarPath = "/domains";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'CreateDomainOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(domainOptions || {})
                : domainOptions || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a domain. This will disable any existing inboxes that use this domain.
         * @summary Delete a domain
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDomain: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling deleteDomain.');
            }
            var localVarPath = "/domains/{id}".replace("{" + 'id' + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns domain verification status and tokens for a given domain
         * @summary Get a domain
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomain: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling getDomain.');
            }
            var localVarPath = "/domains/{id}".replace("{" + 'id' + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all custom domains you have created
         * @summary Get domains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomains: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/domains";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update values on a domain. Note you cannot change the domain name as it is immutable. Recreate the domain if you need to alter this.
         * @summary Update a domain
         * @param {string} id id
         * @param {UpdateDomainOptions} updateDomainDto updateDomainDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomain: function (id, updateDomainDto, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling updateDomain.');
            }
            // verify required parameter 'updateDomainDto' is not null or undefined
            if (updateDomainDto === null || updateDomainDto === undefined) {
                throw new RequiredError('updateDomainDto', 'Required parameter updateDomainDto was null or undefined when calling updateDomain.');
            }
            var localVarPath = "/domains/{id}".replace("{" + 'id' + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'UpdateDomainOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(updateDomainDto || {})
                : updateDomainDto || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.DomainControllerApiFetchParamCreator = DomainControllerApiFetchParamCreator;
/**
 * DomainControllerApi - functional programming interface
 * @export
 */
var DomainControllerApiFp = function (configuration) {
    return {
        /**
         * Add a catch all inbox to a domain so that any emails sent to it that cannot be matched will be sent to the catch all inbox generated
         * @summary Add catch all wild card inbox to domain
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDomainWildcardCatchAll: function (id, options) {
            var localVarFetchArgs = exports.DomainControllerApiFetchParamCreator(configuration).addDomainWildcardCatchAll(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Link a domain that you own with MailSlurp so you can create email addresses using it. Endpoint returns DNS records used for validation. You must add these verification records to your host provider's DNS setup to verify the domain.
         * @summary Create Domain
         * @param {CreateDomainOptions} domainOptions domainOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDomain: function (domainOptions, options) {
            var localVarFetchArgs = exports.DomainControllerApiFetchParamCreator(configuration).createDomain(domainOptions, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a domain. This will disable any existing inboxes that use this domain.
         * @summary Delete a domain
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDomain: function (id, options) {
            var localVarFetchArgs = exports.DomainControllerApiFetchParamCreator(configuration).deleteDomain(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns domain verification status and tokens for a given domain
         * @summary Get a domain
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomain: function (id, options) {
            var localVarFetchArgs = exports.DomainControllerApiFetchParamCreator(configuration).getDomain(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all custom domains you have created
         * @summary Get domains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomains: function (options) {
            var localVarFetchArgs = exports.DomainControllerApiFetchParamCreator(configuration).getDomains(options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update values on a domain. Note you cannot change the domain name as it is immutable. Recreate the domain if you need to alter this.
         * @summary Update a domain
         * @param {string} id id
         * @param {UpdateDomainOptions} updateDomainDto updateDomainDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomain: function (id, updateDomainDto, options) {
            var localVarFetchArgs = exports.DomainControllerApiFetchParamCreator(configuration).updateDomain(id, updateDomainDto, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.DomainControllerApiFp = DomainControllerApiFp;
/**
 * DomainControllerApi - factory interface
 * @export
 */
var DomainControllerApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Add a catch all inbox to a domain so that any emails sent to it that cannot be matched will be sent to the catch all inbox generated
         * @summary Add catch all wild card inbox to domain
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDomainWildcardCatchAll: function (id, options) {
            return exports.DomainControllerApiFp(configuration).addDomainWildcardCatchAll(id, options)(fetch, basePath);
        },
        /**
         * Link a domain that you own with MailSlurp so you can create email addresses using it. Endpoint returns DNS records used for validation. You must add these verification records to your host provider's DNS setup to verify the domain.
         * @summary Create Domain
         * @param {CreateDomainOptions} domainOptions domainOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDomain: function (domainOptions, options) {
            return exports.DomainControllerApiFp(configuration).createDomain(domainOptions, options)(fetch, basePath);
        },
        /**
         * Delete a domain. This will disable any existing inboxes that use this domain.
         * @summary Delete a domain
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDomain: function (id, options) {
            return exports.DomainControllerApiFp(configuration).deleteDomain(id, options)(fetch, basePath);
        },
        /**
         * Returns domain verification status and tokens for a given domain
         * @summary Get a domain
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomain: function (id, options) {
            return exports.DomainControllerApiFp(configuration).getDomain(id, options)(fetch, basePath);
        },
        /**
         * List all custom domains you have created
         * @summary Get domains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomains: function (options) {
            return exports.DomainControllerApiFp(configuration).getDomains(options)(fetch, basePath);
        },
        /**
         * Update values on a domain. Note you cannot change the domain name as it is immutable. Recreate the domain if you need to alter this.
         * @summary Update a domain
         * @param {string} id id
         * @param {UpdateDomainOptions} updateDomainDto updateDomainDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomain: function (id, updateDomainDto, options) {
            return exports.DomainControllerApiFp(configuration).updateDomain(id, updateDomainDto, options)(fetch, basePath);
        },
    };
};
exports.DomainControllerApiFactory = DomainControllerApiFactory;
/**
 * DomainControllerApi - object-oriented interface
 * @export
 * @class DomainControllerApi
 * @extends {BaseAPI}
 */
var DomainControllerApi = /** @class */ (function (_super) {
    __extends(DomainControllerApi, _super);
    function DomainControllerApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Add a catch all inbox to a domain so that any emails sent to it that cannot be matched will be sent to the catch all inbox generated
     * @summary Add catch all wild card inbox to domain
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainControllerApi
     */
    DomainControllerApi.prototype.addDomainWildcardCatchAll = function (id, options) {
        return exports.DomainControllerApiFp(this.configuration).addDomainWildcardCatchAll(id, options)(this.fetch, this.basePath);
    };
    /**
     * Link a domain that you own with MailSlurp so you can create email addresses using it. Endpoint returns DNS records used for validation. You must add these verification records to your host provider's DNS setup to verify the domain.
     * @summary Create Domain
     * @param {CreateDomainOptions} domainOptions domainOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainControllerApi
     */
    DomainControllerApi.prototype.createDomain = function (domainOptions, options) {
        return exports.DomainControllerApiFp(this.configuration).createDomain(domainOptions, options)(this.fetch, this.basePath);
    };
    /**
     * Delete a domain. This will disable any existing inboxes that use this domain.
     * @summary Delete a domain
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainControllerApi
     */
    DomainControllerApi.prototype.deleteDomain = function (id, options) {
        return exports.DomainControllerApiFp(this.configuration).deleteDomain(id, options)(this.fetch, this.basePath);
    };
    /**
     * Returns domain verification status and tokens for a given domain
     * @summary Get a domain
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainControllerApi
     */
    DomainControllerApi.prototype.getDomain = function (id, options) {
        return exports.DomainControllerApiFp(this.configuration).getDomain(id, options)(this.fetch, this.basePath);
    };
    /**
     * List all custom domains you have created
     * @summary Get domains
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainControllerApi
     */
    DomainControllerApi.prototype.getDomains = function (options) {
        return exports.DomainControllerApiFp(this.configuration).getDomains(options)(this.fetch, this.basePath);
    };
    /**
     * Update values on a domain. Note you cannot change the domain name as it is immutable. Recreate the domain if you need to alter this.
     * @summary Update a domain
     * @param {string} id id
     * @param {UpdateDomainOptions} updateDomainDto updateDomainDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainControllerApi
     */
    DomainControllerApi.prototype.updateDomain = function (id, updateDomainDto, options) {
        return exports.DomainControllerApiFp(this.configuration).updateDomain(id, updateDomainDto, options)(this.fetch, this.basePath);
    };
    return DomainControllerApi;
}(BaseAPI));
exports.DomainControllerApi = DomainControllerApi;
/**
 * EmailControllerApi - fetch parameter creator
 * @export
 */
var EmailControllerApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Deletes all emails in your account. Be careful as emails cannot be recovered
         * @summary Delete all emails in all inboxes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllEmails: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/emails";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an email and removes it from the inbox. Deleted emails cannot be recovered.
         * @summary Delete an email
         * @param {string} emailId ID of email to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmail: function (emailId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError('emailId', 'Required parameter emailId was null or undefined when calling deleteEmail.');
            }
            var localVarPath = "/emails/{emailId}".replace("{" + 'emailId' + "}", encodeURIComponent(String(emailId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified attachment for a given email as a stream / array of bytes. You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
         * @summary Get email attachment bytes. Returned as `octet-stream` with content type header. If you have trouble with byte responses try the `downloadAttachmentBase64` response endpoints and convert the base 64 encoded content to a file or string.
         * @param {string} attachmentId ID of attachment
         * @param {string} emailId ID of email
         * @param {string} [apiKey] Can pass apiKey in url for this request if you wish to download the file in a browser. Content type will be set to original content type of the attachment file. This is so that browsers can download the file correctly.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachment: function (attachmentId, emailId, apiKey, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError('attachmentId', 'Required parameter attachmentId was null or undefined when calling downloadAttachment.');
            }
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError('emailId', 'Required parameter emailId was null or undefined when calling downloadAttachment.');
            }
            var localVarPath = "/emails/{emailId}/attachments/{attachmentId}"
                .replace("{" + 'attachmentId' + "}", encodeURIComponent(String(attachmentId)))
                .replace("{" + 'emailId' + "}", encodeURIComponent(String(emailId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (apiKey !== undefined) {
                localVarQueryParameter['apiKey'] = apiKey;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified attachment for a given email as a base 64 encoded string. The response type is application/json. This method is similar to the `downloadAttachment` method but allows some clients to get around issues with binary responses.
         * @summary Get email attachment as base64 encoded string alternative to binary responses. Decode the `base64FileContents` as a `utf-8` encoded string or array of bytes depending on the `contentType`.
         * @param {string} attachmentId ID of attachment
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachmentBase64: function (attachmentId, emailId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError('attachmentId', 'Required parameter attachmentId was null or undefined when calling downloadAttachmentBase64.');
            }
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError('emailId', 'Required parameter emailId was null or undefined when calling downloadAttachmentBase64.');
            }
            var localVarPath = "/emails/{emailId}/attachments/{attachmentId}/base64"
                .replace("{" + 'attachmentId' + "}", encodeURIComponent(String(attachmentId)))
                .replace("{" + 'emailId' + "}", encodeURIComponent(String(emailId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Forward an existing email to new recipients.
         * @summary Forward email to recipients
         * @param {string} emailId ID of email
         * @param {ForwardEmailOptions} forwardEmailOptions forwardEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forwardEmail: function (emailId, forwardEmailOptions, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError('emailId', 'Required parameter emailId was null or undefined when calling forwardEmail.');
            }
            // verify required parameter 'forwardEmailOptions' is not null or undefined
            if (forwardEmailOptions === null ||
                forwardEmailOptions === undefined) {
                throw new RequiredError('forwardEmailOptions', 'Required parameter forwardEmailOptions was null or undefined when calling forwardEmail.');
            }
            var localVarPath = "/emails/{emailId}/forward".replace("{" + 'emailId' + "}", encodeURIComponent(String(emailId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'ForwardEmailOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(forwardEmailOptions || {})
                : forwardEmailOptions || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the metadata such as name and content-type for a given attachment and email.
         * @summary Get email attachment metadata. This is the `contentType` and `contentLength` of an attachment. To get the individual attachments  use the `downloadAttachment` methods.
         * @param {string} attachmentId ID of attachment
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachmentMetaData: function (attachmentId, emailId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError('attachmentId', 'Required parameter attachmentId was null or undefined when calling getAttachmentMetaData.');
            }
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError('emailId', 'Required parameter emailId was null or undefined when calling getAttachmentMetaData.');
            }
            var localVarPath = "/emails/{emailId}/attachments/{attachmentId}/metadata"
                .replace("{" + 'attachmentId' + "}", encodeURIComponent(String(attachmentId)))
                .replace("{" + 'emailId' + "}", encodeURIComponent(String(emailId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of attachment metadata such as name and content-type for a given email if present.
         * @summary Get all email attachment metadata. Metadata includes name and attachment size.
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachments: function (emailId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError('emailId', 'Required parameter emailId was null or undefined when calling getAttachments.');
            }
            var localVarPath = "/emails/{emailId}/attachments".replace("{" + 'emailId' + "}", encodeURIComponent(String(emailId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawEmail endpoints
         * @summary Get email content
         * @param {string} emailId emailId
         * @param {boolean} [decode] Decode email body quoted-printable encoding to plain text. SMTP servers often encode text using quoted-printable format (for instance &#x60;&#x3D;D7&#x60;). This can be a pain for testing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmail: function (emailId, decode, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError('emailId', 'Required parameter emailId was null or undefined when calling getEmail.');
            }
            var localVarPath = "/emails/{emailId}".replace("{" + 'emailId' + "}", encodeURIComponent(String(emailId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (decode !== undefined) {
                localVarQueryParameter['decode'] = decode;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the matches for a given Java style regex pattern. Do not include the typical `/` at start or end of regex in some languages. Given an example `your code is: 12345` the pattern to extract match looks like `code is: (\\d{6})`. This will return an array of matches with the first matching the entire pattern and the subsequent matching the groups: `['code is: 123456', '123456']` See https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html for more information of available patterns.
         * @summary Get email content regex pattern match results. Runs regex against email body and returns match groups.
         * @param {ContentMatchOptions} contentMatchOptions contentMatchOptions
         * @param {string} emailId ID of email to match against
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailContentMatch: function (contentMatchOptions, emailId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'contentMatchOptions' is not null or undefined
            if (contentMatchOptions === null ||
                contentMatchOptions === undefined) {
                throw new RequiredError('contentMatchOptions', 'Required parameter contentMatchOptions was null or undefined when calling getEmailContentMatch.');
            }
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError('emailId', 'Required parameter emailId was null or undefined when calling getEmailContentMatch.');
            }
            var localVarPath = "/emails/{emailId}/contentMatch".replace("{" + 'emailId' + "}", encodeURIComponent(String(emailId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'ContentMatchOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(contentMatchOptions || {})
                : contentMatchOptions || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve email content as HTML response for viewing in browsers. Decodes quoted-printable entities and converts charset to UTF-8. Pass your API KEY as a request parameter when viewing in a browser: `?apiKey=xxx`
         * @summary Get email content as HTML. For displaying emails in browser context.
         * @param {string} emailId emailId
         * @param {boolean} [decode] decode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailHTML: function (emailId, decode, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError('emailId', 'Required parameter emailId was null or undefined when calling getEmailHTML.');
            }
            var localVarPath = "/emails/{emailId}/html".replace("{" + 'emailId' + "}", encodeURIComponent(String(emailId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (decode !== undefined) {
                localVarQueryParameter['decode'] = decode;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Parse an email body and return the content as an array of text. HTML parsing uses JSoup which supports JQuery/CSS style selectors
         * @summary Parse and return text from an email, stripping HTML and decoding encoded characters
         * @param {string} emailId ID of email to perform HTML query on
         * @param {string} [htmlSelector] HTML selector to search for. Uses JQuery/JSoup/CSS style selector like &#39;.my-div&#39; to match content. See https://jsoup.org/apidocs/org/jsoup/select/Selector.html for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailHTMLQuery: function (emailId, htmlSelector, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError('emailId', 'Required parameter emailId was null or undefined when calling getEmailHTMLQuery.');
            }
            var localVarPath = "/emails/{emailId}/htmlQuery".replace("{" + 'emailId' + "}", encodeURIComponent(String(emailId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (htmlSelector !== undefined) {
                localVarQueryParameter['htmlSelector'] = htmlSelector;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Parse an email body and return the content as an array of strings. HTML parsing uses JSoup and UNIX line separators.
         * @summary Parse and return text from an email, stripping HTML and decoding encoded characters
         * @param {string} emailId ID of email to fetch text for
         * @param {boolean} [decodeHtmlEntities] Decode HTML entities
         * @param {string} [lineSeparator] Line separator character
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailTextLines: function (emailId, decodeHtmlEntities, lineSeparator, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError('emailId', 'Required parameter emailId was null or undefined when calling getEmailTextLines.');
            }
            var localVarPath = "/emails/{emailId}/textLines".replace("{" + 'emailId' + "}", encodeURIComponent(String(emailId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (decodeHtmlEntities !== undefined) {
                localVarQueryParameter['decodeHtmlEntities'] = decodeHtmlEntities;
            }
            if (lineSeparator !== undefined) {
                localVarQueryParameter['lineSeparator'] = lineSeparator;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
         * @summary Get all emails in all inboxes. Email API list all.
         * @param {Array<string>} [inboxId] Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account.
         * @param {number} [page] Optional page index in email list pagination
         * @param {number} [size] Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {boolean} [unreadOnly] Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailsPaginated: function (inboxId, page, size, sort, unreadOnly, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/emails";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (inboxId) {
                localVarQueryParameter['inboxId'] = inboxId;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            if (unreadOnly !== undefined) {
                localVarQueryParameter['unreadOnly'] = unreadOnly;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the newest email in all inboxes or in a passed set of inbox IDs
         * @summary Get latest email in all inboxes. Most recently received.
         * @param {Array<string>} [inboxIds] Optional set of inboxes to filter by. Only get the latest email from these inbox IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestEmail: function (inboxIds, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/emails/latest";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (inboxIds) {
                localVarQueryParameter['inboxIds'] = inboxIds;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the newest email in all inboxes or in a passed set of inbox IDs
         * @summary Get latest email in an inbox. Use `WaitForController` to get emails that may not have arrived yet.
         * @param {string} [inboxId] ID of the inbox you want to get the latest email from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestEmailInInbox: function (inboxId, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/emails/latestIn";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (inboxId !== undefined) {
                localVarQueryParameter['inboxId'] = inboxId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * By default returns all emails across all team inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
         * @summary Get all organization emails. List team or shared test email accounts
         * @param {Array<string>} [inboxId] Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account.
         * @param {number} [page] Optional page index in email list pagination
         * @param {number} [size] Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {boolean} [unreadOnly] Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationEmailsPaginated: function (inboxId, page, size, sort, unreadOnly, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/emails/organization";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (inboxId) {
                localVarQueryParameter['inboxId'] = inboxId;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            if (unreadOnly !== undefined) {
                localVarQueryParameter['unreadOnly'] = unreadOnly;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a raw, unparsed, and unprocessed email. If your client has issues processing the response it is likely due to the response content-type which is text/plain. If you need a JSON response content-type use the getRawEmailJson endpoint
         * @summary Get raw email string. Returns unparsed raw SMTP message with headers and body.
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawEmailContents: function (emailId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError('emailId', 'Required parameter emailId was null or undefined when calling getRawEmailContents.');
            }
            var localVarPath = "/emails/{emailId}/raw".replace("{" + 'emailId' + "}", encodeURIComponent(String(emailId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a raw, unparsed, and unprocessed email wrapped in a JSON response object for easier handling when compared with the getRawEmail text/plain response
         * @summary Get raw email in JSON. Unparsed SMTP message in JSON wrapper format.
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawEmailJson: function (emailId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError('emailId', 'Required parameter emailId was null or undefined when calling getRawEmailJson.');
            }
            var localVarPath = "/emails/{emailId}/raw/json".replace("{" + 'emailId' + "}", encodeURIComponent(String(emailId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get number of emails unread. Unread means has not been viewed in dashboard or returned in an email API response
         * @summary Get unread email count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnreadEmailCount: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/emails/unreadCount";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send the reply to the email sender or reply-to and include same subject cc bcc etc. Reply to an email and the contents will be sent with the existing subject to the emails `to`, `cc`, and `bcc`.
         * @summary Reply to an email
         * @param {string} emailId ID of the email that should be replied to
         * @param {ReplyToEmailOptions} replyToEmailOptions replyToEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replyToEmail: function (emailId, replyToEmailOptions, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError('emailId', 'Required parameter emailId was null or undefined when calling replyToEmail.');
            }
            // verify required parameter 'replyToEmailOptions' is not null or undefined
            if (replyToEmailOptions === null ||
                replyToEmailOptions === undefined) {
                throw new RequiredError('replyToEmailOptions', 'Required parameter replyToEmailOptions was null or undefined when calling replyToEmail.');
            }
            var localVarPath = "/emails/{emailId}".replace("{" + 'emailId' + "}", encodeURIComponent(String(emailId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'ReplyToEmailOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(replyToEmailOptions || {})
                : replyToEmailOptions || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate the HTML content of email if HTML is found. Considered valid if no HTML.
         * @summary Validate email HTML contents
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateEmail: function (emailId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError('emailId', 'Required parameter emailId was null or undefined when calling validateEmail.');
            }
            var localVarPath = "/emails/{emailId}/validate".replace("{" + 'emailId' + "}", encodeURIComponent(String(emailId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.EmailControllerApiFetchParamCreator = EmailControllerApiFetchParamCreator;
/**
 * EmailControllerApi - functional programming interface
 * @export
 */
var EmailControllerApiFp = function (configuration) {
    return {
        /**
         * Deletes all emails in your account. Be careful as emails cannot be recovered
         * @summary Delete all emails in all inboxes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllEmails: function (options) {
            var localVarFetchArgs = exports.EmailControllerApiFetchParamCreator(configuration).deleteAllEmails(options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes an email and removes it from the inbox. Deleted emails cannot be recovered.
         * @summary Delete an email
         * @param {string} emailId ID of email to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmail: function (emailId, options) {
            var localVarFetchArgs = exports.EmailControllerApiFetchParamCreator(configuration).deleteEmail(emailId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the specified attachment for a given email as a stream / array of bytes. You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
         * @summary Get email attachment bytes. Returned as `octet-stream` with content type header. If you have trouble with byte responses try the `downloadAttachmentBase64` response endpoints and convert the base 64 encoded content to a file or string.
         * @param {string} attachmentId ID of attachment
         * @param {string} emailId ID of email
         * @param {string} [apiKey] Can pass apiKey in url for this request if you wish to download the file in a browser. Content type will be set to original content type of the attachment file. This is so that browsers can download the file correctly.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachment: function (attachmentId, emailId, apiKey, options) {
            var localVarFetchArgs = exports.EmailControllerApiFetchParamCreator(configuration).downloadAttachment(attachmentId, emailId, apiKey, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the specified attachment for a given email as a base 64 encoded string. The response type is application/json. This method is similar to the `downloadAttachment` method but allows some clients to get around issues with binary responses.
         * @summary Get email attachment as base64 encoded string alternative to binary responses. Decode the `base64FileContents` as a `utf-8` encoded string or array of bytes depending on the `contentType`.
         * @param {string} attachmentId ID of attachment
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachmentBase64: function (attachmentId, emailId, options) {
            var localVarFetchArgs = exports.EmailControllerApiFetchParamCreator(configuration).downloadAttachmentBase64(attachmentId, emailId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Forward an existing email to new recipients.
         * @summary Forward email to recipients
         * @param {string} emailId ID of email
         * @param {ForwardEmailOptions} forwardEmailOptions forwardEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forwardEmail: function (emailId, forwardEmailOptions, options) {
            var localVarFetchArgs = exports.EmailControllerApiFetchParamCreator(configuration).forwardEmail(emailId, forwardEmailOptions, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the metadata such as name and content-type for a given attachment and email.
         * @summary Get email attachment metadata. This is the `contentType` and `contentLength` of an attachment. To get the individual attachments  use the `downloadAttachment` methods.
         * @param {string} attachmentId ID of attachment
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachmentMetaData: function (attachmentId, emailId, options) {
            var localVarFetchArgs = exports.EmailControllerApiFetchParamCreator(configuration).getAttachmentMetaData(attachmentId, emailId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns an array of attachment metadata such as name and content-type for a given email if present.
         * @summary Get all email attachment metadata. Metadata includes name and attachment size.
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachments: function (emailId, options) {
            var localVarFetchArgs = exports.EmailControllerApiFetchParamCreator(configuration).getAttachments(emailId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawEmail endpoints
         * @summary Get email content
         * @param {string} emailId emailId
         * @param {boolean} [decode] Decode email body quoted-printable encoding to plain text. SMTP servers often encode text using quoted-printable format (for instance &#x60;&#x3D;D7&#x60;). This can be a pain for testing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmail: function (emailId, decode, options) {
            var localVarFetchArgs = exports.EmailControllerApiFetchParamCreator(configuration).getEmail(emailId, decode, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return the matches for a given Java style regex pattern. Do not include the typical `/` at start or end of regex in some languages. Given an example `your code is: 12345` the pattern to extract match looks like `code is: (\\d{6})`. This will return an array of matches with the first matching the entire pattern and the subsequent matching the groups: `['code is: 123456', '123456']` See https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html for more information of available patterns.
         * @summary Get email content regex pattern match results. Runs regex against email body and returns match groups.
         * @param {ContentMatchOptions} contentMatchOptions contentMatchOptions
         * @param {string} emailId ID of email to match against
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailContentMatch: function (contentMatchOptions, emailId, options) {
            var localVarFetchArgs = exports.EmailControllerApiFetchParamCreator(configuration).getEmailContentMatch(contentMatchOptions, emailId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve email content as HTML response for viewing in browsers. Decodes quoted-printable entities and converts charset to UTF-8. Pass your API KEY as a request parameter when viewing in a browser: `?apiKey=xxx`
         * @summary Get email content as HTML. For displaying emails in browser context.
         * @param {string} emailId emailId
         * @param {boolean} [decode] decode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailHTML: function (emailId, decode, options) {
            var localVarFetchArgs = exports.EmailControllerApiFetchParamCreator(configuration).getEmailHTML(emailId, decode, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Parse an email body and return the content as an array of text. HTML parsing uses JSoup which supports JQuery/CSS style selectors
         * @summary Parse and return text from an email, stripping HTML and decoding encoded characters
         * @param {string} emailId ID of email to perform HTML query on
         * @param {string} [htmlSelector] HTML selector to search for. Uses JQuery/JSoup/CSS style selector like &#39;.my-div&#39; to match content. See https://jsoup.org/apidocs/org/jsoup/select/Selector.html for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailHTMLQuery: function (emailId, htmlSelector, options) {
            var localVarFetchArgs = exports.EmailControllerApiFetchParamCreator(configuration).getEmailHTMLQuery(emailId, htmlSelector, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Parse an email body and return the content as an array of strings. HTML parsing uses JSoup and UNIX line separators.
         * @summary Parse and return text from an email, stripping HTML and decoding encoded characters
         * @param {string} emailId ID of email to fetch text for
         * @param {boolean} [decodeHtmlEntities] Decode HTML entities
         * @param {string} [lineSeparator] Line separator character
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailTextLines: function (emailId, decodeHtmlEntities, lineSeparator, options) {
            var localVarFetchArgs = exports.EmailControllerApiFetchParamCreator(configuration).getEmailTextLines(emailId, decodeHtmlEntities, lineSeparator, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
         * @summary Get all emails in all inboxes. Email API list all.
         * @param {Array<string>} [inboxId] Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account.
         * @param {number} [page] Optional page index in email list pagination
         * @param {number} [size] Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {boolean} [unreadOnly] Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailsPaginated: function (inboxId, page, size, sort, unreadOnly, options) {
            var localVarFetchArgs = exports.EmailControllerApiFetchParamCreator(configuration).getEmailsPaginated(inboxId, page, size, sort, unreadOnly, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get the newest email in all inboxes or in a passed set of inbox IDs
         * @summary Get latest email in all inboxes. Most recently received.
         * @param {Array<string>} [inboxIds] Optional set of inboxes to filter by. Only get the latest email from these inbox IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestEmail: function (inboxIds, options) {
            var localVarFetchArgs = exports.EmailControllerApiFetchParamCreator(configuration).getLatestEmail(inboxIds, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get the newest email in all inboxes or in a passed set of inbox IDs
         * @summary Get latest email in an inbox. Use `WaitForController` to get emails that may not have arrived yet.
         * @param {string} [inboxId] ID of the inbox you want to get the latest email from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestEmailInInbox: function (inboxId, options) {
            var localVarFetchArgs = exports.EmailControllerApiFetchParamCreator(configuration).getLatestEmailInInbox(inboxId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * By default returns all emails across all team inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
         * @summary Get all organization emails. List team or shared test email accounts
         * @param {Array<string>} [inboxId] Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account.
         * @param {number} [page] Optional page index in email list pagination
         * @param {number} [size] Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {boolean} [unreadOnly] Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationEmailsPaginated: function (inboxId, page, size, sort, unreadOnly, options) {
            var localVarFetchArgs = exports.EmailControllerApiFetchParamCreator(configuration).getOrganizationEmailsPaginated(inboxId, page, size, sort, unreadOnly, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a raw, unparsed, and unprocessed email. If your client has issues processing the response it is likely due to the response content-type which is text/plain. If you need a JSON response content-type use the getRawEmailJson endpoint
         * @summary Get raw email string. Returns unparsed raw SMTP message with headers and body.
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawEmailContents: function (emailId, options) {
            var localVarFetchArgs = exports.EmailControllerApiFetchParamCreator(configuration).getRawEmailContents(emailId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a raw, unparsed, and unprocessed email wrapped in a JSON response object for easier handling when compared with the getRawEmail text/plain response
         * @summary Get raw email in JSON. Unparsed SMTP message in JSON wrapper format.
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawEmailJson: function (emailId, options) {
            var localVarFetchArgs = exports.EmailControllerApiFetchParamCreator(configuration).getRawEmailJson(emailId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get number of emails unread. Unread means has not been viewed in dashboard or returned in an email API response
         * @summary Get unread email count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnreadEmailCount: function (options) {
            var localVarFetchArgs = exports.EmailControllerApiFetchParamCreator(configuration).getUnreadEmailCount(options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Send the reply to the email sender or reply-to and include same subject cc bcc etc. Reply to an email and the contents will be sent with the existing subject to the emails `to`, `cc`, and `bcc`.
         * @summary Reply to an email
         * @param {string} emailId ID of the email that should be replied to
         * @param {ReplyToEmailOptions} replyToEmailOptions replyToEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replyToEmail: function (emailId, replyToEmailOptions, options) {
            var localVarFetchArgs = exports.EmailControllerApiFetchParamCreator(configuration).replyToEmail(emailId, replyToEmailOptions, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Validate the HTML content of email if HTML is found. Considered valid if no HTML.
         * @summary Validate email HTML contents
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateEmail: function (emailId, options) {
            var localVarFetchArgs = exports.EmailControllerApiFetchParamCreator(configuration).validateEmail(emailId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.EmailControllerApiFp = EmailControllerApiFp;
/**
 * EmailControllerApi - factory interface
 * @export
 */
var EmailControllerApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Deletes all emails in your account. Be careful as emails cannot be recovered
         * @summary Delete all emails in all inboxes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllEmails: function (options) {
            return exports.EmailControllerApiFp(configuration).deleteAllEmails(options)(fetch, basePath);
        },
        /**
         * Deletes an email and removes it from the inbox. Deleted emails cannot be recovered.
         * @summary Delete an email
         * @param {string} emailId ID of email to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmail: function (emailId, options) {
            return exports.EmailControllerApiFp(configuration).deleteEmail(emailId, options)(fetch, basePath);
        },
        /**
         * Returns the specified attachment for a given email as a stream / array of bytes. You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
         * @summary Get email attachment bytes. Returned as `octet-stream` with content type header. If you have trouble with byte responses try the `downloadAttachmentBase64` response endpoints and convert the base 64 encoded content to a file or string.
         * @param {string} attachmentId ID of attachment
         * @param {string} emailId ID of email
         * @param {string} [apiKey] Can pass apiKey in url for this request if you wish to download the file in a browser. Content type will be set to original content type of the attachment file. This is so that browsers can download the file correctly.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachment: function (attachmentId, emailId, apiKey, options) {
            return exports.EmailControllerApiFp(configuration).downloadAttachment(attachmentId, emailId, apiKey, options)(fetch, basePath);
        },
        /**
         * Returns the specified attachment for a given email as a base 64 encoded string. The response type is application/json. This method is similar to the `downloadAttachment` method but allows some clients to get around issues with binary responses.
         * @summary Get email attachment as base64 encoded string alternative to binary responses. Decode the `base64FileContents` as a `utf-8` encoded string or array of bytes depending on the `contentType`.
         * @param {string} attachmentId ID of attachment
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachmentBase64: function (attachmentId, emailId, options) {
            return exports.EmailControllerApiFp(configuration).downloadAttachmentBase64(attachmentId, emailId, options)(fetch, basePath);
        },
        /**
         * Forward an existing email to new recipients.
         * @summary Forward email to recipients
         * @param {string} emailId ID of email
         * @param {ForwardEmailOptions} forwardEmailOptions forwardEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forwardEmail: function (emailId, forwardEmailOptions, options) {
            return exports.EmailControllerApiFp(configuration).forwardEmail(emailId, forwardEmailOptions, options)(fetch, basePath);
        },
        /**
         * Returns the metadata such as name and content-type for a given attachment and email.
         * @summary Get email attachment metadata. This is the `contentType` and `contentLength` of an attachment. To get the individual attachments  use the `downloadAttachment` methods.
         * @param {string} attachmentId ID of attachment
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachmentMetaData: function (attachmentId, emailId, options) {
            return exports.EmailControllerApiFp(configuration).getAttachmentMetaData(attachmentId, emailId, options)(fetch, basePath);
        },
        /**
         * Returns an array of attachment metadata such as name and content-type for a given email if present.
         * @summary Get all email attachment metadata. Metadata includes name and attachment size.
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachments: function (emailId, options) {
            return exports.EmailControllerApiFp(configuration).getAttachments(emailId, options)(fetch, basePath);
        },
        /**
         * Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawEmail endpoints
         * @summary Get email content
         * @param {string} emailId emailId
         * @param {boolean} [decode] Decode email body quoted-printable encoding to plain text. SMTP servers often encode text using quoted-printable format (for instance &#x60;&#x3D;D7&#x60;). This can be a pain for testing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmail: function (emailId, decode, options) {
            return exports.EmailControllerApiFp(configuration).getEmail(emailId, decode, options)(fetch, basePath);
        },
        /**
         * Return the matches for a given Java style regex pattern. Do not include the typical `/` at start or end of regex in some languages. Given an example `your code is: 12345` the pattern to extract match looks like `code is: (\\d{6})`. This will return an array of matches with the first matching the entire pattern and the subsequent matching the groups: `['code is: 123456', '123456']` See https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html for more information of available patterns.
         * @summary Get email content regex pattern match results. Runs regex against email body and returns match groups.
         * @param {ContentMatchOptions} contentMatchOptions contentMatchOptions
         * @param {string} emailId ID of email to match against
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailContentMatch: function (contentMatchOptions, emailId, options) {
            return exports.EmailControllerApiFp(configuration).getEmailContentMatch(contentMatchOptions, emailId, options)(fetch, basePath);
        },
        /**
         * Retrieve email content as HTML response for viewing in browsers. Decodes quoted-printable entities and converts charset to UTF-8. Pass your API KEY as a request parameter when viewing in a browser: `?apiKey=xxx`
         * @summary Get email content as HTML. For displaying emails in browser context.
         * @param {string} emailId emailId
         * @param {boolean} [decode] decode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailHTML: function (emailId, decode, options) {
            return exports.EmailControllerApiFp(configuration).getEmailHTML(emailId, decode, options)(fetch, basePath);
        },
        /**
         * Parse an email body and return the content as an array of text. HTML parsing uses JSoup which supports JQuery/CSS style selectors
         * @summary Parse and return text from an email, stripping HTML and decoding encoded characters
         * @param {string} emailId ID of email to perform HTML query on
         * @param {string} [htmlSelector] HTML selector to search for. Uses JQuery/JSoup/CSS style selector like &#39;.my-div&#39; to match content. See https://jsoup.org/apidocs/org/jsoup/select/Selector.html for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailHTMLQuery: function (emailId, htmlSelector, options) {
            return exports.EmailControllerApiFp(configuration).getEmailHTMLQuery(emailId, htmlSelector, options)(fetch, basePath);
        },
        /**
         * Parse an email body and return the content as an array of strings. HTML parsing uses JSoup and UNIX line separators.
         * @summary Parse and return text from an email, stripping HTML and decoding encoded characters
         * @param {string} emailId ID of email to fetch text for
         * @param {boolean} [decodeHtmlEntities] Decode HTML entities
         * @param {string} [lineSeparator] Line separator character
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailTextLines: function (emailId, decodeHtmlEntities, lineSeparator, options) {
            return exports.EmailControllerApiFp(configuration).getEmailTextLines(emailId, decodeHtmlEntities, lineSeparator, options)(fetch, basePath);
        },
        /**
         * By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
         * @summary Get all emails in all inboxes. Email API list all.
         * @param {Array<string>} [inboxId] Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account.
         * @param {number} [page] Optional page index in email list pagination
         * @param {number} [size] Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {boolean} [unreadOnly] Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailsPaginated: function (inboxId, page, size, sort, unreadOnly, options) {
            return exports.EmailControllerApiFp(configuration).getEmailsPaginated(inboxId, page, size, sort, unreadOnly, options)(fetch, basePath);
        },
        /**
         * Get the newest email in all inboxes or in a passed set of inbox IDs
         * @summary Get latest email in all inboxes. Most recently received.
         * @param {Array<string>} [inboxIds] Optional set of inboxes to filter by. Only get the latest email from these inbox IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestEmail: function (inboxIds, options) {
            return exports.EmailControllerApiFp(configuration).getLatestEmail(inboxIds, options)(fetch, basePath);
        },
        /**
         * Get the newest email in all inboxes or in a passed set of inbox IDs
         * @summary Get latest email in an inbox. Use `WaitForController` to get emails that may not have arrived yet.
         * @param {string} [inboxId] ID of the inbox you want to get the latest email from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestEmailInInbox: function (inboxId, options) {
            return exports.EmailControllerApiFp(configuration).getLatestEmailInInbox(inboxId, options)(fetch, basePath);
        },
        /**
         * By default returns all emails across all team inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
         * @summary Get all organization emails. List team or shared test email accounts
         * @param {Array<string>} [inboxId] Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account.
         * @param {number} [page] Optional page index in email list pagination
         * @param {number} [size] Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {boolean} [unreadOnly] Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationEmailsPaginated: function (inboxId, page, size, sort, unreadOnly, options) {
            return exports.EmailControllerApiFp(configuration).getOrganizationEmailsPaginated(inboxId, page, size, sort, unreadOnly, options)(fetch, basePath);
        },
        /**
         * Returns a raw, unparsed, and unprocessed email. If your client has issues processing the response it is likely due to the response content-type which is text/plain. If you need a JSON response content-type use the getRawEmailJson endpoint
         * @summary Get raw email string. Returns unparsed raw SMTP message with headers and body.
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawEmailContents: function (emailId, options) {
            return exports.EmailControllerApiFp(configuration).getRawEmailContents(emailId, options)(fetch, basePath);
        },
        /**
         * Returns a raw, unparsed, and unprocessed email wrapped in a JSON response object for easier handling when compared with the getRawEmail text/plain response
         * @summary Get raw email in JSON. Unparsed SMTP message in JSON wrapper format.
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawEmailJson: function (emailId, options) {
            return exports.EmailControllerApiFp(configuration).getRawEmailJson(emailId, options)(fetch, basePath);
        },
        /**
         * Get number of emails unread. Unread means has not been viewed in dashboard or returned in an email API response
         * @summary Get unread email count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnreadEmailCount: function (options) {
            return exports.EmailControllerApiFp(configuration).getUnreadEmailCount(options)(fetch, basePath);
        },
        /**
         * Send the reply to the email sender or reply-to and include same subject cc bcc etc. Reply to an email and the contents will be sent with the existing subject to the emails `to`, `cc`, and `bcc`.
         * @summary Reply to an email
         * @param {string} emailId ID of the email that should be replied to
         * @param {ReplyToEmailOptions} replyToEmailOptions replyToEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replyToEmail: function (emailId, replyToEmailOptions, options) {
            return exports.EmailControllerApiFp(configuration).replyToEmail(emailId, replyToEmailOptions, options)(fetch, basePath);
        },
        /**
         * Validate the HTML content of email if HTML is found. Considered valid if no HTML.
         * @summary Validate email HTML contents
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateEmail: function (emailId, options) {
            return exports.EmailControllerApiFp(configuration).validateEmail(emailId, options)(fetch, basePath);
        },
    };
};
exports.EmailControllerApiFactory = EmailControllerApiFactory;
/**
 * EmailControllerApi - object-oriented interface
 * @export
 * @class EmailControllerApi
 * @extends {BaseAPI}
 */
var EmailControllerApi = /** @class */ (function (_super) {
    __extends(EmailControllerApi, _super);
    function EmailControllerApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Deletes all emails in your account. Be careful as emails cannot be recovered
     * @summary Delete all emails in all inboxes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    EmailControllerApi.prototype.deleteAllEmails = function (options) {
        return exports.EmailControllerApiFp(this.configuration).deleteAllEmails(options)(this.fetch, this.basePath);
    };
    /**
     * Deletes an email and removes it from the inbox. Deleted emails cannot be recovered.
     * @summary Delete an email
     * @param {string} emailId ID of email to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    EmailControllerApi.prototype.deleteEmail = function (emailId, options) {
        return exports.EmailControllerApiFp(this.configuration).deleteEmail(emailId, options)(this.fetch, this.basePath);
    };
    /**
     * Returns the specified attachment for a given email as a stream / array of bytes. You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
     * @summary Get email attachment bytes. Returned as `octet-stream` with content type header. If you have trouble with byte responses try the `downloadAttachmentBase64` response endpoints and convert the base 64 encoded content to a file or string.
     * @param {string} attachmentId ID of attachment
     * @param {string} emailId ID of email
     * @param {string} [apiKey] Can pass apiKey in url for this request if you wish to download the file in a browser. Content type will be set to original content type of the attachment file. This is so that browsers can download the file correctly.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    EmailControllerApi.prototype.downloadAttachment = function (attachmentId, emailId, apiKey, options) {
        return exports.EmailControllerApiFp(this.configuration).downloadAttachment(attachmentId, emailId, apiKey, options)(this.fetch, this.basePath);
    };
    /**
     * Returns the specified attachment for a given email as a base 64 encoded string. The response type is application/json. This method is similar to the `downloadAttachment` method but allows some clients to get around issues with binary responses.
     * @summary Get email attachment as base64 encoded string alternative to binary responses. Decode the `base64FileContents` as a `utf-8` encoded string or array of bytes depending on the `contentType`.
     * @param {string} attachmentId ID of attachment
     * @param {string} emailId ID of email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    EmailControllerApi.prototype.downloadAttachmentBase64 = function (attachmentId, emailId, options) {
        return exports.EmailControllerApiFp(this.configuration).downloadAttachmentBase64(attachmentId, emailId, options)(this.fetch, this.basePath);
    };
    /**
     * Forward an existing email to new recipients.
     * @summary Forward email to recipients
     * @param {string} emailId ID of email
     * @param {ForwardEmailOptions} forwardEmailOptions forwardEmailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    EmailControllerApi.prototype.forwardEmail = function (emailId, forwardEmailOptions, options) {
        return exports.EmailControllerApiFp(this.configuration).forwardEmail(emailId, forwardEmailOptions, options)(this.fetch, this.basePath);
    };
    /**
     * Returns the metadata such as name and content-type for a given attachment and email.
     * @summary Get email attachment metadata. This is the `contentType` and `contentLength` of an attachment. To get the individual attachments  use the `downloadAttachment` methods.
     * @param {string} attachmentId ID of attachment
     * @param {string} emailId ID of email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    EmailControllerApi.prototype.getAttachmentMetaData = function (attachmentId, emailId, options) {
        return exports.EmailControllerApiFp(this.configuration).getAttachmentMetaData(attachmentId, emailId, options)(this.fetch, this.basePath);
    };
    /**
     * Returns an array of attachment metadata such as name and content-type for a given email if present.
     * @summary Get all email attachment metadata. Metadata includes name and attachment size.
     * @param {string} emailId ID of email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    EmailControllerApi.prototype.getAttachments = function (emailId, options) {
        return exports.EmailControllerApiFp(this.configuration).getAttachments(emailId, options)(this.fetch, this.basePath);
    };
    /**
     * Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawEmail endpoints
     * @summary Get email content
     * @param {string} emailId emailId
     * @param {boolean} [decode] Decode email body quoted-printable encoding to plain text. SMTP servers often encode text using quoted-printable format (for instance &#x60;&#x3D;D7&#x60;). This can be a pain for testing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    EmailControllerApi.prototype.getEmail = function (emailId, decode, options) {
        return exports.EmailControllerApiFp(this.configuration).getEmail(emailId, decode, options)(this.fetch, this.basePath);
    };
    /**
     * Return the matches for a given Java style regex pattern. Do not include the typical `/` at start or end of regex in some languages. Given an example `your code is: 12345` the pattern to extract match looks like `code is: (\\d{6})`. This will return an array of matches with the first matching the entire pattern and the subsequent matching the groups: `['code is: 123456', '123456']` See https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html for more information of available patterns.
     * @summary Get email content regex pattern match results. Runs regex against email body and returns match groups.
     * @param {ContentMatchOptions} contentMatchOptions contentMatchOptions
     * @param {string} emailId ID of email to match against
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    EmailControllerApi.prototype.getEmailContentMatch = function (contentMatchOptions, emailId, options) {
        return exports.EmailControllerApiFp(this.configuration).getEmailContentMatch(contentMatchOptions, emailId, options)(this.fetch, this.basePath);
    };
    /**
     * Retrieve email content as HTML response for viewing in browsers. Decodes quoted-printable entities and converts charset to UTF-8. Pass your API KEY as a request parameter when viewing in a browser: `?apiKey=xxx`
     * @summary Get email content as HTML. For displaying emails in browser context.
     * @param {string} emailId emailId
     * @param {boolean} [decode] decode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    EmailControllerApi.prototype.getEmailHTML = function (emailId, decode, options) {
        return exports.EmailControllerApiFp(this.configuration).getEmailHTML(emailId, decode, options)(this.fetch, this.basePath);
    };
    /**
     * Parse an email body and return the content as an array of text. HTML parsing uses JSoup which supports JQuery/CSS style selectors
     * @summary Parse and return text from an email, stripping HTML and decoding encoded characters
     * @param {string} emailId ID of email to perform HTML query on
     * @param {string} [htmlSelector] HTML selector to search for. Uses JQuery/JSoup/CSS style selector like &#39;.my-div&#39; to match content. See https://jsoup.org/apidocs/org/jsoup/select/Selector.html for more information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    EmailControllerApi.prototype.getEmailHTMLQuery = function (emailId, htmlSelector, options) {
        return exports.EmailControllerApiFp(this.configuration).getEmailHTMLQuery(emailId, htmlSelector, options)(this.fetch, this.basePath);
    };
    /**
     * Parse an email body and return the content as an array of strings. HTML parsing uses JSoup and UNIX line separators.
     * @summary Parse and return text from an email, stripping HTML and decoding encoded characters
     * @param {string} emailId ID of email to fetch text for
     * @param {boolean} [decodeHtmlEntities] Decode HTML entities
     * @param {string} [lineSeparator] Line separator character
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    EmailControllerApi.prototype.getEmailTextLines = function (emailId, decodeHtmlEntities, lineSeparator, options) {
        return exports.EmailControllerApiFp(this.configuration).getEmailTextLines(emailId, decodeHtmlEntities, lineSeparator, options)(this.fetch, this.basePath);
    };
    /**
     * By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
     * @summary Get all emails in all inboxes. Email API list all.
     * @param {Array<string>} [inboxId] Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account.
     * @param {number} [page] Optional page index in email list pagination
     * @param {number} [size] Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {boolean} [unreadOnly] Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    EmailControllerApi.prototype.getEmailsPaginated = function (inboxId, page, size, sort, unreadOnly, options) {
        return exports.EmailControllerApiFp(this.configuration).getEmailsPaginated(inboxId, page, size, sort, unreadOnly, options)(this.fetch, this.basePath);
    };
    /**
     * Get the newest email in all inboxes or in a passed set of inbox IDs
     * @summary Get latest email in all inboxes. Most recently received.
     * @param {Array<string>} [inboxIds] Optional set of inboxes to filter by. Only get the latest email from these inbox IDs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    EmailControllerApi.prototype.getLatestEmail = function (inboxIds, options) {
        return exports.EmailControllerApiFp(this.configuration).getLatestEmail(inboxIds, options)(this.fetch, this.basePath);
    };
    /**
     * Get the newest email in all inboxes or in a passed set of inbox IDs
     * @summary Get latest email in an inbox. Use `WaitForController` to get emails that may not have arrived yet.
     * @param {string} [inboxId] ID of the inbox you want to get the latest email from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    EmailControllerApi.prototype.getLatestEmailInInbox = function (inboxId, options) {
        return exports.EmailControllerApiFp(this.configuration).getLatestEmailInInbox(inboxId, options)(this.fetch, this.basePath);
    };
    /**
     * By default returns all emails across all team inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
     * @summary Get all organization emails. List team or shared test email accounts
     * @param {Array<string>} [inboxId] Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account.
     * @param {number} [page] Optional page index in email list pagination
     * @param {number} [size] Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {boolean} [unreadOnly] Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    EmailControllerApi.prototype.getOrganizationEmailsPaginated = function (inboxId, page, size, sort, unreadOnly, options) {
        return exports.EmailControllerApiFp(this.configuration).getOrganizationEmailsPaginated(inboxId, page, size, sort, unreadOnly, options)(this.fetch, this.basePath);
    };
    /**
     * Returns a raw, unparsed, and unprocessed email. If your client has issues processing the response it is likely due to the response content-type which is text/plain. If you need a JSON response content-type use the getRawEmailJson endpoint
     * @summary Get raw email string. Returns unparsed raw SMTP message with headers and body.
     * @param {string} emailId ID of email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    EmailControllerApi.prototype.getRawEmailContents = function (emailId, options) {
        return exports.EmailControllerApiFp(this.configuration).getRawEmailContents(emailId, options)(this.fetch, this.basePath);
    };
    /**
     * Returns a raw, unparsed, and unprocessed email wrapped in a JSON response object for easier handling when compared with the getRawEmail text/plain response
     * @summary Get raw email in JSON. Unparsed SMTP message in JSON wrapper format.
     * @param {string} emailId ID of email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    EmailControllerApi.prototype.getRawEmailJson = function (emailId, options) {
        return exports.EmailControllerApiFp(this.configuration).getRawEmailJson(emailId, options)(this.fetch, this.basePath);
    };
    /**
     * Get number of emails unread. Unread means has not been viewed in dashboard or returned in an email API response
     * @summary Get unread email count
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    EmailControllerApi.prototype.getUnreadEmailCount = function (options) {
        return exports.EmailControllerApiFp(this.configuration).getUnreadEmailCount(options)(this.fetch, this.basePath);
    };
    /**
     * Send the reply to the email sender or reply-to and include same subject cc bcc etc. Reply to an email and the contents will be sent with the existing subject to the emails `to`, `cc`, and `bcc`.
     * @summary Reply to an email
     * @param {string} emailId ID of the email that should be replied to
     * @param {ReplyToEmailOptions} replyToEmailOptions replyToEmailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    EmailControllerApi.prototype.replyToEmail = function (emailId, replyToEmailOptions, options) {
        return exports.EmailControllerApiFp(this.configuration).replyToEmail(emailId, replyToEmailOptions, options)(this.fetch, this.basePath);
    };
    /**
     * Validate the HTML content of email if HTML is found. Considered valid if no HTML.
     * @summary Validate email HTML contents
     * @param {string} emailId ID of email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    EmailControllerApi.prototype.validateEmail = function (emailId, options) {
        return exports.EmailControllerApiFp(this.configuration).validateEmail(emailId, options)(this.fetch, this.basePath);
    };
    return EmailControllerApi;
}(BaseAPI));
exports.EmailControllerApi = EmailControllerApi;
/**
 * ExpiredControllerApi - fetch parameter creator
 * @export
 */
var ExpiredControllerApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Return default times used for inbox expiration
         * @summary Get default expiration settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpirationDefaults: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/expired/defaults";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use the inboxId to return an ExpiredInboxRecord if an inbox has expired. Inboxes expire and are disabled if an expiration date is set or plan requires. Returns 404 if no expired inbox is found for the inboxId
         * @summary Get expired inbox record for a previously existing inbox
         * @param {string} inboxId ID of inbox you want to retrieve (not the inbox ID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpiredInboxByInboxId: function (inboxId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError('inboxId', 'Required parameter inboxId was null or undefined when calling getExpiredInboxByInboxId.');
            }
            var localVarPath = "/expired/inbox/{inboxId}".replace("{" + 'inboxId' + "}", encodeURIComponent(String(inboxId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Inboxes created with an expiration date will expire after the given date and be moved to an ExpiredInbox entity. You can still read emails in the inbox but it can no longer send or receive emails. Fetch the expired inboxes to view the old inboxes properties
         * @summary Get an expired inbox record
         * @param {string} expiredId ID of the ExpiredInboxRecord you want to retrieve. This is different from the ID of the inbox you are interested in. See other methods for getting ExpiredInboxRecord for an inbox inboxId)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpiredInboxRecord: function (expiredId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'expiredId' is not null or undefined
            if (expiredId === null || expiredId === undefined) {
                throw new RequiredError('expiredId', 'Required parameter expiredId was null or undefined when calling getExpiredInboxRecord.');
            }
            var localVarPath = "/expired/{expiredId}".replace("{" + 'expiredId' + "}", encodeURIComponent(String(expiredId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Inboxes created with an expiration date will expire after the given date. An ExpiredInboxRecord is created that records the inboxes old ID and email address. You can still read emails in the inbox (using the inboxes old ID) but the email address associated with the inbox can no longer send or receive emails. Fetch expired inbox records to view the old inboxes properties
         * @summary List records of expired inboxes
         * @param {number} [page] Optional page index in inbox sent email list pagination
         * @param {number} [size] Optional page size in inbox sent email list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpiredInboxes: function (page, size, sort, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/expired";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.ExpiredControllerApiFetchParamCreator = ExpiredControllerApiFetchParamCreator;
/**
 * ExpiredControllerApi - functional programming interface
 * @export
 */
var ExpiredControllerApiFp = function (configuration) {
    return {
        /**
         * Return default times used for inbox expiration
         * @summary Get default expiration settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpirationDefaults: function (options) {
            var localVarFetchArgs = exports.ExpiredControllerApiFetchParamCreator(configuration).getExpirationDefaults(options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Use the inboxId to return an ExpiredInboxRecord if an inbox has expired. Inboxes expire and are disabled if an expiration date is set or plan requires. Returns 404 if no expired inbox is found for the inboxId
         * @summary Get expired inbox record for a previously existing inbox
         * @param {string} inboxId ID of inbox you want to retrieve (not the inbox ID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpiredInboxByInboxId: function (inboxId, options) {
            var localVarFetchArgs = exports.ExpiredControllerApiFetchParamCreator(configuration).getExpiredInboxByInboxId(inboxId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Inboxes created with an expiration date will expire after the given date and be moved to an ExpiredInbox entity. You can still read emails in the inbox but it can no longer send or receive emails. Fetch the expired inboxes to view the old inboxes properties
         * @summary Get an expired inbox record
         * @param {string} expiredId ID of the ExpiredInboxRecord you want to retrieve. This is different from the ID of the inbox you are interested in. See other methods for getting ExpiredInboxRecord for an inbox inboxId)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpiredInboxRecord: function (expiredId, options) {
            var localVarFetchArgs = exports.ExpiredControllerApiFetchParamCreator(configuration).getExpiredInboxRecord(expiredId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Inboxes created with an expiration date will expire after the given date. An ExpiredInboxRecord is created that records the inboxes old ID and email address. You can still read emails in the inbox (using the inboxes old ID) but the email address associated with the inbox can no longer send or receive emails. Fetch expired inbox records to view the old inboxes properties
         * @summary List records of expired inboxes
         * @param {number} [page] Optional page index in inbox sent email list pagination
         * @param {number} [size] Optional page size in inbox sent email list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpiredInboxes: function (page, size, sort, options) {
            var localVarFetchArgs = exports.ExpiredControllerApiFetchParamCreator(configuration).getExpiredInboxes(page, size, sort, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.ExpiredControllerApiFp = ExpiredControllerApiFp;
/**
 * ExpiredControllerApi - factory interface
 * @export
 */
var ExpiredControllerApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Return default times used for inbox expiration
         * @summary Get default expiration settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpirationDefaults: function (options) {
            return exports.ExpiredControllerApiFp(configuration).getExpirationDefaults(options)(fetch, basePath);
        },
        /**
         * Use the inboxId to return an ExpiredInboxRecord if an inbox has expired. Inboxes expire and are disabled if an expiration date is set or plan requires. Returns 404 if no expired inbox is found for the inboxId
         * @summary Get expired inbox record for a previously existing inbox
         * @param {string} inboxId ID of inbox you want to retrieve (not the inbox ID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpiredInboxByInboxId: function (inboxId, options) {
            return exports.ExpiredControllerApiFp(configuration).getExpiredInboxByInboxId(inboxId, options)(fetch, basePath);
        },
        /**
         * Inboxes created with an expiration date will expire after the given date and be moved to an ExpiredInbox entity. You can still read emails in the inbox but it can no longer send or receive emails. Fetch the expired inboxes to view the old inboxes properties
         * @summary Get an expired inbox record
         * @param {string} expiredId ID of the ExpiredInboxRecord you want to retrieve. This is different from the ID of the inbox you are interested in. See other methods for getting ExpiredInboxRecord for an inbox inboxId)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpiredInboxRecord: function (expiredId, options) {
            return exports.ExpiredControllerApiFp(configuration).getExpiredInboxRecord(expiredId, options)(fetch, basePath);
        },
        /**
         * Inboxes created with an expiration date will expire after the given date. An ExpiredInboxRecord is created that records the inboxes old ID and email address. You can still read emails in the inbox (using the inboxes old ID) but the email address associated with the inbox can no longer send or receive emails. Fetch expired inbox records to view the old inboxes properties
         * @summary List records of expired inboxes
         * @param {number} [page] Optional page index in inbox sent email list pagination
         * @param {number} [size] Optional page size in inbox sent email list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpiredInboxes: function (page, size, sort, options) {
            return exports.ExpiredControllerApiFp(configuration).getExpiredInboxes(page, size, sort, options)(fetch, basePath);
        },
    };
};
exports.ExpiredControllerApiFactory = ExpiredControllerApiFactory;
/**
 * ExpiredControllerApi - object-oriented interface
 * @export
 * @class ExpiredControllerApi
 * @extends {BaseAPI}
 */
var ExpiredControllerApi = /** @class */ (function (_super) {
    __extends(ExpiredControllerApi, _super);
    function ExpiredControllerApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Return default times used for inbox expiration
     * @summary Get default expiration settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExpiredControllerApi
     */
    ExpiredControllerApi.prototype.getExpirationDefaults = function (options) {
        return exports.ExpiredControllerApiFp(this.configuration).getExpirationDefaults(options)(this.fetch, this.basePath);
    };
    /**
     * Use the inboxId to return an ExpiredInboxRecord if an inbox has expired. Inboxes expire and are disabled if an expiration date is set or plan requires. Returns 404 if no expired inbox is found for the inboxId
     * @summary Get expired inbox record for a previously existing inbox
     * @param {string} inboxId ID of inbox you want to retrieve (not the inbox ID)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExpiredControllerApi
     */
    ExpiredControllerApi.prototype.getExpiredInboxByInboxId = function (inboxId, options) {
        return exports.ExpiredControllerApiFp(this.configuration).getExpiredInboxByInboxId(inboxId, options)(this.fetch, this.basePath);
    };
    /**
     * Inboxes created with an expiration date will expire after the given date and be moved to an ExpiredInbox entity. You can still read emails in the inbox but it can no longer send or receive emails. Fetch the expired inboxes to view the old inboxes properties
     * @summary Get an expired inbox record
     * @param {string} expiredId ID of the ExpiredInboxRecord you want to retrieve. This is different from the ID of the inbox you are interested in. See other methods for getting ExpiredInboxRecord for an inbox inboxId)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExpiredControllerApi
     */
    ExpiredControllerApi.prototype.getExpiredInboxRecord = function (expiredId, options) {
        return exports.ExpiredControllerApiFp(this.configuration).getExpiredInboxRecord(expiredId, options)(this.fetch, this.basePath);
    };
    /**
     * Inboxes created with an expiration date will expire after the given date. An ExpiredInboxRecord is created that records the inboxes old ID and email address. You can still read emails in the inbox (using the inboxes old ID) but the email address associated with the inbox can no longer send or receive emails. Fetch expired inbox records to view the old inboxes properties
     * @summary List records of expired inboxes
     * @param {number} [page] Optional page index in inbox sent email list pagination
     * @param {number} [size] Optional page size in inbox sent email list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExpiredControllerApi
     */
    ExpiredControllerApi.prototype.getExpiredInboxes = function (page, size, sort, options) {
        return exports.ExpiredControllerApiFp(this.configuration).getExpiredInboxes(page, size, sort, options)(this.fetch, this.basePath);
    };
    return ExpiredControllerApi;
}(BaseAPI));
exports.ExpiredControllerApi = ExpiredControllerApi;
/**
 * FormControllerApi - fetch parameter creator
 * @export
 */
var FormControllerApiFetchParamCreator = function (configuration) {
    return {
        /**
         * This endpoint allows you to submit HTML forms and receive the field values and files via email.   #### Parameters The endpoint looks for special meta parameters in the form fields OR in the URL request parameters. The meta parameters can be used to specify the behaviour of the email.   You must provide at-least a `_to` email address to tell the endpoint where the form should be emailed. These can be submitted as hidden HTML input fields with the corresponding `name` attributes or as URL query parameters such as `?_to=test@example.com`  The endpoint takes all other form fields that are named and includes them in the message body of the email. Files are sent as attachments.  #### Submitting This endpoint accepts form submission via POST method. It accepts `application/x-www-form-urlencoded`, and `multipart/form-data` content-types.  #### HTML Example ```html <form    action=\"https://api.mailslurp.com/forms\"   method=\"post\" >   <input name=\"_to\" type=\"hidden\" value=\"test@example.com\"/>   <textarea name=\"feedback\"></textarea>   <button type=\"submit\">Submit</button> </form> ```  #### URL Example ```html <form    action=\"https://api.mailslurp.com/forms?_to=test@example.com\"   method=\"post\" >   <textarea name=\"feedback\"></textarea>   <button type=\"submit\">Submit</button> </form> ```    The email address is specified by a `_to` field OR is extracted from an email alias specified by a `_toAlias` field (see the alias controller for more information).  Endpoint accepts .  You can specify a content type in HTML forms using the `enctype` attribute, for instance: `<form enctype=\"multipart/form-data\">`.
         * @summary Submit a form to be parsed and sent as an email to an address determined by the form fields
         * @param {string} [emailAddress] Email address of the submitting user. Include this if you wish to record the submitters email address and reply to it later.
         * @param {string} [redirectTo] Optional URL to redirect form submitter to after submission. If not present user will see a success message.
         * @param {string} [spamCheck] Optional but recommended field that catches spammers out. Include as a hidden form field but LEAVE EMPTY. Spam-bots will usually fill every field. If the _spamCheck field is filled the form submission will be ignored.
         * @param {string} [subject] Optional subject of the email that will be sent.
         * @param {string} [successMessage] Optional success message to display if no _redirectTo present.
         * @param {string} [to] The email address that submitted form should be sent to.
         * @param {string} [otherParameters] All other parameters or fields will be accepted and attached to the sent email. This includes files and any HTML form field with a name. These fields will become the body of the email that is sent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitForm: function (emailAddress, redirectTo, spamCheck, subject, successMessage, to, otherParameters, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/forms";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            var localVarFormParams = new url.URLSearchParams();
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (emailAddress !== undefined) {
                localVarFormParams.set('_emailAddress', emailAddress);
            }
            if (redirectTo !== undefined) {
                localVarFormParams.set('_redirectTo', redirectTo);
            }
            if (spamCheck !== undefined) {
                localVarFormParams.set('_spamCheck', spamCheck);
            }
            if (subject !== undefined) {
                localVarFormParams.set('_subject', subject);
            }
            if (successMessage !== undefined) {
                localVarFormParams.set('_successMessage', successMessage);
            }
            if (to !== undefined) {
                localVarFormParams.set('_to', to);
            }
            if (otherParameters !== undefined) {
                localVarFormParams.set('otherParameters', otherParameters);
            }
            localVarHeaderParameter['Content-Type'] =
                'application/x-www-form-urlencoded';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.FormControllerApiFetchParamCreator = FormControllerApiFetchParamCreator;
/**
 * FormControllerApi - functional programming interface
 * @export
 */
var FormControllerApiFp = function (configuration) {
    return {
        /**
         * This endpoint allows you to submit HTML forms and receive the field values and files via email.   #### Parameters The endpoint looks for special meta parameters in the form fields OR in the URL request parameters. The meta parameters can be used to specify the behaviour of the email.   You must provide at-least a `_to` email address to tell the endpoint where the form should be emailed. These can be submitted as hidden HTML input fields with the corresponding `name` attributes or as URL query parameters such as `?_to=test@example.com`  The endpoint takes all other form fields that are named and includes them in the message body of the email. Files are sent as attachments.  #### Submitting This endpoint accepts form submission via POST method. It accepts `application/x-www-form-urlencoded`, and `multipart/form-data` content-types.  #### HTML Example ```html <form    action=\"https://api.mailslurp.com/forms\"   method=\"post\" >   <input name=\"_to\" type=\"hidden\" value=\"test@example.com\"/>   <textarea name=\"feedback\"></textarea>   <button type=\"submit\">Submit</button> </form> ```  #### URL Example ```html <form    action=\"https://api.mailslurp.com/forms?_to=test@example.com\"   method=\"post\" >   <textarea name=\"feedback\"></textarea>   <button type=\"submit\">Submit</button> </form> ```    The email address is specified by a `_to` field OR is extracted from an email alias specified by a `_toAlias` field (see the alias controller for more information).  Endpoint accepts .  You can specify a content type in HTML forms using the `enctype` attribute, for instance: `<form enctype=\"multipart/form-data\">`.
         * @summary Submit a form to be parsed and sent as an email to an address determined by the form fields
         * @param {string} [emailAddress] Email address of the submitting user. Include this if you wish to record the submitters email address and reply to it later.
         * @param {string} [redirectTo] Optional URL to redirect form submitter to after submission. If not present user will see a success message.
         * @param {string} [spamCheck] Optional but recommended field that catches spammers out. Include as a hidden form field but LEAVE EMPTY. Spam-bots will usually fill every field. If the _spamCheck field is filled the form submission will be ignored.
         * @param {string} [subject] Optional subject of the email that will be sent.
         * @param {string} [successMessage] Optional success message to display if no _redirectTo present.
         * @param {string} [to] The email address that submitted form should be sent to.
         * @param {string} [otherParameters] All other parameters or fields will be accepted and attached to the sent email. This includes files and any HTML form field with a name. These fields will become the body of the email that is sent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitForm: function (emailAddress, redirectTo, spamCheck, subject, successMessage, to, otherParameters, options) {
            var localVarFetchArgs = exports.FormControllerApiFetchParamCreator(configuration).submitForm(emailAddress, redirectTo, spamCheck, subject, successMessage, to, otherParameters, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.FormControllerApiFp = FormControllerApiFp;
/**
 * FormControllerApi - factory interface
 * @export
 */
var FormControllerApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * This endpoint allows you to submit HTML forms and receive the field values and files via email.   #### Parameters The endpoint looks for special meta parameters in the form fields OR in the URL request parameters. The meta parameters can be used to specify the behaviour of the email.   You must provide at-least a `_to` email address to tell the endpoint where the form should be emailed. These can be submitted as hidden HTML input fields with the corresponding `name` attributes or as URL query parameters such as `?_to=test@example.com`  The endpoint takes all other form fields that are named and includes them in the message body of the email. Files are sent as attachments.  #### Submitting This endpoint accepts form submission via POST method. It accepts `application/x-www-form-urlencoded`, and `multipart/form-data` content-types.  #### HTML Example ```html <form    action=\"https://api.mailslurp.com/forms\"   method=\"post\" >   <input name=\"_to\" type=\"hidden\" value=\"test@example.com\"/>   <textarea name=\"feedback\"></textarea>   <button type=\"submit\">Submit</button> </form> ```  #### URL Example ```html <form    action=\"https://api.mailslurp.com/forms?_to=test@example.com\"   method=\"post\" >   <textarea name=\"feedback\"></textarea>   <button type=\"submit\">Submit</button> </form> ```    The email address is specified by a `_to` field OR is extracted from an email alias specified by a `_toAlias` field (see the alias controller for more information).  Endpoint accepts .  You can specify a content type in HTML forms using the `enctype` attribute, for instance: `<form enctype=\"multipart/form-data\">`.
         * @summary Submit a form to be parsed and sent as an email to an address determined by the form fields
         * @param {string} [emailAddress] Email address of the submitting user. Include this if you wish to record the submitters email address and reply to it later.
         * @param {string} [redirectTo] Optional URL to redirect form submitter to after submission. If not present user will see a success message.
         * @param {string} [spamCheck] Optional but recommended field that catches spammers out. Include as a hidden form field but LEAVE EMPTY. Spam-bots will usually fill every field. If the _spamCheck field is filled the form submission will be ignored.
         * @param {string} [subject] Optional subject of the email that will be sent.
         * @param {string} [successMessage] Optional success message to display if no _redirectTo present.
         * @param {string} [to] The email address that submitted form should be sent to.
         * @param {string} [otherParameters] All other parameters or fields will be accepted and attached to the sent email. This includes files and any HTML form field with a name. These fields will become the body of the email that is sent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitForm: function (emailAddress, redirectTo, spamCheck, subject, successMessage, to, otherParameters, options) {
            return exports.FormControllerApiFp(configuration).submitForm(emailAddress, redirectTo, spamCheck, subject, successMessage, to, otherParameters, options)(fetch, basePath);
        },
    };
};
exports.FormControllerApiFactory = FormControllerApiFactory;
/**
 * FormControllerApi - object-oriented interface
 * @export
 * @class FormControllerApi
 * @extends {BaseAPI}
 */
var FormControllerApi = /** @class */ (function (_super) {
    __extends(FormControllerApi, _super);
    function FormControllerApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * This endpoint allows you to submit HTML forms and receive the field values and files via email.   #### Parameters The endpoint looks for special meta parameters in the form fields OR in the URL request parameters. The meta parameters can be used to specify the behaviour of the email.   You must provide at-least a `_to` email address to tell the endpoint where the form should be emailed. These can be submitted as hidden HTML input fields with the corresponding `name` attributes or as URL query parameters such as `?_to=test@example.com`  The endpoint takes all other form fields that are named and includes them in the message body of the email. Files are sent as attachments.  #### Submitting This endpoint accepts form submission via POST method. It accepts `application/x-www-form-urlencoded`, and `multipart/form-data` content-types.  #### HTML Example ```html <form    action=\"https://api.mailslurp.com/forms\"   method=\"post\" >   <input name=\"_to\" type=\"hidden\" value=\"test@example.com\"/>   <textarea name=\"feedback\"></textarea>   <button type=\"submit\">Submit</button> </form> ```  #### URL Example ```html <form    action=\"https://api.mailslurp.com/forms?_to=test@example.com\"   method=\"post\" >   <textarea name=\"feedback\"></textarea>   <button type=\"submit\">Submit</button> </form> ```    The email address is specified by a `_to` field OR is extracted from an email alias specified by a `_toAlias` field (see the alias controller for more information).  Endpoint accepts .  You can specify a content type in HTML forms using the `enctype` attribute, for instance: `<form enctype=\"multipart/form-data\">`.
     * @summary Submit a form to be parsed and sent as an email to an address determined by the form fields
     * @param {string} [emailAddress] Email address of the submitting user. Include this if you wish to record the submitters email address and reply to it later.
     * @param {string} [redirectTo] Optional URL to redirect form submitter to after submission. If not present user will see a success message.
     * @param {string} [spamCheck] Optional but recommended field that catches spammers out. Include as a hidden form field but LEAVE EMPTY. Spam-bots will usually fill every field. If the _spamCheck field is filled the form submission will be ignored.
     * @param {string} [subject] Optional subject of the email that will be sent.
     * @param {string} [successMessage] Optional success message to display if no _redirectTo present.
     * @param {string} [to] The email address that submitted form should be sent to.
     * @param {string} [otherParameters] All other parameters or fields will be accepted and attached to the sent email. This includes files and any HTML form field with a name. These fields will become the body of the email that is sent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormControllerApi
     */
    FormControllerApi.prototype.submitForm = function (emailAddress, redirectTo, spamCheck, subject, successMessage, to, otherParameters, options) {
        return exports.FormControllerApiFp(this.configuration).submitForm(emailAddress, redirectTo, spamCheck, subject, successMessage, to, otherParameters, options)(this.fetch, this.basePath);
    };
    return FormControllerApi;
}(BaseAPI));
exports.FormControllerApi = FormControllerApi;
/**
 * GroupControllerApi - fetch parameter creator
 * @export
 */
var GroupControllerApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Add contacts to a group
         * @param {string} groupId groupId
         * @param {UpdateGroupContacts} updateGroupContactsOption updateGroupContactsOption
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addContactsToGroup: function (groupId, updateGroupContactsOption, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError('groupId', 'Required parameter groupId was null or undefined when calling addContactsToGroup.');
            }
            // verify required parameter 'updateGroupContactsOption' is not null or undefined
            if (updateGroupContactsOption === null ||
                updateGroupContactsOption === undefined) {
                throw new RequiredError('updateGroupContactsOption', 'Required parameter updateGroupContactsOption was null or undefined when calling addContactsToGroup.');
            }
            var localVarPath = "/groups/{groupId}/contacts".replace("{" + 'groupId' + "}", encodeURIComponent(String(groupId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'UpdateGroupContacts' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(updateGroupContactsOption || {})
                : updateGroupContactsOption || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a group
         * @param {CreateGroupOptions} createGroupOptions createGroupOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup: function (createGroupOptions, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'createGroupOptions' is not null or undefined
            if (createGroupOptions === null ||
                createGroupOptions === undefined) {
                throw new RequiredError('createGroupOptions', 'Required parameter createGroupOptions was null or undefined when calling createGroup.');
            }
            var localVarPath = "/groups";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'CreateGroupOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(createGroupOptions || {})
                : createGroupOptions || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete group
         * @param {string} groupId groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup: function (groupId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError('groupId', 'Required parameter groupId was null or undefined when calling deleteGroup.');
            }
            var localVarPath = "/groups/{groupId}".replace("{" + 'groupId' + "}", encodeURIComponent(String(groupId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Contact Groups in paginated format
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllGroups: function (page, size, sort, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/groups/paginated";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get group
         * @param {string} groupId groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup: function (groupId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError('groupId', 'Required parameter groupId was null or undefined when calling getGroup.');
            }
            var localVarPath = "/groups/{groupId}".replace("{" + 'groupId' + "}", encodeURIComponent(String(groupId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get group and contacts belonging to it
         * @param {string} groupId groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupWithContacts: function (groupId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError('groupId', 'Required parameter groupId was null or undefined when calling getGroupWithContacts.');
            }
            var localVarPath = "/groups/{groupId}/contacts".replace("{" + 'groupId' + "}", encodeURIComponent(String(groupId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get group and paginated contacts belonging to it
         * @param {string} groupId groupId
         * @param {number} [page] Optional page index in group contact pagination
         * @param {number} [size] Optional page size in group contact pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupWithContactsPaginated: function (groupId, page, size, sort, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError('groupId', 'Required parameter groupId was null or undefined when calling getGroupWithContactsPaginated.');
            }
            var localVarPath = "/groups/{groupId}/contacts-paginated".replace("{" + 'groupId' + "}", encodeURIComponent(String(groupId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/groups";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Remove contacts from a group
         * @param {string} groupId groupId
         * @param {UpdateGroupContacts} updateGroupContactsOption updateGroupContactsOption
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeContactsFromGroup: function (groupId, updateGroupContactsOption, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError('groupId', 'Required parameter groupId was null or undefined when calling removeContactsFromGroup.');
            }
            // verify required parameter 'updateGroupContactsOption' is not null or undefined
            if (updateGroupContactsOption === null ||
                updateGroupContactsOption === undefined) {
                throw new RequiredError('updateGroupContactsOption', 'Required parameter updateGroupContactsOption was null or undefined when calling removeContactsFromGroup.');
            }
            var localVarPath = "/groups/{groupId}/contacts".replace("{" + 'groupId' + "}", encodeURIComponent(String(groupId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'UpdateGroupContacts' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(updateGroupContactsOption || {})
                : updateGroupContactsOption || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.GroupControllerApiFetchParamCreator = GroupControllerApiFetchParamCreator;
/**
 * GroupControllerApi - functional programming interface
 * @export
 */
var GroupControllerApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Add contacts to a group
         * @param {string} groupId groupId
         * @param {UpdateGroupContacts} updateGroupContactsOption updateGroupContactsOption
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addContactsToGroup: function (groupId, updateGroupContactsOption, options) {
            var localVarFetchArgs = exports.GroupControllerApiFetchParamCreator(configuration).addContactsToGroup(groupId, updateGroupContactsOption, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Create a group
         * @param {CreateGroupOptions} createGroupOptions createGroupOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup: function (createGroupOptions, options) {
            var localVarFetchArgs = exports.GroupControllerApiFetchParamCreator(configuration).createGroup(createGroupOptions, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete group
         * @param {string} groupId groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup: function (groupId, options) {
            var localVarFetchArgs = exports.GroupControllerApiFetchParamCreator(configuration).deleteGroup(groupId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all Contact Groups in paginated format
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllGroups: function (page, size, sort, options) {
            var localVarFetchArgs = exports.GroupControllerApiFetchParamCreator(configuration).getAllGroups(page, size, sort, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get group
         * @param {string} groupId groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup: function (groupId, options) {
            var localVarFetchArgs = exports.GroupControllerApiFetchParamCreator(configuration).getGroup(groupId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get group and contacts belonging to it
         * @param {string} groupId groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupWithContacts: function (groupId, options) {
            var localVarFetchArgs = exports.GroupControllerApiFetchParamCreator(configuration).getGroupWithContacts(groupId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get group and paginated contacts belonging to it
         * @param {string} groupId groupId
         * @param {number} [page] Optional page index in group contact pagination
         * @param {number} [size] Optional page size in group contact pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupWithContactsPaginated: function (groupId, page, size, sort, options) {
            var localVarFetchArgs = exports.GroupControllerApiFetchParamCreator(configuration).getGroupWithContactsPaginated(groupId, page, size, sort, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups: function (options) {
            var localVarFetchArgs = exports.GroupControllerApiFetchParamCreator(configuration).getGroups(options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Remove contacts from a group
         * @param {string} groupId groupId
         * @param {UpdateGroupContacts} updateGroupContactsOption updateGroupContactsOption
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeContactsFromGroup: function (groupId, updateGroupContactsOption, options) {
            var localVarFetchArgs = exports.GroupControllerApiFetchParamCreator(configuration).removeContactsFromGroup(groupId, updateGroupContactsOption, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.GroupControllerApiFp = GroupControllerApiFp;
/**
 * GroupControllerApi - factory interface
 * @export
 */
var GroupControllerApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Add contacts to a group
         * @param {string} groupId groupId
         * @param {UpdateGroupContacts} updateGroupContactsOption updateGroupContactsOption
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addContactsToGroup: function (groupId, updateGroupContactsOption, options) {
            return exports.GroupControllerApiFp(configuration).addContactsToGroup(groupId, updateGroupContactsOption, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a group
         * @param {CreateGroupOptions} createGroupOptions createGroupOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup: function (createGroupOptions, options) {
            return exports.GroupControllerApiFp(configuration).createGroup(createGroupOptions, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete group
         * @param {string} groupId groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup: function (groupId, options) {
            return exports.GroupControllerApiFp(configuration).deleteGroup(groupId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get all Contact Groups in paginated format
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllGroups: function (page, size, sort, options) {
            return exports.GroupControllerApiFp(configuration).getAllGroups(page, size, sort, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get group
         * @param {string} groupId groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup: function (groupId, options) {
            return exports.GroupControllerApiFp(configuration).getGroup(groupId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get group and contacts belonging to it
         * @param {string} groupId groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupWithContacts: function (groupId, options) {
            return exports.GroupControllerApiFp(configuration).getGroupWithContacts(groupId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get group and paginated contacts belonging to it
         * @param {string} groupId groupId
         * @param {number} [page] Optional page index in group contact pagination
         * @param {number} [size] Optional page size in group contact pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupWithContactsPaginated: function (groupId, page, size, sort, options) {
            return exports.GroupControllerApiFp(configuration).getGroupWithContactsPaginated(groupId, page, size, sort, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get all groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups: function (options) {
            return exports.GroupControllerApiFp(configuration).getGroups(options)(fetch, basePath);
        },
        /**
         *
         * @summary Remove contacts from a group
         * @param {string} groupId groupId
         * @param {UpdateGroupContacts} updateGroupContactsOption updateGroupContactsOption
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeContactsFromGroup: function (groupId, updateGroupContactsOption, options) {
            return exports.GroupControllerApiFp(configuration).removeContactsFromGroup(groupId, updateGroupContactsOption, options)(fetch, basePath);
        },
    };
};
exports.GroupControllerApiFactory = GroupControllerApiFactory;
/**
 * GroupControllerApi - object-oriented interface
 * @export
 * @class GroupControllerApi
 * @extends {BaseAPI}
 */
var GroupControllerApi = /** @class */ (function (_super) {
    __extends(GroupControllerApi, _super);
    function GroupControllerApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Add contacts to a group
     * @param {string} groupId groupId
     * @param {UpdateGroupContacts} updateGroupContactsOption updateGroupContactsOption
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupControllerApi
     */
    GroupControllerApi.prototype.addContactsToGroup = function (groupId, updateGroupContactsOption, options) {
        return exports.GroupControllerApiFp(this.configuration).addContactsToGroup(groupId, updateGroupContactsOption, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Create a group
     * @param {CreateGroupOptions} createGroupOptions createGroupOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupControllerApi
     */
    GroupControllerApi.prototype.createGroup = function (createGroupOptions, options) {
        return exports.GroupControllerApiFp(this.configuration).createGroup(createGroupOptions, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Delete group
     * @param {string} groupId groupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupControllerApi
     */
    GroupControllerApi.prototype.deleteGroup = function (groupId, options) {
        return exports.GroupControllerApiFp(this.configuration).deleteGroup(groupId, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Get all Contact Groups in paginated format
     * @param {number} [page] Optional page index in inbox list pagination
     * @param {number} [size] Optional page size in inbox list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupControllerApi
     */
    GroupControllerApi.prototype.getAllGroups = function (page, size, sort, options) {
        return exports.GroupControllerApiFp(this.configuration).getAllGroups(page, size, sort, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Get group
     * @param {string} groupId groupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupControllerApi
     */
    GroupControllerApi.prototype.getGroup = function (groupId, options) {
        return exports.GroupControllerApiFp(this.configuration).getGroup(groupId, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Get group and contacts belonging to it
     * @param {string} groupId groupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupControllerApi
     */
    GroupControllerApi.prototype.getGroupWithContacts = function (groupId, options) {
        return exports.GroupControllerApiFp(this.configuration).getGroupWithContacts(groupId, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Get group and paginated contacts belonging to it
     * @param {string} groupId groupId
     * @param {number} [page] Optional page index in group contact pagination
     * @param {number} [size] Optional page size in group contact pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupControllerApi
     */
    GroupControllerApi.prototype.getGroupWithContactsPaginated = function (groupId, page, size, sort, options) {
        return exports.GroupControllerApiFp(this.configuration).getGroupWithContactsPaginated(groupId, page, size, sort, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Get all groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupControllerApi
     */
    GroupControllerApi.prototype.getGroups = function (options) {
        return exports.GroupControllerApiFp(this.configuration).getGroups(options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Remove contacts from a group
     * @param {string} groupId groupId
     * @param {UpdateGroupContacts} updateGroupContactsOption updateGroupContactsOption
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupControllerApi
     */
    GroupControllerApi.prototype.removeContactsFromGroup = function (groupId, updateGroupContactsOption, options) {
        return exports.GroupControllerApiFp(this.configuration).removeContactsFromGroup(groupId, updateGroupContactsOption, options)(this.fetch, this.basePath);
    };
    return GroupControllerApi;
}(BaseAPI));
exports.GroupControllerApi = GroupControllerApi;
/**
 * InboxControllerApi - fetch parameter creator
 * @export
 */
var InboxControllerApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Create a new inbox and with a randomized email address to send and receive from. Pass emailAddress parameter if you wish to use a specific email address. Creating an inbox is required before sending or receiving emails. If writing tests it is recommended that you create a new inbox during each test method so that it is unique and empty.
         * @summary Create an inbox email address. An inbox has a real email address and can send and receive emails.
         * @param {boolean} [allowTeamAccess] Grant team access to this inbox and the emails that belong to it for team members of your organization.
         * @param {string} [description] Optional description of the inbox for labelling purposes. Is shown in the dashboard and can be used with
         * @param {string} [emailAddress] A custom email address to use with the inbox. Defaults to null. When null MailSlurp will assign a random email address to the inbox such as &#x60;123@mailslurp.com&#x60;. If you use the &#x60;useDomainPool&#x60; option when the email address is null it will generate an email address with a more varied domain ending such as &#x60;123@mailslurp.info&#x60; or &#x60;123@mailslurp.biz&#x60;. When a custom email address is provided the address is split into a domain and the domain is queried against your user. If you have created the domain in the MailSlurp dashboard and verified it you can use any email address that ends with the domain. Send an email to this address and the inbox will receive and store it for you. To retrieve the email use the Inbox and Email Controller endpoints with the inbox ID.
         * @param {Date} [expiresAt] Optional inbox expiration date. If null then this inbox is permanent and the emails in it won&#39;t be deleted. If an expiration date is provided or is required by your plan the inbox will be closed when the expiration time is reached. Expired inboxes still contain their emails but can no longer send or receive emails. An ExpiredInboxRecord is created when an inbox and the email address and inbox ID are recorded. The expiresAt property is a timestamp string in ISO DateTime Format yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSXXX.
         * @param {number} [expiresIn] Number of milliseconds that inbox should exist for
         * @param {boolean} [favourite] Is the inbox favorited. Favouriting inboxes is typically done in the dashboard for quick access or filtering
         * @param {string} [name] Optional name of the inbox. Displayed in the dashboard for easier search
         * @param {Array<string>} [tags] Tags that inbox has been tagged with. Tags can be added to inboxes to group different inboxes within an account. You can also search for inboxes by tag in the dashboard UI.
         * @param {boolean} [useDomainPool] Use the MailSlurp domain name pool with this inbox when creating the email address. Defaults to null. If enabled the inbox will be an email address with a domain randomly chosen from a list of the MailSlurp domains. This is useful when the default &#x60;@mailslurp.com&#x60; email addresses used with inboxes are blocked or considered spam by a provider or receiving service. When domain pool is enabled an email address will be generated ending in &#x60;@mailslurp.{world,info,xyz,...}&#x60; . This means a TLD is randomly selecting from a list of &#x60;.biz&#x60;, &#x60;.info&#x60;, &#x60;.xyz&#x60; etc to add variance to the generated email addresses. When null or false MailSlurp uses the default behavior of &#x60;@mailslurp.com&#x60; or custom email address provided by the emailAddress field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInbox: function (allowTeamAccess, description, emailAddress, expiresAt, expiresIn, favourite, name, tags, useDomainPool, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/inboxes";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (allowTeamAccess !== undefined) {
                localVarQueryParameter['allowTeamAccess'] = allowTeamAccess;
            }
            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }
            if (emailAddress !== undefined) {
                localVarQueryParameter['emailAddress'] = emailAddress;
            }
            if (expiresAt !== undefined) {
                localVarQueryParameter['expiresAt'] = expiresAt.toISOString();
            }
            if (expiresIn !== undefined) {
                localVarQueryParameter['expiresIn'] = expiresIn;
            }
            if (favourite !== undefined) {
                localVarQueryParameter['favourite'] = favourite;
            }
            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }
            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }
            if (useDomainPool !== undefined) {
                localVarQueryParameter['useDomainPool'] = useDomainPool;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create an inbox with default options. Uses MailSlurp domain pool address and is private.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInboxWithDefaults: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/inboxes/withDefaults";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Additional endpoint that allows inbox creation with request body options. Can be more flexible that other methods for some clients.
         * @summary Create an inbox with options. Extended options for inbox creation.
         * @param {CreateInboxDto} createInboxDto createInboxDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInboxWithOptions: function (createInboxDto, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'createInboxDto' is not null or undefined
            if (createInboxDto === null || createInboxDto === undefined) {
                throw new RequiredError('createInboxDto', 'Required parameter createInboxDto was null or undefined when calling createInboxWithOptions.');
            }
            var localVarPath = "/inboxes/withOptions";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'CreateInboxDto' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(createInboxDto || {})
                : createInboxDto || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently delete all inboxes and associated email addresses. This will also delete all emails within the inboxes. Be careful as inboxes cannot be recovered once deleted. Note: deleting inboxes will not impact your usage limits. Monthly inbox creation limits are based on how many inboxes were created in the last 30 days, not how many inboxes you currently have.
         * @summary Delete all inboxes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllInboxes: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/inboxes";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently delete an inbox and associated email address as well as all emails within the given inbox. This action cannot be undone. Note: deleting an inbox will not affect your account usage. Monthly inbox usage is based on how many inboxes you create within 30 days, not how many exist at time of request.
         * @summary Delete inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInbox: function (inboxId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError('inboxId', 'Required parameter inboxId was null or undefined when calling deleteInbox.');
            }
            var localVarPath = "/inboxes/{inboxId}".replace("{" + 'inboxId' + "}", encodeURIComponent(String(inboxId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List inboxes in paginated form. The results are available on the `content` property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). You Can also filter by whether an inbox is favorited or use email address pattern. This method is the recommended way to query inboxes. The alternative `getInboxes` method returns a full list of inboxes but is limited to 100 results. Results do not include team access inboxes by default. Use organization method to list team inboxes or set `teamAccess` to true.
         * @summary List All Inboxes Paginated
         * @param {boolean} [favourite] Optionally filter results for favourites only
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {string} [search] Optionally filter by search words partial matching ID, tags, name, and email address
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {string} [tag] Optionally filter by tags. Will return inboxes that include given tags
         * @param {boolean} [teamAccess] Optionally filter by team access. Defaults to false so organization inboxes are not included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllInboxes: function (favourite, page, search, size, sort, tag, teamAccess, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/inboxes/paginated";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (favourite !== undefined) {
                localVarQueryParameter['favourite'] = favourite;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }
            if (teamAccess !== undefined) {
                localVarQueryParameter['teamAccess'] = teamAccess;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List emails that an inbox has received. Only emails that are sent to the inbox's email address will appear in the inbox. It may take several seconds for any email you send to an inbox's email address to appear in the inbox. To make this endpoint wait for a minimum number of emails use the `minCount` parameter. The server will retry the inbox database until the `minCount` is satisfied or the `retryTimeout` is reached
         * @summary Get emails in an Inbox. This method is not idempotent as it allows retries and waits if you want certain conditions to be met before returning. For simple listing and sorting of known emails use the email controller instead.
         * @param {string} inboxId Id of inbox that emails belongs to
         * @param {number} [limit] Limit the result set, ordered by received date time sort direction. Maximum 100. For more listing options see the email controller
         * @param {number} [minCount] Minimum acceptable email count. Will cause request to hang (and retry) until minCount is satisfied or retryTimeout is reached.
         * @param {number} [retryTimeout] Maximum milliseconds to spend retrying inbox database until minCount emails are returned
         * @param {Date} [since] Exclude emails received before this ISO 8601 date time
         * @param {number} [size] Alias for limit. Assessed first before assessing any passed limit.
         * @param {'ASC' | 'DESC'} [sort] Sort the results by received date and direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmails: function (inboxId, limit, minCount, retryTimeout, since, size, sort, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError('inboxId', 'Required parameter inboxId was null or undefined when calling getEmails.');
            }
            var localVarPath = "/inboxes/{inboxId}/emails".replace("{" + 'inboxId' + "}", encodeURIComponent(String(inboxId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (minCount !== undefined) {
                localVarQueryParameter['minCount'] = minCount;
            }
            if (retryTimeout !== undefined) {
                localVarQueryParameter['retryTimeout'] = retryTimeout;
            }
            if (since !== undefined) {
                localVarQueryParameter['since'] = since.toISOString();
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an inbox's properties, including its email address and ID.
         * @summary Get Inbox. Returns properties of an inbox.
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInbox: function (inboxId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError('inboxId', 'Required parameter inboxId was null or undefined when calling getInbox.');
            }
            var localVarPath = "/inboxes/{inboxId}".replace("{" + 'inboxId' + "}", encodeURIComponent(String(inboxId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a paginated list of emails in an inbox. Does not hold connections open.
         * @summary Get inbox emails paginated
         * @param {string} inboxId Id of inbox that emails belongs to
         * @param {number} [page] Optional page index in inbox emails list pagination
         * @param {number} [size] Optional page size in inbox emails list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxEmailsPaginated: function (inboxId, page, size, sort, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError('inboxId', 'Required parameter inboxId was null or undefined when calling getInboxEmailsPaginated.');
            }
            var localVarPath = "/inboxes/{inboxId}/emails/paginated".replace("{" + 'inboxId' + "}", encodeURIComponent(String(inboxId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an inbox's sent email receipts. Call individual sent email endpoints for more details. Note for privacy reasons the full body of sent emails is never stored. An MD5 hash hex is available for comparison instead.
         * @summary Get Inbox Sent Emails
         * @param {string} inboxId inboxId
         * @param {number} [page] Optional page index in inbox sent email list pagination
         * @param {number} [size] Optional page size in inbox sent email list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxSentEmails: function (inboxId, page, size, sort, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError('inboxId', 'Required parameter inboxId was null or undefined when calling getInboxSentEmails.');
            }
            var localVarPath = "/inboxes/{inboxId}/sent".replace("{" + 'inboxId' + "}", encodeURIComponent(String(inboxId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all inbox tags
         * @summary Get inbox tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxTags: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/inboxes/tags";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the inboxes you have created. Note use of the more advanced `getAllEmails` is recommended. You can provide a limit and sort parameter.
         * @summary List Inboxes and email eddresses
         * @param {number} [size] Optional result size limit. Note an automatic limit of 100 results is applied. See the paginated &#x60;getAllEmails&#x60; for larger queries.
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxes: function (size, sort, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/inboxes";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List organization inboxes in paginated form. These are inboxes created with `allowTeamAccess` flag enabled. Organization inboxes are `readOnly` for non-admin users. The results are available on the `content` property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time).
         * @summary List Organization Inboxes Paginated
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationInboxes: function (page, size, sort, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/inboxes/organization";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send an email from an inbox's email address.  The request body should contain the `SendEmailOptions` that include recipients, attachments, body etc. See `SendEmailOptions` for all available properties. Note the `inboxId` refers to the inbox's id not the inbox's email address. See https://www.mailslurp.com/guides/ for more information on how to send emails. This method does not return a sent email entity due to legacy reasons. To send and get a sent email as returned response use the sister method `sendEmailAndConfirm`.
         * @summary Send Email
         * @param {string} inboxId ID of the inbox you want to send the email from
         * @param {SendEmailOptions} [sendEmailOptions] Options for the email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmail: function (inboxId, sendEmailOptions, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError('inboxId', 'Required parameter inboxId was null or undefined when calling sendEmail.');
            }
            var localVarPath = "/inboxes/{inboxId}".replace("{" + 'inboxId' + "}", encodeURIComponent(String(inboxId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'SendEmailOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(sendEmailOptions || {})
                : sendEmailOptions || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sister method for standard `sendEmail` method with the benefit of returning a `SentEmail` entity confirming the successful sending of the email with a link to the sent object created for it.
         * @summary Send email and return sent confirmation
         * @param {string} inboxId ID of the inbox you want to send the email from
         * @param {SendEmailOptions} [sendEmailOptions] Options for the email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailAndConfirm: function (inboxId, sendEmailOptions, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError('inboxId', 'Required parameter inboxId was null or undefined when calling sendEmailAndConfirm.');
            }
            var localVarPath = "/inboxes/{inboxId}/confirm".replace("{" + 'inboxId' + "}", encodeURIComponent(String(inboxId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'SendEmailOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(sendEmailOptions || {})
                : sendEmailOptions || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set and return new favourite state for an inbox
         * @summary Set inbox favourited state
         * @param {string} inboxId inboxId
         * @param {SetInboxFavouritedOptions} setInboxFavouritedOptions setInboxFavouritedOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setInboxFavourited: function (inboxId, setInboxFavouritedOptions, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError('inboxId', 'Required parameter inboxId was null or undefined when calling setInboxFavourited.');
            }
            // verify required parameter 'setInboxFavouritedOptions' is not null or undefined
            if (setInboxFavouritedOptions === null ||
                setInboxFavouritedOptions === undefined) {
                throw new RequiredError('setInboxFavouritedOptions', 'Required parameter setInboxFavouritedOptions was null or undefined when calling setInboxFavourited.');
            }
            var localVarPath = "/inboxes/{inboxId}/favourite".replace("{" + 'inboxId' + "}", encodeURIComponent(String(inboxId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'SetInboxFavouritedOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(setInboxFavouritedOptions || {})
                : setInboxFavouritedOptions || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update editable fields on an inbox
         * @summary Update Inbox. Change name and description. Email address is not editable.
         * @param {string} inboxId inboxId
         * @param {UpdateInboxOptions} updateInboxOptions updateInboxOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInbox: function (inboxId, updateInboxOptions, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError('inboxId', 'Required parameter inboxId was null or undefined when calling updateInbox.');
            }
            // verify required parameter 'updateInboxOptions' is not null or undefined
            if (updateInboxOptions === null ||
                updateInboxOptions === undefined) {
                throw new RequiredError('updateInboxOptions', 'Required parameter updateInboxOptions was null or undefined when calling updateInbox.');
            }
            var localVarPath = "/inboxes/{inboxId}".replace("{" + 'inboxId' + "}", encodeURIComponent(String(inboxId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'UpdateInboxOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(updateInboxOptions || {})
                : updateInboxOptions || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.InboxControllerApiFetchParamCreator = InboxControllerApiFetchParamCreator;
/**
 * InboxControllerApi - functional programming interface
 * @export
 */
var InboxControllerApiFp = function (configuration) {
    return {
        /**
         * Create a new inbox and with a randomized email address to send and receive from. Pass emailAddress parameter if you wish to use a specific email address. Creating an inbox is required before sending or receiving emails. If writing tests it is recommended that you create a new inbox during each test method so that it is unique and empty.
         * @summary Create an inbox email address. An inbox has a real email address and can send and receive emails.
         * @param {boolean} [allowTeamAccess] Grant team access to this inbox and the emails that belong to it for team members of your organization.
         * @param {string} [description] Optional description of the inbox for labelling purposes. Is shown in the dashboard and can be used with
         * @param {string} [emailAddress] A custom email address to use with the inbox. Defaults to null. When null MailSlurp will assign a random email address to the inbox such as &#x60;123@mailslurp.com&#x60;. If you use the &#x60;useDomainPool&#x60; option when the email address is null it will generate an email address with a more varied domain ending such as &#x60;123@mailslurp.info&#x60; or &#x60;123@mailslurp.biz&#x60;. When a custom email address is provided the address is split into a domain and the domain is queried against your user. If you have created the domain in the MailSlurp dashboard and verified it you can use any email address that ends with the domain. Send an email to this address and the inbox will receive and store it for you. To retrieve the email use the Inbox and Email Controller endpoints with the inbox ID.
         * @param {Date} [expiresAt] Optional inbox expiration date. If null then this inbox is permanent and the emails in it won&#39;t be deleted. If an expiration date is provided or is required by your plan the inbox will be closed when the expiration time is reached. Expired inboxes still contain their emails but can no longer send or receive emails. An ExpiredInboxRecord is created when an inbox and the email address and inbox ID are recorded. The expiresAt property is a timestamp string in ISO DateTime Format yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSXXX.
         * @param {number} [expiresIn] Number of milliseconds that inbox should exist for
         * @param {boolean} [favourite] Is the inbox favorited. Favouriting inboxes is typically done in the dashboard for quick access or filtering
         * @param {string} [name] Optional name of the inbox. Displayed in the dashboard for easier search
         * @param {Array<string>} [tags] Tags that inbox has been tagged with. Tags can be added to inboxes to group different inboxes within an account. You can also search for inboxes by tag in the dashboard UI.
         * @param {boolean} [useDomainPool] Use the MailSlurp domain name pool with this inbox when creating the email address. Defaults to null. If enabled the inbox will be an email address with a domain randomly chosen from a list of the MailSlurp domains. This is useful when the default &#x60;@mailslurp.com&#x60; email addresses used with inboxes are blocked or considered spam by a provider or receiving service. When domain pool is enabled an email address will be generated ending in &#x60;@mailslurp.{world,info,xyz,...}&#x60; . This means a TLD is randomly selecting from a list of &#x60;.biz&#x60;, &#x60;.info&#x60;, &#x60;.xyz&#x60; etc to add variance to the generated email addresses. When null or false MailSlurp uses the default behavior of &#x60;@mailslurp.com&#x60; or custom email address provided by the emailAddress field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInbox: function (allowTeamAccess, description, emailAddress, expiresAt, expiresIn, favourite, name, tags, useDomainPool, options) {
            var localVarFetchArgs = exports.InboxControllerApiFetchParamCreator(configuration).createInbox(allowTeamAccess, description, emailAddress, expiresAt, expiresIn, favourite, name, tags, useDomainPool, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Create an inbox with default options. Uses MailSlurp domain pool address and is private.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInboxWithDefaults: function (options) {
            var localVarFetchArgs = exports.InboxControllerApiFetchParamCreator(configuration).createInboxWithDefaults(options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Additional endpoint that allows inbox creation with request body options. Can be more flexible that other methods for some clients.
         * @summary Create an inbox with options. Extended options for inbox creation.
         * @param {CreateInboxDto} createInboxDto createInboxDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInboxWithOptions: function (createInboxDto, options) {
            var localVarFetchArgs = exports.InboxControllerApiFetchParamCreator(configuration).createInboxWithOptions(createInboxDto, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Permanently delete all inboxes and associated email addresses. This will also delete all emails within the inboxes. Be careful as inboxes cannot be recovered once deleted. Note: deleting inboxes will not impact your usage limits. Monthly inbox creation limits are based on how many inboxes were created in the last 30 days, not how many inboxes you currently have.
         * @summary Delete all inboxes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllInboxes: function (options) {
            var localVarFetchArgs = exports.InboxControllerApiFetchParamCreator(configuration).deleteAllInboxes(options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Permanently delete an inbox and associated email address as well as all emails within the given inbox. This action cannot be undone. Note: deleting an inbox will not affect your account usage. Monthly inbox usage is based on how many inboxes you create within 30 days, not how many exist at time of request.
         * @summary Delete inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInbox: function (inboxId, options) {
            var localVarFetchArgs = exports.InboxControllerApiFetchParamCreator(configuration).deleteInbox(inboxId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List inboxes in paginated form. The results are available on the `content` property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). You Can also filter by whether an inbox is favorited or use email address pattern. This method is the recommended way to query inboxes. The alternative `getInboxes` method returns a full list of inboxes but is limited to 100 results. Results do not include team access inboxes by default. Use organization method to list team inboxes or set `teamAccess` to true.
         * @summary List All Inboxes Paginated
         * @param {boolean} [favourite] Optionally filter results for favourites only
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {string} [search] Optionally filter by search words partial matching ID, tags, name, and email address
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {string} [tag] Optionally filter by tags. Will return inboxes that include given tags
         * @param {boolean} [teamAccess] Optionally filter by team access. Defaults to false so organization inboxes are not included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllInboxes: function (favourite, page, search, size, sort, tag, teamAccess, options) {
            var localVarFetchArgs = exports.InboxControllerApiFetchParamCreator(configuration).getAllInboxes(favourite, page, search, size, sort, tag, teamAccess, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List emails that an inbox has received. Only emails that are sent to the inbox's email address will appear in the inbox. It may take several seconds for any email you send to an inbox's email address to appear in the inbox. To make this endpoint wait for a minimum number of emails use the `minCount` parameter. The server will retry the inbox database until the `minCount` is satisfied or the `retryTimeout` is reached
         * @summary Get emails in an Inbox. This method is not idempotent as it allows retries and waits if you want certain conditions to be met before returning. For simple listing and sorting of known emails use the email controller instead.
         * @param {string} inboxId Id of inbox that emails belongs to
         * @param {number} [limit] Limit the result set, ordered by received date time sort direction. Maximum 100. For more listing options see the email controller
         * @param {number} [minCount] Minimum acceptable email count. Will cause request to hang (and retry) until minCount is satisfied or retryTimeout is reached.
         * @param {number} [retryTimeout] Maximum milliseconds to spend retrying inbox database until minCount emails are returned
         * @param {Date} [since] Exclude emails received before this ISO 8601 date time
         * @param {number} [size] Alias for limit. Assessed first before assessing any passed limit.
         * @param {'ASC' | 'DESC'} [sort] Sort the results by received date and direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmails: function (inboxId, limit, minCount, retryTimeout, since, size, sort, options) {
            var localVarFetchArgs = exports.InboxControllerApiFetchParamCreator(configuration).getEmails(inboxId, limit, minCount, retryTimeout, since, size, sort, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns an inbox's properties, including its email address and ID.
         * @summary Get Inbox. Returns properties of an inbox.
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInbox: function (inboxId, options) {
            var localVarFetchArgs = exports.InboxControllerApiFetchParamCreator(configuration).getInbox(inboxId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a paginated list of emails in an inbox. Does not hold connections open.
         * @summary Get inbox emails paginated
         * @param {string} inboxId Id of inbox that emails belongs to
         * @param {number} [page] Optional page index in inbox emails list pagination
         * @param {number} [size] Optional page size in inbox emails list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxEmailsPaginated: function (inboxId, page, size, sort, options) {
            var localVarFetchArgs = exports.InboxControllerApiFetchParamCreator(configuration).getInboxEmailsPaginated(inboxId, page, size, sort, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns an inbox's sent email receipts. Call individual sent email endpoints for more details. Note for privacy reasons the full body of sent emails is never stored. An MD5 hash hex is available for comparison instead.
         * @summary Get Inbox Sent Emails
         * @param {string} inboxId inboxId
         * @param {number} [page] Optional page index in inbox sent email list pagination
         * @param {number} [size] Optional page size in inbox sent email list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxSentEmails: function (inboxId, page, size, sort, options) {
            var localVarFetchArgs = exports.InboxControllerApiFetchParamCreator(configuration).getInboxSentEmails(inboxId, page, size, sort, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all inbox tags
         * @summary Get inbox tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxTags: function (options) {
            var localVarFetchArgs = exports.InboxControllerApiFetchParamCreator(configuration).getInboxTags(options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List the inboxes you have created. Note use of the more advanced `getAllEmails` is recommended. You can provide a limit and sort parameter.
         * @summary List Inboxes and email eddresses
         * @param {number} [size] Optional result size limit. Note an automatic limit of 100 results is applied. See the paginated &#x60;getAllEmails&#x60; for larger queries.
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxes: function (size, sort, options) {
            var localVarFetchArgs = exports.InboxControllerApiFetchParamCreator(configuration).getInboxes(size, sort, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List organization inboxes in paginated form. These are inboxes created with `allowTeamAccess` flag enabled. Organization inboxes are `readOnly` for non-admin users. The results are available on the `content` property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time).
         * @summary List Organization Inboxes Paginated
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationInboxes: function (page, size, sort, options) {
            var localVarFetchArgs = exports.InboxControllerApiFetchParamCreator(configuration).getOrganizationInboxes(page, size, sort, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Send an email from an inbox's email address.  The request body should contain the `SendEmailOptions` that include recipients, attachments, body etc. See `SendEmailOptions` for all available properties. Note the `inboxId` refers to the inbox's id not the inbox's email address. See https://www.mailslurp.com/guides/ for more information on how to send emails. This method does not return a sent email entity due to legacy reasons. To send and get a sent email as returned response use the sister method `sendEmailAndConfirm`.
         * @summary Send Email
         * @param {string} inboxId ID of the inbox you want to send the email from
         * @param {SendEmailOptions} [sendEmailOptions] Options for the email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmail: function (inboxId, sendEmailOptions, options) {
            var localVarFetchArgs = exports.InboxControllerApiFetchParamCreator(configuration).sendEmail(inboxId, sendEmailOptions, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Sister method for standard `sendEmail` method with the benefit of returning a `SentEmail` entity confirming the successful sending of the email with a link to the sent object created for it.
         * @summary Send email and return sent confirmation
         * @param {string} inboxId ID of the inbox you want to send the email from
         * @param {SendEmailOptions} [sendEmailOptions] Options for the email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailAndConfirm: function (inboxId, sendEmailOptions, options) {
            var localVarFetchArgs = exports.InboxControllerApiFetchParamCreator(configuration).sendEmailAndConfirm(inboxId, sendEmailOptions, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Set and return new favourite state for an inbox
         * @summary Set inbox favourited state
         * @param {string} inboxId inboxId
         * @param {SetInboxFavouritedOptions} setInboxFavouritedOptions setInboxFavouritedOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setInboxFavourited: function (inboxId, setInboxFavouritedOptions, options) {
            var localVarFetchArgs = exports.InboxControllerApiFetchParamCreator(configuration).setInboxFavourited(inboxId, setInboxFavouritedOptions, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update editable fields on an inbox
         * @summary Update Inbox. Change name and description. Email address is not editable.
         * @param {string} inboxId inboxId
         * @param {UpdateInboxOptions} updateInboxOptions updateInboxOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInbox: function (inboxId, updateInboxOptions, options) {
            var localVarFetchArgs = exports.InboxControllerApiFetchParamCreator(configuration).updateInbox(inboxId, updateInboxOptions, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.InboxControllerApiFp = InboxControllerApiFp;
/**
 * InboxControllerApi - factory interface
 * @export
 */
var InboxControllerApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Create a new inbox and with a randomized email address to send and receive from. Pass emailAddress parameter if you wish to use a specific email address. Creating an inbox is required before sending or receiving emails. If writing tests it is recommended that you create a new inbox during each test method so that it is unique and empty.
         * @summary Create an inbox email address. An inbox has a real email address and can send and receive emails.
         * @param {boolean} [allowTeamAccess] Grant team access to this inbox and the emails that belong to it for team members of your organization.
         * @param {string} [description] Optional description of the inbox for labelling purposes. Is shown in the dashboard and can be used with
         * @param {string} [emailAddress] A custom email address to use with the inbox. Defaults to null. When null MailSlurp will assign a random email address to the inbox such as &#x60;123@mailslurp.com&#x60;. If you use the &#x60;useDomainPool&#x60; option when the email address is null it will generate an email address with a more varied domain ending such as &#x60;123@mailslurp.info&#x60; or &#x60;123@mailslurp.biz&#x60;. When a custom email address is provided the address is split into a domain and the domain is queried against your user. If you have created the domain in the MailSlurp dashboard and verified it you can use any email address that ends with the domain. Send an email to this address and the inbox will receive and store it for you. To retrieve the email use the Inbox and Email Controller endpoints with the inbox ID.
         * @param {Date} [expiresAt] Optional inbox expiration date. If null then this inbox is permanent and the emails in it won&#39;t be deleted. If an expiration date is provided or is required by your plan the inbox will be closed when the expiration time is reached. Expired inboxes still contain their emails but can no longer send or receive emails. An ExpiredInboxRecord is created when an inbox and the email address and inbox ID are recorded. The expiresAt property is a timestamp string in ISO DateTime Format yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSXXX.
         * @param {number} [expiresIn] Number of milliseconds that inbox should exist for
         * @param {boolean} [favourite] Is the inbox favorited. Favouriting inboxes is typically done in the dashboard for quick access or filtering
         * @param {string} [name] Optional name of the inbox. Displayed in the dashboard for easier search
         * @param {Array<string>} [tags] Tags that inbox has been tagged with. Tags can be added to inboxes to group different inboxes within an account. You can also search for inboxes by tag in the dashboard UI.
         * @param {boolean} [useDomainPool] Use the MailSlurp domain name pool with this inbox when creating the email address. Defaults to null. If enabled the inbox will be an email address with a domain randomly chosen from a list of the MailSlurp domains. This is useful when the default &#x60;@mailslurp.com&#x60; email addresses used with inboxes are blocked or considered spam by a provider or receiving service. When domain pool is enabled an email address will be generated ending in &#x60;@mailslurp.{world,info,xyz,...}&#x60; . This means a TLD is randomly selecting from a list of &#x60;.biz&#x60;, &#x60;.info&#x60;, &#x60;.xyz&#x60; etc to add variance to the generated email addresses. When null or false MailSlurp uses the default behavior of &#x60;@mailslurp.com&#x60; or custom email address provided by the emailAddress field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInbox: function (allowTeamAccess, description, emailAddress, expiresAt, expiresIn, favourite, name, tags, useDomainPool, options) {
            return exports.InboxControllerApiFp(configuration).createInbox(allowTeamAccess, description, emailAddress, expiresAt, expiresIn, favourite, name, tags, useDomainPool, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create an inbox with default options. Uses MailSlurp domain pool address and is private.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInboxWithDefaults: function (options) {
            return exports.InboxControllerApiFp(configuration).createInboxWithDefaults(options)(fetch, basePath);
        },
        /**
         * Additional endpoint that allows inbox creation with request body options. Can be more flexible that other methods for some clients.
         * @summary Create an inbox with options. Extended options for inbox creation.
         * @param {CreateInboxDto} createInboxDto createInboxDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInboxWithOptions: function (createInboxDto, options) {
            return exports.InboxControllerApiFp(configuration).createInboxWithOptions(createInboxDto, options)(fetch, basePath);
        },
        /**
         * Permanently delete all inboxes and associated email addresses. This will also delete all emails within the inboxes. Be careful as inboxes cannot be recovered once deleted. Note: deleting inboxes will not impact your usage limits. Monthly inbox creation limits are based on how many inboxes were created in the last 30 days, not how many inboxes you currently have.
         * @summary Delete all inboxes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllInboxes: function (options) {
            return exports.InboxControllerApiFp(configuration).deleteAllInboxes(options)(fetch, basePath);
        },
        /**
         * Permanently delete an inbox and associated email address as well as all emails within the given inbox. This action cannot be undone. Note: deleting an inbox will not affect your account usage. Monthly inbox usage is based on how many inboxes you create within 30 days, not how many exist at time of request.
         * @summary Delete inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInbox: function (inboxId, options) {
            return exports.InboxControllerApiFp(configuration).deleteInbox(inboxId, options)(fetch, basePath);
        },
        /**
         * List inboxes in paginated form. The results are available on the `content` property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). You Can also filter by whether an inbox is favorited or use email address pattern. This method is the recommended way to query inboxes. The alternative `getInboxes` method returns a full list of inboxes but is limited to 100 results. Results do not include team access inboxes by default. Use organization method to list team inboxes or set `teamAccess` to true.
         * @summary List All Inboxes Paginated
         * @param {boolean} [favourite] Optionally filter results for favourites only
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {string} [search] Optionally filter by search words partial matching ID, tags, name, and email address
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {string} [tag] Optionally filter by tags. Will return inboxes that include given tags
         * @param {boolean} [teamAccess] Optionally filter by team access. Defaults to false so organization inboxes are not included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllInboxes: function (favourite, page, search, size, sort, tag, teamAccess, options) {
            return exports.InboxControllerApiFp(configuration).getAllInboxes(favourite, page, search, size, sort, tag, teamAccess, options)(fetch, basePath);
        },
        /**
         * List emails that an inbox has received. Only emails that are sent to the inbox's email address will appear in the inbox. It may take several seconds for any email you send to an inbox's email address to appear in the inbox. To make this endpoint wait for a minimum number of emails use the `minCount` parameter. The server will retry the inbox database until the `minCount` is satisfied or the `retryTimeout` is reached
         * @summary Get emails in an Inbox. This method is not idempotent as it allows retries and waits if you want certain conditions to be met before returning. For simple listing and sorting of known emails use the email controller instead.
         * @param {string} inboxId Id of inbox that emails belongs to
         * @param {number} [limit] Limit the result set, ordered by received date time sort direction. Maximum 100. For more listing options see the email controller
         * @param {number} [minCount] Minimum acceptable email count. Will cause request to hang (and retry) until minCount is satisfied or retryTimeout is reached.
         * @param {number} [retryTimeout] Maximum milliseconds to spend retrying inbox database until minCount emails are returned
         * @param {Date} [since] Exclude emails received before this ISO 8601 date time
         * @param {number} [size] Alias for limit. Assessed first before assessing any passed limit.
         * @param {'ASC' | 'DESC'} [sort] Sort the results by received date and direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmails: function (inboxId, limit, minCount, retryTimeout, since, size, sort, options) {
            return exports.InboxControllerApiFp(configuration).getEmails(inboxId, limit, minCount, retryTimeout, since, size, sort, options)(fetch, basePath);
        },
        /**
         * Returns an inbox's properties, including its email address and ID.
         * @summary Get Inbox. Returns properties of an inbox.
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInbox: function (inboxId, options) {
            return exports.InboxControllerApiFp(configuration).getInbox(inboxId, options)(fetch, basePath);
        },
        /**
         * Get a paginated list of emails in an inbox. Does not hold connections open.
         * @summary Get inbox emails paginated
         * @param {string} inboxId Id of inbox that emails belongs to
         * @param {number} [page] Optional page index in inbox emails list pagination
         * @param {number} [size] Optional page size in inbox emails list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxEmailsPaginated: function (inboxId, page, size, sort, options) {
            return exports.InboxControllerApiFp(configuration).getInboxEmailsPaginated(inboxId, page, size, sort, options)(fetch, basePath);
        },
        /**
         * Returns an inbox's sent email receipts. Call individual sent email endpoints for more details. Note for privacy reasons the full body of sent emails is never stored. An MD5 hash hex is available for comparison instead.
         * @summary Get Inbox Sent Emails
         * @param {string} inboxId inboxId
         * @param {number} [page] Optional page index in inbox sent email list pagination
         * @param {number} [size] Optional page size in inbox sent email list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxSentEmails: function (inboxId, page, size, sort, options) {
            return exports.InboxControllerApiFp(configuration).getInboxSentEmails(inboxId, page, size, sort, options)(fetch, basePath);
        },
        /**
         * Get all inbox tags
         * @summary Get inbox tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxTags: function (options) {
            return exports.InboxControllerApiFp(configuration).getInboxTags(options)(fetch, basePath);
        },
        /**
         * List the inboxes you have created. Note use of the more advanced `getAllEmails` is recommended. You can provide a limit and sort parameter.
         * @summary List Inboxes and email eddresses
         * @param {number} [size] Optional result size limit. Note an automatic limit of 100 results is applied. See the paginated &#x60;getAllEmails&#x60; for larger queries.
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxes: function (size, sort, options) {
            return exports.InboxControllerApiFp(configuration).getInboxes(size, sort, options)(fetch, basePath);
        },
        /**
         * List organization inboxes in paginated form. These are inboxes created with `allowTeamAccess` flag enabled. Organization inboxes are `readOnly` for non-admin users. The results are available on the `content` property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time).
         * @summary List Organization Inboxes Paginated
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationInboxes: function (page, size, sort, options) {
            return exports.InboxControllerApiFp(configuration).getOrganizationInboxes(page, size, sort, options)(fetch, basePath);
        },
        /**
         * Send an email from an inbox's email address.  The request body should contain the `SendEmailOptions` that include recipients, attachments, body etc. See `SendEmailOptions` for all available properties. Note the `inboxId` refers to the inbox's id not the inbox's email address. See https://www.mailslurp.com/guides/ for more information on how to send emails. This method does not return a sent email entity due to legacy reasons. To send and get a sent email as returned response use the sister method `sendEmailAndConfirm`.
         * @summary Send Email
         * @param {string} inboxId ID of the inbox you want to send the email from
         * @param {SendEmailOptions} [sendEmailOptions] Options for the email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmail: function (inboxId, sendEmailOptions, options) {
            return exports.InboxControllerApiFp(configuration).sendEmail(inboxId, sendEmailOptions, options)(fetch, basePath);
        },
        /**
         * Sister method for standard `sendEmail` method with the benefit of returning a `SentEmail` entity confirming the successful sending of the email with a link to the sent object created for it.
         * @summary Send email and return sent confirmation
         * @param {string} inboxId ID of the inbox you want to send the email from
         * @param {SendEmailOptions} [sendEmailOptions] Options for the email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailAndConfirm: function (inboxId, sendEmailOptions, options) {
            return exports.InboxControllerApiFp(configuration).sendEmailAndConfirm(inboxId, sendEmailOptions, options)(fetch, basePath);
        },
        /**
         * Set and return new favourite state for an inbox
         * @summary Set inbox favourited state
         * @param {string} inboxId inboxId
         * @param {SetInboxFavouritedOptions} setInboxFavouritedOptions setInboxFavouritedOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setInboxFavourited: function (inboxId, setInboxFavouritedOptions, options) {
            return exports.InboxControllerApiFp(configuration).setInboxFavourited(inboxId, setInboxFavouritedOptions, options)(fetch, basePath);
        },
        /**
         * Update editable fields on an inbox
         * @summary Update Inbox. Change name and description. Email address is not editable.
         * @param {string} inboxId inboxId
         * @param {UpdateInboxOptions} updateInboxOptions updateInboxOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInbox: function (inboxId, updateInboxOptions, options) {
            return exports.InboxControllerApiFp(configuration).updateInbox(inboxId, updateInboxOptions, options)(fetch, basePath);
        },
    };
};
exports.InboxControllerApiFactory = InboxControllerApiFactory;
/**
 * InboxControllerApi - object-oriented interface
 * @export
 * @class InboxControllerApi
 * @extends {BaseAPI}
 */
var InboxControllerApi = /** @class */ (function (_super) {
    __extends(InboxControllerApi, _super);
    function InboxControllerApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Create a new inbox and with a randomized email address to send and receive from. Pass emailAddress parameter if you wish to use a specific email address. Creating an inbox is required before sending or receiving emails. If writing tests it is recommended that you create a new inbox during each test method so that it is unique and empty.
     * @summary Create an inbox email address. An inbox has a real email address and can send and receive emails.
     * @param {boolean} [allowTeamAccess] Grant team access to this inbox and the emails that belong to it for team members of your organization.
     * @param {string} [description] Optional description of the inbox for labelling purposes. Is shown in the dashboard and can be used with
     * @param {string} [emailAddress] A custom email address to use with the inbox. Defaults to null. When null MailSlurp will assign a random email address to the inbox such as &#x60;123@mailslurp.com&#x60;. If you use the &#x60;useDomainPool&#x60; option when the email address is null it will generate an email address with a more varied domain ending such as &#x60;123@mailslurp.info&#x60; or &#x60;123@mailslurp.biz&#x60;. When a custom email address is provided the address is split into a domain and the domain is queried against your user. If you have created the domain in the MailSlurp dashboard and verified it you can use any email address that ends with the domain. Send an email to this address and the inbox will receive and store it for you. To retrieve the email use the Inbox and Email Controller endpoints with the inbox ID.
     * @param {Date} [expiresAt] Optional inbox expiration date. If null then this inbox is permanent and the emails in it won&#39;t be deleted. If an expiration date is provided or is required by your plan the inbox will be closed when the expiration time is reached. Expired inboxes still contain their emails but can no longer send or receive emails. An ExpiredInboxRecord is created when an inbox and the email address and inbox ID are recorded. The expiresAt property is a timestamp string in ISO DateTime Format yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSXXX.
     * @param {number} [expiresIn] Number of milliseconds that inbox should exist for
     * @param {boolean} [favourite] Is the inbox favorited. Favouriting inboxes is typically done in the dashboard for quick access or filtering
     * @param {string} [name] Optional name of the inbox. Displayed in the dashboard for easier search
     * @param {Array<string>} [tags] Tags that inbox has been tagged with. Tags can be added to inboxes to group different inboxes within an account. You can also search for inboxes by tag in the dashboard UI.
     * @param {boolean} [useDomainPool] Use the MailSlurp domain name pool with this inbox when creating the email address. Defaults to null. If enabled the inbox will be an email address with a domain randomly chosen from a list of the MailSlurp domains. This is useful when the default &#x60;@mailslurp.com&#x60; email addresses used with inboxes are blocked or considered spam by a provider or receiving service. When domain pool is enabled an email address will be generated ending in &#x60;@mailslurp.{world,info,xyz,...}&#x60; . This means a TLD is randomly selecting from a list of &#x60;.biz&#x60;, &#x60;.info&#x60;, &#x60;.xyz&#x60; etc to add variance to the generated email addresses. When null or false MailSlurp uses the default behavior of &#x60;@mailslurp.com&#x60; or custom email address provided by the emailAddress field.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    InboxControllerApi.prototype.createInbox = function (allowTeamAccess, description, emailAddress, expiresAt, expiresIn, favourite, name, tags, useDomainPool, options) {
        return exports.InboxControllerApiFp(this.configuration).createInbox(allowTeamAccess, description, emailAddress, expiresAt, expiresIn, favourite, name, tags, useDomainPool, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Create an inbox with default options. Uses MailSlurp domain pool address and is private.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    InboxControllerApi.prototype.createInboxWithDefaults = function (options) {
        return exports.InboxControllerApiFp(this.configuration).createInboxWithDefaults(options)(this.fetch, this.basePath);
    };
    /**
     * Additional endpoint that allows inbox creation with request body options. Can be more flexible that other methods for some clients.
     * @summary Create an inbox with options. Extended options for inbox creation.
     * @param {CreateInboxDto} createInboxDto createInboxDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    InboxControllerApi.prototype.createInboxWithOptions = function (createInboxDto, options) {
        return exports.InboxControllerApiFp(this.configuration).createInboxWithOptions(createInboxDto, options)(this.fetch, this.basePath);
    };
    /**
     * Permanently delete all inboxes and associated email addresses. This will also delete all emails within the inboxes. Be careful as inboxes cannot be recovered once deleted. Note: deleting inboxes will not impact your usage limits. Monthly inbox creation limits are based on how many inboxes were created in the last 30 days, not how many inboxes you currently have.
     * @summary Delete all inboxes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    InboxControllerApi.prototype.deleteAllInboxes = function (options) {
        return exports.InboxControllerApiFp(this.configuration).deleteAllInboxes(options)(this.fetch, this.basePath);
    };
    /**
     * Permanently delete an inbox and associated email address as well as all emails within the given inbox. This action cannot be undone. Note: deleting an inbox will not affect your account usage. Monthly inbox usage is based on how many inboxes you create within 30 days, not how many exist at time of request.
     * @summary Delete inbox
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    InboxControllerApi.prototype.deleteInbox = function (inboxId, options) {
        return exports.InboxControllerApiFp(this.configuration).deleteInbox(inboxId, options)(this.fetch, this.basePath);
    };
    /**
     * List inboxes in paginated form. The results are available on the `content` property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). You Can also filter by whether an inbox is favorited or use email address pattern. This method is the recommended way to query inboxes. The alternative `getInboxes` method returns a full list of inboxes but is limited to 100 results. Results do not include team access inboxes by default. Use organization method to list team inboxes or set `teamAccess` to true.
     * @summary List All Inboxes Paginated
     * @param {boolean} [favourite] Optionally filter results for favourites only
     * @param {number} [page] Optional page index in inbox list pagination
     * @param {string} [search] Optionally filter by search words partial matching ID, tags, name, and email address
     * @param {number} [size] Optional page size in inbox list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {string} [tag] Optionally filter by tags. Will return inboxes that include given tags
     * @param {boolean} [teamAccess] Optionally filter by team access. Defaults to false so organization inboxes are not included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    InboxControllerApi.prototype.getAllInboxes = function (favourite, page, search, size, sort, tag, teamAccess, options) {
        return exports.InboxControllerApiFp(this.configuration).getAllInboxes(favourite, page, search, size, sort, tag, teamAccess, options)(this.fetch, this.basePath);
    };
    /**
     * List emails that an inbox has received. Only emails that are sent to the inbox's email address will appear in the inbox. It may take several seconds for any email you send to an inbox's email address to appear in the inbox. To make this endpoint wait for a minimum number of emails use the `minCount` parameter. The server will retry the inbox database until the `minCount` is satisfied or the `retryTimeout` is reached
     * @summary Get emails in an Inbox. This method is not idempotent as it allows retries and waits if you want certain conditions to be met before returning. For simple listing and sorting of known emails use the email controller instead.
     * @param {string} inboxId Id of inbox that emails belongs to
     * @param {number} [limit] Limit the result set, ordered by received date time sort direction. Maximum 100. For more listing options see the email controller
     * @param {number} [minCount] Minimum acceptable email count. Will cause request to hang (and retry) until minCount is satisfied or retryTimeout is reached.
     * @param {number} [retryTimeout] Maximum milliseconds to spend retrying inbox database until minCount emails are returned
     * @param {Date} [since] Exclude emails received before this ISO 8601 date time
     * @param {number} [size] Alias for limit. Assessed first before assessing any passed limit.
     * @param {'ASC' | 'DESC'} [sort] Sort the results by received date and direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    InboxControllerApi.prototype.getEmails = function (inboxId, limit, minCount, retryTimeout, since, size, sort, options) {
        return exports.InboxControllerApiFp(this.configuration).getEmails(inboxId, limit, minCount, retryTimeout, since, size, sort, options)(this.fetch, this.basePath);
    };
    /**
     * Returns an inbox's properties, including its email address and ID.
     * @summary Get Inbox. Returns properties of an inbox.
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    InboxControllerApi.prototype.getInbox = function (inboxId, options) {
        return exports.InboxControllerApiFp(this.configuration).getInbox(inboxId, options)(this.fetch, this.basePath);
    };
    /**
     * Get a paginated list of emails in an inbox. Does not hold connections open.
     * @summary Get inbox emails paginated
     * @param {string} inboxId Id of inbox that emails belongs to
     * @param {number} [page] Optional page index in inbox emails list pagination
     * @param {number} [size] Optional page size in inbox emails list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    InboxControllerApi.prototype.getInboxEmailsPaginated = function (inboxId, page, size, sort, options) {
        return exports.InboxControllerApiFp(this.configuration).getInboxEmailsPaginated(inboxId, page, size, sort, options)(this.fetch, this.basePath);
    };
    /**
     * Returns an inbox's sent email receipts. Call individual sent email endpoints for more details. Note for privacy reasons the full body of sent emails is never stored. An MD5 hash hex is available for comparison instead.
     * @summary Get Inbox Sent Emails
     * @param {string} inboxId inboxId
     * @param {number} [page] Optional page index in inbox sent email list pagination
     * @param {number} [size] Optional page size in inbox sent email list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    InboxControllerApi.prototype.getInboxSentEmails = function (inboxId, page, size, sort, options) {
        return exports.InboxControllerApiFp(this.configuration).getInboxSentEmails(inboxId, page, size, sort, options)(this.fetch, this.basePath);
    };
    /**
     * Get all inbox tags
     * @summary Get inbox tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    InboxControllerApi.prototype.getInboxTags = function (options) {
        return exports.InboxControllerApiFp(this.configuration).getInboxTags(options)(this.fetch, this.basePath);
    };
    /**
     * List the inboxes you have created. Note use of the more advanced `getAllEmails` is recommended. You can provide a limit and sort parameter.
     * @summary List Inboxes and email eddresses
     * @param {number} [size] Optional result size limit. Note an automatic limit of 100 results is applied. See the paginated &#x60;getAllEmails&#x60; for larger queries.
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    InboxControllerApi.prototype.getInboxes = function (size, sort, options) {
        return exports.InboxControllerApiFp(this.configuration).getInboxes(size, sort, options)(this.fetch, this.basePath);
    };
    /**
     * List organization inboxes in paginated form. These are inboxes created with `allowTeamAccess` flag enabled. Organization inboxes are `readOnly` for non-admin users. The results are available on the `content` property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time).
     * @summary List Organization Inboxes Paginated
     * @param {number} [page] Optional page index in inbox list pagination
     * @param {number} [size] Optional page size in inbox list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    InboxControllerApi.prototype.getOrganizationInboxes = function (page, size, sort, options) {
        return exports.InboxControllerApiFp(this.configuration).getOrganizationInboxes(page, size, sort, options)(this.fetch, this.basePath);
    };
    /**
     * Send an email from an inbox's email address.  The request body should contain the `SendEmailOptions` that include recipients, attachments, body etc. See `SendEmailOptions` for all available properties. Note the `inboxId` refers to the inbox's id not the inbox's email address. See https://www.mailslurp.com/guides/ for more information on how to send emails. This method does not return a sent email entity due to legacy reasons. To send and get a sent email as returned response use the sister method `sendEmailAndConfirm`.
     * @summary Send Email
     * @param {string} inboxId ID of the inbox you want to send the email from
     * @param {SendEmailOptions} [sendEmailOptions] Options for the email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    InboxControllerApi.prototype.sendEmail = function (inboxId, sendEmailOptions, options) {
        return exports.InboxControllerApiFp(this.configuration).sendEmail(inboxId, sendEmailOptions, options)(this.fetch, this.basePath);
    };
    /**
     * Sister method for standard `sendEmail` method with the benefit of returning a `SentEmail` entity confirming the successful sending of the email with a link to the sent object created for it.
     * @summary Send email and return sent confirmation
     * @param {string} inboxId ID of the inbox you want to send the email from
     * @param {SendEmailOptions} [sendEmailOptions] Options for the email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    InboxControllerApi.prototype.sendEmailAndConfirm = function (inboxId, sendEmailOptions, options) {
        return exports.InboxControllerApiFp(this.configuration).sendEmailAndConfirm(inboxId, sendEmailOptions, options)(this.fetch, this.basePath);
    };
    /**
     * Set and return new favourite state for an inbox
     * @summary Set inbox favourited state
     * @param {string} inboxId inboxId
     * @param {SetInboxFavouritedOptions} setInboxFavouritedOptions setInboxFavouritedOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    InboxControllerApi.prototype.setInboxFavourited = function (inboxId, setInboxFavouritedOptions, options) {
        return exports.InboxControllerApiFp(this.configuration).setInboxFavourited(inboxId, setInboxFavouritedOptions, options)(this.fetch, this.basePath);
    };
    /**
     * Update editable fields on an inbox
     * @summary Update Inbox. Change name and description. Email address is not editable.
     * @param {string} inboxId inboxId
     * @param {UpdateInboxOptions} updateInboxOptions updateInboxOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    InboxControllerApi.prototype.updateInbox = function (inboxId, updateInboxOptions, options) {
        return exports.InboxControllerApiFp(this.configuration).updateInbox(inboxId, updateInboxOptions, options)(this.fetch, this.basePath);
    };
    return InboxControllerApi;
}(BaseAPI));
exports.InboxControllerApi = InboxControllerApi;
/**
 * MailServerControllerApi - fetch parameter creator
 * @export
 */
var MailServerControllerApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get DNS Mail Server records for a domain
         * @param {DescribeDomainOptions} describeOptions describeOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        describeMailServerDomain: function (describeOptions, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'describeOptions' is not null or undefined
            if (describeOptions === null || describeOptions === undefined) {
                throw new RequiredError('describeOptions', 'Required parameter describeOptions was null or undefined when calling describeMailServerDomain.');
            }
            var localVarPath = "/mail-server/describe/domain";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'DescribeDomainOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(describeOptions || {})
                : describeOptions || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Lookup DNS records for a domain
         * @param {DNSLookupOptions} dnsLookupOptions dnsLookupOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDnsLookup: function (dnsLookupOptions, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'dnsLookupOptions' is not null or undefined
            if (dnsLookupOptions === null || dnsLookupOptions === undefined) {
                throw new RequiredError('dnsLookupOptions', 'Required parameter dnsLookupOptions was null or undefined when calling getDnsLookup.');
            }
            var localVarPath = "/mail-server/describe/dns-lookup";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'DNSLookupOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(dnsLookupOptions || {})
                : dnsLookupOptions || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get IP address for a domain
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIpAddress: function (name, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name', 'Required parameter name was null or undefined when calling getIpAddress.');
            }
            var localVarPath = "/mail-server/describe/ip-address";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Verify the existence of an email address at a given mail server.
         * @param {VerifyEmailAddressOptions} verifyOptions verifyOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmailAddress: function (verifyOptions, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'verifyOptions' is not null or undefined
            if (verifyOptions === null || verifyOptions === undefined) {
                throw new RequiredError('verifyOptions', 'Required parameter verifyOptions was null or undefined when calling verifyEmailAddress.');
            }
            var localVarPath = "/mail-server/verify/email-address";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'VerifyEmailAddressOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(verifyOptions || {})
                : verifyOptions || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.MailServerControllerApiFetchParamCreator = MailServerControllerApiFetchParamCreator;
/**
 * MailServerControllerApi - functional programming interface
 * @export
 */
var MailServerControllerApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Get DNS Mail Server records for a domain
         * @param {DescribeDomainOptions} describeOptions describeOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        describeMailServerDomain: function (describeOptions, options) {
            var localVarFetchArgs = exports.MailServerControllerApiFetchParamCreator(configuration).describeMailServerDomain(describeOptions, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Lookup DNS records for a domain
         * @param {DNSLookupOptions} dnsLookupOptions dnsLookupOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDnsLookup: function (dnsLookupOptions, options) {
            var localVarFetchArgs = exports.MailServerControllerApiFetchParamCreator(configuration).getDnsLookup(dnsLookupOptions, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get IP address for a domain
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIpAddress: function (name, options) {
            var localVarFetchArgs = exports.MailServerControllerApiFetchParamCreator(configuration).getIpAddress(name, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Verify the existence of an email address at a given mail server.
         * @param {VerifyEmailAddressOptions} verifyOptions verifyOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmailAddress: function (verifyOptions, options) {
            var localVarFetchArgs = exports.MailServerControllerApiFetchParamCreator(configuration).verifyEmailAddress(verifyOptions, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.MailServerControllerApiFp = MailServerControllerApiFp;
/**
 * MailServerControllerApi - factory interface
 * @export
 */
var MailServerControllerApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Get DNS Mail Server records for a domain
         * @param {DescribeDomainOptions} describeOptions describeOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        describeMailServerDomain: function (describeOptions, options) {
            return exports.MailServerControllerApiFp(configuration).describeMailServerDomain(describeOptions, options)(fetch, basePath);
        },
        /**
         *
         * @summary Lookup DNS records for a domain
         * @param {DNSLookupOptions} dnsLookupOptions dnsLookupOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDnsLookup: function (dnsLookupOptions, options) {
            return exports.MailServerControllerApiFp(configuration).getDnsLookup(dnsLookupOptions, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get IP address for a domain
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIpAddress: function (name, options) {
            return exports.MailServerControllerApiFp(configuration).getIpAddress(name, options)(fetch, basePath);
        },
        /**
         *
         * @summary Verify the existence of an email address at a given mail server.
         * @param {VerifyEmailAddressOptions} verifyOptions verifyOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmailAddress: function (verifyOptions, options) {
            return exports.MailServerControllerApiFp(configuration).verifyEmailAddress(verifyOptions, options)(fetch, basePath);
        },
    };
};
exports.MailServerControllerApiFactory = MailServerControllerApiFactory;
/**
 * MailServerControllerApi - object-oriented interface
 * @export
 * @class MailServerControllerApi
 * @extends {BaseAPI}
 */
var MailServerControllerApi = /** @class */ (function (_super) {
    __extends(MailServerControllerApi, _super);
    function MailServerControllerApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Get DNS Mail Server records for a domain
     * @param {DescribeDomainOptions} describeOptions describeOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailServerControllerApi
     */
    MailServerControllerApi.prototype.describeMailServerDomain = function (describeOptions, options) {
        return exports.MailServerControllerApiFp(this.configuration).describeMailServerDomain(describeOptions, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Lookup DNS records for a domain
     * @param {DNSLookupOptions} dnsLookupOptions dnsLookupOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailServerControllerApi
     */
    MailServerControllerApi.prototype.getDnsLookup = function (dnsLookupOptions, options) {
        return exports.MailServerControllerApiFp(this.configuration).getDnsLookup(dnsLookupOptions, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Get IP address for a domain
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailServerControllerApi
     */
    MailServerControllerApi.prototype.getIpAddress = function (name, options) {
        return exports.MailServerControllerApiFp(this.configuration).getIpAddress(name, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Verify the existence of an email address at a given mail server.
     * @param {VerifyEmailAddressOptions} verifyOptions verifyOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailServerControllerApi
     */
    MailServerControllerApi.prototype.verifyEmailAddress = function (verifyOptions, options) {
        return exports.MailServerControllerApiFp(this.configuration).verifyEmailAddress(verifyOptions, options)(this.fetch, this.basePath);
    };
    return MailServerControllerApi;
}(BaseAPI));
exports.MailServerControllerApi = MailServerControllerApi;
/**
 * MissedEmailControllerApi - fetch parameter creator
 * @export
 */
var MissedEmailControllerApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get all MissedEmails in paginated format
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMissedEmails: function (page, size, sort, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/missed-emails";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get MissedEmail
         * @param {string} missedEmailId MissedEmailId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMissedEmail: function (missedEmailId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'missedEmailId' is not null or undefined
            if (missedEmailId === null || missedEmailId === undefined) {
                throw new RequiredError('missedEmailId', 'Required parameter missedEmailId was null or undefined when calling getMissedEmail.');
            }
            var localVarPath = "/missed-emails/{MissedEmailId}".replace("{" + 'MissedEmailId' + "}", encodeURIComponent(String(missedEmailId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.MissedEmailControllerApiFetchParamCreator = MissedEmailControllerApiFetchParamCreator;
/**
 * MissedEmailControllerApi - functional programming interface
 * @export
 */
var MissedEmailControllerApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Get all MissedEmails in paginated format
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMissedEmails: function (page, size, sort, options) {
            var localVarFetchArgs = exports.MissedEmailControllerApiFetchParamCreator(configuration).getAllMissedEmails(page, size, sort, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get MissedEmail
         * @param {string} missedEmailId MissedEmailId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMissedEmail: function (missedEmailId, options) {
            var localVarFetchArgs = exports.MissedEmailControllerApiFetchParamCreator(configuration).getMissedEmail(missedEmailId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.MissedEmailControllerApiFp = MissedEmailControllerApiFp;
/**
 * MissedEmailControllerApi - factory interface
 * @export
 */
var MissedEmailControllerApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Get all MissedEmails in paginated format
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMissedEmails: function (page, size, sort, options) {
            return exports.MissedEmailControllerApiFp(configuration).getAllMissedEmails(page, size, sort, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get MissedEmail
         * @param {string} missedEmailId MissedEmailId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMissedEmail: function (missedEmailId, options) {
            return exports.MissedEmailControllerApiFp(configuration).getMissedEmail(missedEmailId, options)(fetch, basePath);
        },
    };
};
exports.MissedEmailControllerApiFactory = MissedEmailControllerApiFactory;
/**
 * MissedEmailControllerApi - object-oriented interface
 * @export
 * @class MissedEmailControllerApi
 * @extends {BaseAPI}
 */
var MissedEmailControllerApi = /** @class */ (function (_super) {
    __extends(MissedEmailControllerApi, _super);
    function MissedEmailControllerApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Get all MissedEmails in paginated format
     * @param {number} [page] Optional page index in inbox list pagination
     * @param {number} [size] Optional page size in inbox list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MissedEmailControllerApi
     */
    MissedEmailControllerApi.prototype.getAllMissedEmails = function (page, size, sort, options) {
        return exports.MissedEmailControllerApiFp(this.configuration).getAllMissedEmails(page, size, sort, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Get MissedEmail
     * @param {string} missedEmailId MissedEmailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MissedEmailControllerApi
     */
    MissedEmailControllerApi.prototype.getMissedEmail = function (missedEmailId, options) {
        return exports.MissedEmailControllerApiFp(this.configuration).getMissedEmail(missedEmailId, options)(this.fetch, this.basePath);
    };
    return MissedEmailControllerApi;
}(BaseAPI));
exports.MissedEmailControllerApi = MissedEmailControllerApi;
/**
 * SentEmailsControllerApi - fetch parameter creator
 * @export
 */
var SentEmailsControllerApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get sent email receipt
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSentEmail: function (id, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling getSentEmail.');
            }
            var localVarPath = "/sent/{id}".replace("{" + 'id' + "}", encodeURIComponent(String(id)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all sent emails in paginated form
         * @param {string} [inboxId] Optional inboxId to filter sender of sent emails by
         * @param {number} [page] Optional page index in inbox sent email list pagination
         * @param {number} [size] Optional page size in inbox sent email list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSentEmails: function (inboxId, page, size, sort, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/sent";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (inboxId !== undefined) {
                localVarQueryParameter['inboxId'] = inboxId;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all sent organization emails in paginated form
         * @param {string} [inboxId] Optional inboxId to filter sender of sent emails by
         * @param {number} [page] Optional page index in inbox sent email list pagination
         * @param {number} [size] Optional page size in inbox sent email list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSentOrganizationEmails: function (inboxId, page, size, sort, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/sent/organization";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (inboxId !== undefined) {
                localVarQueryParameter['inboxId'] = inboxId;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.SentEmailsControllerApiFetchParamCreator = SentEmailsControllerApiFetchParamCreator;
/**
 * SentEmailsControllerApi - functional programming interface
 * @export
 */
var SentEmailsControllerApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Get sent email receipt
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSentEmail: function (id, options) {
            var localVarFetchArgs = exports.SentEmailsControllerApiFetchParamCreator(configuration).getSentEmail(id, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all sent emails in paginated form
         * @param {string} [inboxId] Optional inboxId to filter sender of sent emails by
         * @param {number} [page] Optional page index in inbox sent email list pagination
         * @param {number} [size] Optional page size in inbox sent email list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSentEmails: function (inboxId, page, size, sort, options) {
            var localVarFetchArgs = exports.SentEmailsControllerApiFetchParamCreator(configuration).getSentEmails(inboxId, page, size, sort, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all sent organization emails in paginated form
         * @param {string} [inboxId] Optional inboxId to filter sender of sent emails by
         * @param {number} [page] Optional page index in inbox sent email list pagination
         * @param {number} [size] Optional page size in inbox sent email list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSentOrganizationEmails: function (inboxId, page, size, sort, options) {
            var localVarFetchArgs = exports.SentEmailsControllerApiFetchParamCreator(configuration).getSentOrganizationEmails(inboxId, page, size, sort, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.SentEmailsControllerApiFp = SentEmailsControllerApiFp;
/**
 * SentEmailsControllerApi - factory interface
 * @export
 */
var SentEmailsControllerApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Get sent email receipt
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSentEmail: function (id, options) {
            return exports.SentEmailsControllerApiFp(configuration).getSentEmail(id, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get all sent emails in paginated form
         * @param {string} [inboxId] Optional inboxId to filter sender of sent emails by
         * @param {number} [page] Optional page index in inbox sent email list pagination
         * @param {number} [size] Optional page size in inbox sent email list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSentEmails: function (inboxId, page, size, sort, options) {
            return exports.SentEmailsControllerApiFp(configuration).getSentEmails(inboxId, page, size, sort, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get all sent organization emails in paginated form
         * @param {string} [inboxId] Optional inboxId to filter sender of sent emails by
         * @param {number} [page] Optional page index in inbox sent email list pagination
         * @param {number} [size] Optional page size in inbox sent email list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSentOrganizationEmails: function (inboxId, page, size, sort, options) {
            return exports.SentEmailsControllerApiFp(configuration).getSentOrganizationEmails(inboxId, page, size, sort, options)(fetch, basePath);
        },
    };
};
exports.SentEmailsControllerApiFactory = SentEmailsControllerApiFactory;
/**
 * SentEmailsControllerApi - object-oriented interface
 * @export
 * @class SentEmailsControllerApi
 * @extends {BaseAPI}
 */
var SentEmailsControllerApi = /** @class */ (function (_super) {
    __extends(SentEmailsControllerApi, _super);
    function SentEmailsControllerApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Get sent email receipt
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SentEmailsControllerApi
     */
    SentEmailsControllerApi.prototype.getSentEmail = function (id, options) {
        return exports.SentEmailsControllerApiFp(this.configuration).getSentEmail(id, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Get all sent emails in paginated form
     * @param {string} [inboxId] Optional inboxId to filter sender of sent emails by
     * @param {number} [page] Optional page index in inbox sent email list pagination
     * @param {number} [size] Optional page size in inbox sent email list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SentEmailsControllerApi
     */
    SentEmailsControllerApi.prototype.getSentEmails = function (inboxId, page, size, sort, options) {
        return exports.SentEmailsControllerApiFp(this.configuration).getSentEmails(inboxId, page, size, sort, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Get all sent organization emails in paginated form
     * @param {string} [inboxId] Optional inboxId to filter sender of sent emails by
     * @param {number} [page] Optional page index in inbox sent email list pagination
     * @param {number} [size] Optional page size in inbox sent email list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SentEmailsControllerApi
     */
    SentEmailsControllerApi.prototype.getSentOrganizationEmails = function (inboxId, page, size, sort, options) {
        return exports.SentEmailsControllerApiFp(this.configuration).getSentOrganizationEmails(inboxId, page, size, sort, options)(this.fetch, this.basePath);
    };
    return SentEmailsControllerApi;
}(BaseAPI));
exports.SentEmailsControllerApi = SentEmailsControllerApi;
/**
 * TemplateControllerApi - fetch parameter creator
 * @export
 */
var TemplateControllerApiFetchParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Create a Template
         * @param {CreateTemplateOptions} createTemplateOptions createTemplateOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTemplate: function (createTemplateOptions, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'createTemplateOptions' is not null or undefined
            if (createTemplateOptions === null ||
                createTemplateOptions === undefined) {
                throw new RequiredError('createTemplateOptions', 'Required parameter createTemplateOptions was null or undefined when calling createTemplate.');
            }
            var localVarPath = "/templates";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'CreateTemplateOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(createTemplateOptions || {})
                : createTemplateOptions || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete Template
         * @param {string} templateId TemplateId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTemplate: function (templateId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'templateId' is not null or undefined
            if (templateId === null || templateId === undefined) {
                throw new RequiredError('templateId', 'Required parameter templateId was null or undefined when calling deleteTemplate.');
            }
            var localVarPath = "/templates/{TemplateId}".replace("{" + 'TemplateId' + "}", encodeURIComponent(String(templateId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Templates in paginated format
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTemplates: function (page, size, sort, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/templates/paginated";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Template
         * @param {string} templateId TemplateId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplate: function (templateId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'templateId' is not null or undefined
            if (templateId === null || templateId === undefined) {
                throw new RequiredError('templateId', 'Required parameter templateId was null or undefined when calling getTemplate.');
            }
            var localVarPath = "/templates/{TemplateId}".replace("{" + 'TemplateId' + "}", encodeURIComponent(String(templateId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplates: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/templates";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.TemplateControllerApiFetchParamCreator = TemplateControllerApiFetchParamCreator;
/**
 * TemplateControllerApi - functional programming interface
 * @export
 */
var TemplateControllerApiFp = function (configuration) {
    return {
        /**
         *
         * @summary Create a Template
         * @param {CreateTemplateOptions} createTemplateOptions createTemplateOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTemplate: function (createTemplateOptions, options) {
            var localVarFetchArgs = exports.TemplateControllerApiFetchParamCreator(configuration).createTemplate(createTemplateOptions, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete Template
         * @param {string} templateId TemplateId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTemplate: function (templateId, options) {
            var localVarFetchArgs = exports.TemplateControllerApiFetchParamCreator(configuration).deleteTemplate(templateId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all Templates in paginated format
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTemplates: function (page, size, sort, options) {
            var localVarFetchArgs = exports.TemplateControllerApiFetchParamCreator(configuration).getAllTemplates(page, size, sort, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get Template
         * @param {string} templateId TemplateId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplate: function (templateId, options) {
            var localVarFetchArgs = exports.TemplateControllerApiFetchParamCreator(configuration).getTemplate(templateId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplates: function (options) {
            var localVarFetchArgs = exports.TemplateControllerApiFetchParamCreator(configuration).getTemplates(options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.TemplateControllerApiFp = TemplateControllerApiFp;
/**
 * TemplateControllerApi - factory interface
 * @export
 */
var TemplateControllerApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         *
         * @summary Create a Template
         * @param {CreateTemplateOptions} createTemplateOptions createTemplateOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTemplate: function (createTemplateOptions, options) {
            return exports.TemplateControllerApiFp(configuration).createTemplate(createTemplateOptions, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete Template
         * @param {string} templateId TemplateId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTemplate: function (templateId, options) {
            return exports.TemplateControllerApiFp(configuration).deleteTemplate(templateId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get all Templates in paginated format
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTemplates: function (page, size, sort, options) {
            return exports.TemplateControllerApiFp(configuration).getAllTemplates(page, size, sort, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get Template
         * @param {string} templateId TemplateId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplate: function (templateId, options) {
            return exports.TemplateControllerApiFp(configuration).getTemplate(templateId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get all Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplates: function (options) {
            return exports.TemplateControllerApiFp(configuration).getTemplates(options)(fetch, basePath);
        },
    };
};
exports.TemplateControllerApiFactory = TemplateControllerApiFactory;
/**
 * TemplateControllerApi - object-oriented interface
 * @export
 * @class TemplateControllerApi
 * @extends {BaseAPI}
 */
var TemplateControllerApi = /** @class */ (function (_super) {
    __extends(TemplateControllerApi, _super);
    function TemplateControllerApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     *
     * @summary Create a Template
     * @param {CreateTemplateOptions} createTemplateOptions createTemplateOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateControllerApi
     */
    TemplateControllerApi.prototype.createTemplate = function (createTemplateOptions, options) {
        return exports.TemplateControllerApiFp(this.configuration).createTemplate(createTemplateOptions, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Delete Template
     * @param {string} templateId TemplateId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateControllerApi
     */
    TemplateControllerApi.prototype.deleteTemplate = function (templateId, options) {
        return exports.TemplateControllerApiFp(this.configuration).deleteTemplate(templateId, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Get all Templates in paginated format
     * @param {number} [page] Optional page index in inbox list pagination
     * @param {number} [size] Optional page size in inbox list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateControllerApi
     */
    TemplateControllerApi.prototype.getAllTemplates = function (page, size, sort, options) {
        return exports.TemplateControllerApiFp(this.configuration).getAllTemplates(page, size, sort, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Get Template
     * @param {string} templateId TemplateId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateControllerApi
     */
    TemplateControllerApi.prototype.getTemplate = function (templateId, options) {
        return exports.TemplateControllerApiFp(this.configuration).getTemplate(templateId, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Get all Templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateControllerApi
     */
    TemplateControllerApi.prototype.getTemplates = function (options) {
        return exports.TemplateControllerApiFp(this.configuration).getTemplates(options)(this.fetch, this.basePath);
    };
    return TemplateControllerApi;
}(BaseAPI));
exports.TemplateControllerApi = TemplateControllerApi;
/**
 * WaitForControllerApi - fetch parameter creator
 * @export
 */
var WaitForControllerApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Generic waitFor method that will wait until an inbox meets given conditions or return immediately if already met
         * @summary Wait for an email to match the provided filter conditions such as subject contains keyword.
         * @param {WaitForConditions} [waitForConditions] Conditions to apply to emails that you are waiting for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitFor: function (waitForConditions, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/waitFor";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'WaitForConditions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(waitForConditions || {})
                : waitForConditions || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If inbox contains count or more emails at time of request then return count worth of emails. If not wait until the count is reached and return those or return an error if timeout is exceeded.
         * @summary Wait for and return count number of emails. Hold connection until inbox count matches expected or timeout occurs
         * @param {number} [count] Number of emails to wait for. Must be greater that 1
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {boolean} [unreadOnly] Optional filter for unread only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForEmailCount: function (count, inboxId, timeout, unreadOnly, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/waitForEmailCount";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (inboxId !== undefined) {
                localVarQueryParameter['inboxId'] = inboxId;
            }
            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }
            if (unreadOnly !== undefined) {
                localVarQueryParameter['unreadOnly'] = unreadOnly;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox set `unreadOnly=true` or see the other receive methods such as `waitForNthEmail` or `waitForEmailCount`.
         * @summary Fetch inbox's latest email or if empty wait for an email to arrive
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {boolean} [unreadOnly] Optional filter for unread only.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForLatestEmail: function (inboxId, timeout, unreadOnly, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/waitForLatestEmail";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (inboxId !== undefined) {
                localVarQueryParameter['inboxId'] = inboxId;
            }
            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }
            if (unreadOnly !== undefined) {
                localVarQueryParameter['unreadOnly'] = unreadOnly;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Perform a search of emails in an inbox with the given patterns. If results match expected count then return or else retry the search until results are found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the `MatchOptions` object for options. An example payload is `{ matches: [{field: 'SUBJECT',should:'CONTAIN',value:'needle'}] }`. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController `getEmailContentMatch` method.
         * @summary Wait or return list of emails that match simple matching patterns
         * @param {MatchOptions} matchOptions matchOptions
         * @param {number} [count] Number of emails to wait for. Must be greater that 1
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {boolean} [unreadOnly] Optional filter for unread only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForMatchingEmail: function (matchOptions, count, inboxId, timeout, unreadOnly, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'matchOptions' is not null or undefined
            if (matchOptions === null || matchOptions === undefined) {
                throw new RequiredError('matchOptions', 'Required parameter matchOptions was null or undefined when calling waitForMatchingEmail.');
            }
            var localVarPath = "/waitForMatchingEmails";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }
            if (inboxId !== undefined) {
                localVarQueryParameter['inboxId'] = inboxId;
            }
            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }
            if (unreadOnly !== undefined) {
                localVarQueryParameter['unreadOnly'] = unreadOnly;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'MatchOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(matchOptions || {})
                : matchOptions || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Perform a search of emails in an inbox with the given patterns. If a result if found then return or else retry the search until a result is found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the `MatchOptions` object for options. An example payload is `{ matches: [{field: 'SUBJECT',should:'CONTAIN',value:'needle'}] }`. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController `getEmailContentMatch` method.
         * @summary Wait for or return the first email that matches proved MatchOptions array
         * @param {MatchOptions} matchOptions matchOptions
         * @param {string} [inboxId] Id of the inbox we are matching an email for
         * @param {number} [timeout] Max milliseconds to wait
         * @param {boolean} [unreadOnly] Optional filter for unread only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForMatchingFirstEmail: function (matchOptions, inboxId, timeout, unreadOnly, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'matchOptions' is not null or undefined
            if (matchOptions === null || matchOptions === undefined) {
                throw new RequiredError('matchOptions', 'Required parameter matchOptions was null or undefined when calling waitForMatchingFirstEmail.');
            }
            var localVarPath = "/waitForMatchingFirstEmail";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (inboxId !== undefined) {
                localVarQueryParameter['inboxId'] = inboxId;
            }
            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }
            if (unreadOnly !== undefined) {
                localVarQueryParameter['unreadOnly'] = unreadOnly;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'MatchOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(matchOptions || {})
                : matchOptions || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If nth email is already present in inbox then return it. If not hold the connection open until timeout expires or the nth email is received and returned.
         * @summary Wait for or fetch the email with a given index in the inbox specified. IF indx doesn't exist waits for it to exist or timeout to occur.
         * @param {string} [inboxId] Id of the inbox you are fetching emails from
         * @param {number} [index] Zero based index of the email to wait for. If an inbox has 1 email already and you want to wait for the 2nd email pass index&#x3D;1
         * @param {number} [timeout] Max milliseconds to wait for the nth email if not already present
         * @param {boolean} [unreadOnly] Optional filter for unread only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForNthEmail: function (inboxId, index, timeout, unreadOnly, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/waitForNthEmail";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (inboxId !== undefined) {
                localVarQueryParameter['inboxId'] = inboxId;
            }
            if (index !== undefined) {
                localVarQueryParameter['index'] = index;
            }
            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }
            if (unreadOnly !== undefined) {
                localVarQueryParameter['unreadOnly'] = unreadOnly;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.WaitForControllerApiFetchParamCreator = WaitForControllerApiFetchParamCreator;
/**
 * WaitForControllerApi - functional programming interface
 * @export
 */
var WaitForControllerApiFp = function (configuration) {
    return {
        /**
         * Generic waitFor method that will wait until an inbox meets given conditions or return immediately if already met
         * @summary Wait for an email to match the provided filter conditions such as subject contains keyword.
         * @param {WaitForConditions} [waitForConditions] Conditions to apply to emails that you are waiting for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitFor: function (waitForConditions, options) {
            var localVarFetchArgs = exports.WaitForControllerApiFetchParamCreator(configuration).waitFor(waitForConditions, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * If inbox contains count or more emails at time of request then return count worth of emails. If not wait until the count is reached and return those or return an error if timeout is exceeded.
         * @summary Wait for and return count number of emails. Hold connection until inbox count matches expected or timeout occurs
         * @param {number} [count] Number of emails to wait for. Must be greater that 1
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {boolean} [unreadOnly] Optional filter for unread only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForEmailCount: function (count, inboxId, timeout, unreadOnly, options) {
            var localVarFetchArgs = exports.WaitForControllerApiFetchParamCreator(configuration).waitForEmailCount(count, inboxId, timeout, unreadOnly, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox set `unreadOnly=true` or see the other receive methods such as `waitForNthEmail` or `waitForEmailCount`.
         * @summary Fetch inbox's latest email or if empty wait for an email to arrive
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {boolean} [unreadOnly] Optional filter for unread only.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForLatestEmail: function (inboxId, timeout, unreadOnly, options) {
            var localVarFetchArgs = exports.WaitForControllerApiFetchParamCreator(configuration).waitForLatestEmail(inboxId, timeout, unreadOnly, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Perform a search of emails in an inbox with the given patterns. If results match expected count then return or else retry the search until results are found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the `MatchOptions` object for options. An example payload is `{ matches: [{field: 'SUBJECT',should:'CONTAIN',value:'needle'}] }`. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController `getEmailContentMatch` method.
         * @summary Wait or return list of emails that match simple matching patterns
         * @param {MatchOptions} matchOptions matchOptions
         * @param {number} [count] Number of emails to wait for. Must be greater that 1
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {boolean} [unreadOnly] Optional filter for unread only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForMatchingEmail: function (matchOptions, count, inboxId, timeout, unreadOnly, options) {
            var localVarFetchArgs = exports.WaitForControllerApiFetchParamCreator(configuration).waitForMatchingEmail(matchOptions, count, inboxId, timeout, unreadOnly, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Perform a search of emails in an inbox with the given patterns. If a result if found then return or else retry the search until a result is found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the `MatchOptions` object for options. An example payload is `{ matches: [{field: 'SUBJECT',should:'CONTAIN',value:'needle'}] }`. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController `getEmailContentMatch` method.
         * @summary Wait for or return the first email that matches proved MatchOptions array
         * @param {MatchOptions} matchOptions matchOptions
         * @param {string} [inboxId] Id of the inbox we are matching an email for
         * @param {number} [timeout] Max milliseconds to wait
         * @param {boolean} [unreadOnly] Optional filter for unread only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForMatchingFirstEmail: function (matchOptions, inboxId, timeout, unreadOnly, options) {
            var localVarFetchArgs = exports.WaitForControllerApiFetchParamCreator(configuration).waitForMatchingFirstEmail(matchOptions, inboxId, timeout, unreadOnly, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * If nth email is already present in inbox then return it. If not hold the connection open until timeout expires or the nth email is received and returned.
         * @summary Wait for or fetch the email with a given index in the inbox specified. IF indx doesn't exist waits for it to exist or timeout to occur.
         * @param {string} [inboxId] Id of the inbox you are fetching emails from
         * @param {number} [index] Zero based index of the email to wait for. If an inbox has 1 email already and you want to wait for the 2nd email pass index&#x3D;1
         * @param {number} [timeout] Max milliseconds to wait for the nth email if not already present
         * @param {boolean} [unreadOnly] Optional filter for unread only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForNthEmail: function (inboxId, index, timeout, unreadOnly, options) {
            var localVarFetchArgs = exports.WaitForControllerApiFetchParamCreator(configuration).waitForNthEmail(inboxId, index, timeout, unreadOnly, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.WaitForControllerApiFp = WaitForControllerApiFp;
/**
 * WaitForControllerApi - factory interface
 * @export
 */
var WaitForControllerApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Generic waitFor method that will wait until an inbox meets given conditions or return immediately if already met
         * @summary Wait for an email to match the provided filter conditions such as subject contains keyword.
         * @param {WaitForConditions} [waitForConditions] Conditions to apply to emails that you are waiting for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitFor: function (waitForConditions, options) {
            return exports.WaitForControllerApiFp(configuration).waitFor(waitForConditions, options)(fetch, basePath);
        },
        /**
         * If inbox contains count or more emails at time of request then return count worth of emails. If not wait until the count is reached and return those or return an error if timeout is exceeded.
         * @summary Wait for and return count number of emails. Hold connection until inbox count matches expected or timeout occurs
         * @param {number} [count] Number of emails to wait for. Must be greater that 1
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {boolean} [unreadOnly] Optional filter for unread only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForEmailCount: function (count, inboxId, timeout, unreadOnly, options) {
            return exports.WaitForControllerApiFp(configuration).waitForEmailCount(count, inboxId, timeout, unreadOnly, options)(fetch, basePath);
        },
        /**
         * Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox set `unreadOnly=true` or see the other receive methods such as `waitForNthEmail` or `waitForEmailCount`.
         * @summary Fetch inbox's latest email or if empty wait for an email to arrive
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {boolean} [unreadOnly] Optional filter for unread only.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForLatestEmail: function (inboxId, timeout, unreadOnly, options) {
            return exports.WaitForControllerApiFp(configuration).waitForLatestEmail(inboxId, timeout, unreadOnly, options)(fetch, basePath);
        },
        /**
         * Perform a search of emails in an inbox with the given patterns. If results match expected count then return or else retry the search until results are found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the `MatchOptions` object for options. An example payload is `{ matches: [{field: 'SUBJECT',should:'CONTAIN',value:'needle'}] }`. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController `getEmailContentMatch` method.
         * @summary Wait or return list of emails that match simple matching patterns
         * @param {MatchOptions} matchOptions matchOptions
         * @param {number} [count] Number of emails to wait for. Must be greater that 1
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {boolean} [unreadOnly] Optional filter for unread only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForMatchingEmail: function (matchOptions, count, inboxId, timeout, unreadOnly, options) {
            return exports.WaitForControllerApiFp(configuration).waitForMatchingEmail(matchOptions, count, inboxId, timeout, unreadOnly, options)(fetch, basePath);
        },
        /**
         * Perform a search of emails in an inbox with the given patterns. If a result if found then return or else retry the search until a result is found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the `MatchOptions` object for options. An example payload is `{ matches: [{field: 'SUBJECT',should:'CONTAIN',value:'needle'}] }`. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController `getEmailContentMatch` method.
         * @summary Wait for or return the first email that matches proved MatchOptions array
         * @param {MatchOptions} matchOptions matchOptions
         * @param {string} [inboxId] Id of the inbox we are matching an email for
         * @param {number} [timeout] Max milliseconds to wait
         * @param {boolean} [unreadOnly] Optional filter for unread only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForMatchingFirstEmail: function (matchOptions, inboxId, timeout, unreadOnly, options) {
            return exports.WaitForControllerApiFp(configuration).waitForMatchingFirstEmail(matchOptions, inboxId, timeout, unreadOnly, options)(fetch, basePath);
        },
        /**
         * If nth email is already present in inbox then return it. If not hold the connection open until timeout expires or the nth email is received and returned.
         * @summary Wait for or fetch the email with a given index in the inbox specified. IF indx doesn't exist waits for it to exist or timeout to occur.
         * @param {string} [inboxId] Id of the inbox you are fetching emails from
         * @param {number} [index] Zero based index of the email to wait for. If an inbox has 1 email already and you want to wait for the 2nd email pass index&#x3D;1
         * @param {number} [timeout] Max milliseconds to wait for the nth email if not already present
         * @param {boolean} [unreadOnly] Optional filter for unread only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForNthEmail: function (inboxId, index, timeout, unreadOnly, options) {
            return exports.WaitForControllerApiFp(configuration).waitForNthEmail(inboxId, index, timeout, unreadOnly, options)(fetch, basePath);
        },
    };
};
exports.WaitForControllerApiFactory = WaitForControllerApiFactory;
/**
 * WaitForControllerApi - object-oriented interface
 * @export
 * @class WaitForControllerApi
 * @extends {BaseAPI}
 */
var WaitForControllerApi = /** @class */ (function (_super) {
    __extends(WaitForControllerApi, _super);
    function WaitForControllerApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Generic waitFor method that will wait until an inbox meets given conditions or return immediately if already met
     * @summary Wait for an email to match the provided filter conditions such as subject contains keyword.
     * @param {WaitForConditions} [waitForConditions] Conditions to apply to emails that you are waiting for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitForControllerApi
     */
    WaitForControllerApi.prototype.waitFor = function (waitForConditions, options) {
        return exports.WaitForControllerApiFp(this.configuration).waitFor(waitForConditions, options)(this.fetch, this.basePath);
    };
    /**
     * If inbox contains count or more emails at time of request then return count worth of emails. If not wait until the count is reached and return those or return an error if timeout is exceeded.
     * @summary Wait for and return count number of emails. Hold connection until inbox count matches expected or timeout occurs
     * @param {number} [count] Number of emails to wait for. Must be greater that 1
     * @param {string} [inboxId] Id of the inbox we are fetching emails from
     * @param {number} [timeout] Max milliseconds to wait
     * @param {boolean} [unreadOnly] Optional filter for unread only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitForControllerApi
     */
    WaitForControllerApi.prototype.waitForEmailCount = function (count, inboxId, timeout, unreadOnly, options) {
        return exports.WaitForControllerApiFp(this.configuration).waitForEmailCount(count, inboxId, timeout, unreadOnly, options)(this.fetch, this.basePath);
    };
    /**
     * Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox set `unreadOnly=true` or see the other receive methods such as `waitForNthEmail` or `waitForEmailCount`.
     * @summary Fetch inbox's latest email or if empty wait for an email to arrive
     * @param {string} [inboxId] Id of the inbox we are fetching emails from
     * @param {number} [timeout] Max milliseconds to wait
     * @param {boolean} [unreadOnly] Optional filter for unread only.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitForControllerApi
     */
    WaitForControllerApi.prototype.waitForLatestEmail = function (inboxId, timeout, unreadOnly, options) {
        return exports.WaitForControllerApiFp(this.configuration).waitForLatestEmail(inboxId, timeout, unreadOnly, options)(this.fetch, this.basePath);
    };
    /**
     * Perform a search of emails in an inbox with the given patterns. If results match expected count then return or else retry the search until results are found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the `MatchOptions` object for options. An example payload is `{ matches: [{field: 'SUBJECT',should:'CONTAIN',value:'needle'}] }`. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController `getEmailContentMatch` method.
     * @summary Wait or return list of emails that match simple matching patterns
     * @param {MatchOptions} matchOptions matchOptions
     * @param {number} [count] Number of emails to wait for. Must be greater that 1
     * @param {string} [inboxId] Id of the inbox we are fetching emails from
     * @param {number} [timeout] Max milliseconds to wait
     * @param {boolean} [unreadOnly] Optional filter for unread only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitForControllerApi
     */
    WaitForControllerApi.prototype.waitForMatchingEmail = function (matchOptions, count, inboxId, timeout, unreadOnly, options) {
        return exports.WaitForControllerApiFp(this.configuration).waitForMatchingEmail(matchOptions, count, inboxId, timeout, unreadOnly, options)(this.fetch, this.basePath);
    };
    /**
     * Perform a search of emails in an inbox with the given patterns. If a result if found then return or else retry the search until a result is found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the `MatchOptions` object for options. An example payload is `{ matches: [{field: 'SUBJECT',should:'CONTAIN',value:'needle'}] }`. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController `getEmailContentMatch` method.
     * @summary Wait for or return the first email that matches proved MatchOptions array
     * @param {MatchOptions} matchOptions matchOptions
     * @param {string} [inboxId] Id of the inbox we are matching an email for
     * @param {number} [timeout] Max milliseconds to wait
     * @param {boolean} [unreadOnly] Optional filter for unread only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitForControllerApi
     */
    WaitForControllerApi.prototype.waitForMatchingFirstEmail = function (matchOptions, inboxId, timeout, unreadOnly, options) {
        return exports.WaitForControllerApiFp(this.configuration).waitForMatchingFirstEmail(matchOptions, inboxId, timeout, unreadOnly, options)(this.fetch, this.basePath);
    };
    /**
     * If nth email is already present in inbox then return it. If not hold the connection open until timeout expires or the nth email is received and returned.
     * @summary Wait for or fetch the email with a given index in the inbox specified. IF indx doesn't exist waits for it to exist or timeout to occur.
     * @param {string} [inboxId] Id of the inbox you are fetching emails from
     * @param {number} [index] Zero based index of the email to wait for. If an inbox has 1 email already and you want to wait for the 2nd email pass index&#x3D;1
     * @param {number} [timeout] Max milliseconds to wait for the nth email if not already present
     * @param {boolean} [unreadOnly] Optional filter for unread only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitForControllerApi
     */
    WaitForControllerApi.prototype.waitForNthEmail = function (inboxId, index, timeout, unreadOnly, options) {
        return exports.WaitForControllerApiFp(this.configuration).waitForNthEmail(inboxId, index, timeout, unreadOnly, options)(this.fetch, this.basePath);
    };
    return WaitForControllerApi;
}(BaseAPI));
exports.WaitForControllerApi = WaitForControllerApi;
/**
 * WebhookControllerApi - fetch parameter creator
 * @export
 */
var WebhookControllerApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Get notified whenever an inbox receives an email via a WebHook URL. An emailID will be posted to this URL every time an email is received for this inbox. The URL must be publicly reachable by the MailSlurp server. You can provide basicAuth values if you wish to secure this endpoint.
         * @summary Attach a WebHook URL to an inbox
         * @param {string} inboxId inboxId
         * @param {CreateWebhookOptions} webhookOptions webhookOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook: function (inboxId, webhookOptions, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError('inboxId', 'Required parameter inboxId was null or undefined when calling createWebhook.');
            }
            // verify required parameter 'webhookOptions' is not null or undefined
            if (webhookOptions === null || webhookOptions === undefined) {
                throw new RequiredError('webhookOptions', 'Required parameter webhookOptions was null or undefined when calling createWebhook.');
            }
            var localVarPath = "/inboxes/{inboxId}/webhooks".replace("{" + 'inboxId' + "}", encodeURIComponent(String(inboxId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            var needsSerialization = 'CreateWebhookOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(webhookOptions || {})
                : webhookOptions || '';
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete and disable a Webhook for an Inbox
         * @param {string} inboxId inboxId
         * @param {string} webhookId webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook: function (inboxId, webhookId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError('inboxId', 'Required parameter inboxId was null or undefined when calling deleteWebhook.');
            }
            // verify required parameter 'webhookId' is not null or undefined
            if (webhookId === null || webhookId === undefined) {
                throw new RequiredError('webhookId', 'Required parameter webhookId was null or undefined when calling deleteWebhook.');
            }
            var localVarPath = "/inboxes/{inboxId}/webhooks/{webhookId}"
                .replace("{" + 'inboxId' + "}", encodeURIComponent(String(inboxId)))
                .replace("{" + 'webhookId' + "}", encodeURIComponent(String(webhookId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List webhooks in paginated form. Allows for page index, page size, and sort direction.
         * @summary List Webhooks Paginated
         * @param {number} [page] Optional page index in list pagination
         * @param {number} [size] Optional page size in list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWebhooks: function (page, size, sort, options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/webhooks/paginated";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get test webhook payload example
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestWebhookPayload: function (options) {
            if (options === void 0) { options = {}; }
            var localVarPath = "/webhooks/test";
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a webhook for an Inbox
         * @param {string} webhookId webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook: function (webhookId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'webhookId' is not null or undefined
            if (webhookId === null || webhookId === undefined) {
                throw new RequiredError('webhookId', 'Required parameter webhookId was null or undefined when calling getWebhook.');
            }
            var localVarPath = "/webhooks/{webhookId}".replace("{" + 'webhookId' + "}", encodeURIComponent(String(webhookId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all webhooks for an Inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks: function (inboxId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError('inboxId', 'Required parameter inboxId was null or undefined when calling getWebhooks.');
            }
            var localVarPath = "/inboxes/{inboxId}/webhooks".replace("{" + 'inboxId' + "}", encodeURIComponent(String(inboxId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Send webhook test data
         * @param {string} webhookId webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTestData: function (webhookId, options) {
            if (options === void 0) { options = {}; }
            // verify required parameter 'webhookId' is not null or undefined
            if (webhookId === null || webhookId === undefined) {
                throw new RequiredError('webhookId', 'Required parameter webhookId was null or undefined when calling sendTestData.');
            }
            var localVarPath = "/webhooks/{webhookId}/test".replace("{" + 'webhookId' + "}", encodeURIComponent(String(webhookId)));
            var localVarUrlObj = url.parse(localVarPath, true);
            var localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                var localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey('x-api-key')
                    : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.WebhookControllerApiFetchParamCreator = WebhookControllerApiFetchParamCreator;
/**
 * WebhookControllerApi - functional programming interface
 * @export
 */
var WebhookControllerApiFp = function (configuration) {
    return {
        /**
         * Get notified whenever an inbox receives an email via a WebHook URL. An emailID will be posted to this URL every time an email is received for this inbox. The URL must be publicly reachable by the MailSlurp server. You can provide basicAuth values if you wish to secure this endpoint.
         * @summary Attach a WebHook URL to an inbox
         * @param {string} inboxId inboxId
         * @param {CreateWebhookOptions} webhookOptions webhookOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook: function (inboxId, webhookOptions, options) {
            var localVarFetchArgs = exports.WebhookControllerApiFetchParamCreator(configuration).createWebhook(inboxId, webhookOptions, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete and disable a Webhook for an Inbox
         * @param {string} inboxId inboxId
         * @param {string} webhookId webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook: function (inboxId, webhookId, options) {
            var localVarFetchArgs = exports.WebhookControllerApiFetchParamCreator(configuration).deleteWebhook(inboxId, webhookId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List webhooks in paginated form. Allows for page index, page size, and sort direction.
         * @summary List Webhooks Paginated
         * @param {number} [page] Optional page index in list pagination
         * @param {number} [size] Optional page size in list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWebhooks: function (page, size, sort, options) {
            var localVarFetchArgs = exports.WebhookControllerApiFetchParamCreator(configuration).getAllWebhooks(page, size, sort, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get test webhook payload example
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestWebhookPayload: function (options) {
            var localVarFetchArgs = exports.WebhookControllerApiFetchParamCreator(configuration).getTestWebhookPayload(options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get a webhook for an Inbox
         * @param {string} webhookId webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook: function (webhookId, options) {
            var localVarFetchArgs = exports.WebhookControllerApiFetchParamCreator(configuration).getWebhook(webhookId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all webhooks for an Inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks: function (inboxId, options) {
            var localVarFetchArgs = exports.WebhookControllerApiFetchParamCreator(configuration).getWebhooks(inboxId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Send webhook test data
         * @param {string} webhookId webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTestData: function (webhookId, options) {
            var localVarFetchArgs = exports.WebhookControllerApiFetchParamCreator(configuration).sendTestData(webhookId, options);
            return function (fetch, basePath) {
                if (fetch === void 0) { fetch = portableFetch; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(function (response) {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.WebhookControllerApiFp = WebhookControllerApiFp;
/**
 * WebhookControllerApi - factory interface
 * @export
 */
var WebhookControllerApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Get notified whenever an inbox receives an email via a WebHook URL. An emailID will be posted to this URL every time an email is received for this inbox. The URL must be publicly reachable by the MailSlurp server. You can provide basicAuth values if you wish to secure this endpoint.
         * @summary Attach a WebHook URL to an inbox
         * @param {string} inboxId inboxId
         * @param {CreateWebhookOptions} webhookOptions webhookOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook: function (inboxId, webhookOptions, options) {
            return exports.WebhookControllerApiFp(configuration).createWebhook(inboxId, webhookOptions, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete and disable a Webhook for an Inbox
         * @param {string} inboxId inboxId
         * @param {string} webhookId webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook: function (inboxId, webhookId, options) {
            return exports.WebhookControllerApiFp(configuration).deleteWebhook(inboxId, webhookId, options)(fetch, basePath);
        },
        /**
         * List webhooks in paginated form. Allows for page index, page size, and sort direction.
         * @summary List Webhooks Paginated
         * @param {number} [page] Optional page index in list pagination
         * @param {number} [size] Optional page size in list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWebhooks: function (page, size, sort, options) {
            return exports.WebhookControllerApiFp(configuration).getAllWebhooks(page, size, sort, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get test webhook payload example
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestWebhookPayload: function (options) {
            return exports.WebhookControllerApiFp(configuration).getTestWebhookPayload(options)(fetch, basePath);
        },
        /**
         *
         * @summary Get a webhook for an Inbox
         * @param {string} webhookId webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook: function (webhookId, options) {
            return exports.WebhookControllerApiFp(configuration).getWebhook(webhookId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get all webhooks for an Inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks: function (inboxId, options) {
            return exports.WebhookControllerApiFp(configuration).getWebhooks(inboxId, options)(fetch, basePath);
        },
        /**
         *
         * @summary Send webhook test data
         * @param {string} webhookId webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTestData: function (webhookId, options) {
            return exports.WebhookControllerApiFp(configuration).sendTestData(webhookId, options)(fetch, basePath);
        },
    };
};
exports.WebhookControllerApiFactory = WebhookControllerApiFactory;
/**
 * WebhookControllerApi - object-oriented interface
 * @export
 * @class WebhookControllerApi
 * @extends {BaseAPI}
 */
var WebhookControllerApi = /** @class */ (function (_super) {
    __extends(WebhookControllerApi, _super);
    function WebhookControllerApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Get notified whenever an inbox receives an email via a WebHook URL. An emailID will be posted to this URL every time an email is received for this inbox. The URL must be publicly reachable by the MailSlurp server. You can provide basicAuth values if you wish to secure this endpoint.
     * @summary Attach a WebHook URL to an inbox
     * @param {string} inboxId inboxId
     * @param {CreateWebhookOptions} webhookOptions webhookOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookControllerApi
     */
    WebhookControllerApi.prototype.createWebhook = function (inboxId, webhookOptions, options) {
        return exports.WebhookControllerApiFp(this.configuration).createWebhook(inboxId, webhookOptions, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Delete and disable a Webhook for an Inbox
     * @param {string} inboxId inboxId
     * @param {string} webhookId webhookId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookControllerApi
     */
    WebhookControllerApi.prototype.deleteWebhook = function (inboxId, webhookId, options) {
        return exports.WebhookControllerApiFp(this.configuration).deleteWebhook(inboxId, webhookId, options)(this.fetch, this.basePath);
    };
    /**
     * List webhooks in paginated form. Allows for page index, page size, and sort direction.
     * @summary List Webhooks Paginated
     * @param {number} [page] Optional page index in list pagination
     * @param {number} [size] Optional page size in list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookControllerApi
     */
    WebhookControllerApi.prototype.getAllWebhooks = function (page, size, sort, options) {
        return exports.WebhookControllerApiFp(this.configuration).getAllWebhooks(page, size, sort, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Get test webhook payload example
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookControllerApi
     */
    WebhookControllerApi.prototype.getTestWebhookPayload = function (options) {
        return exports.WebhookControllerApiFp(this.configuration).getTestWebhookPayload(options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Get a webhook for an Inbox
     * @param {string} webhookId webhookId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookControllerApi
     */
    WebhookControllerApi.prototype.getWebhook = function (webhookId, options) {
        return exports.WebhookControllerApiFp(this.configuration).getWebhook(webhookId, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Get all webhooks for an Inbox
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookControllerApi
     */
    WebhookControllerApi.prototype.getWebhooks = function (inboxId, options) {
        return exports.WebhookControllerApiFp(this.configuration).getWebhooks(inboxId, options)(this.fetch, this.basePath);
    };
    /**
     *
     * @summary Send webhook test data
     * @param {string} webhookId webhookId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookControllerApi
     */
    WebhookControllerApi.prototype.sendTestData = function (webhookId, options) {
        return exports.WebhookControllerApiFp(this.configuration).sendTestData(webhookId, options)(this.fetch, this.basePath);
    };
    return WebhookControllerApi;
}(BaseAPI));
exports.WebhookControllerApi = WebhookControllerApi;
