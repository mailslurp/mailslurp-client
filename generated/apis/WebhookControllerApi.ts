/* tslint:disable */
/* eslint-disable */
/**
 * MailSlurp API
 * MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It\'s designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.   ## Resources - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://www.mailslurp.com/docs/) - [Examples](https://github.com/mailslurp/examples) repository 
 *
 * The version of the OpenAPI document: 67c9a1eda264be4cfe0bb2c76151f0aadf0862bc
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    CreateWebhookOptions,
    CreateWebhookOptionsFromJSON,
    CreateWebhookOptionsToJSON,
    PageWebhookProjection,
    PageWebhookProjectionFromJSON,
    PageWebhookProjectionToJSON,
    WebhookDto,
    WebhookDtoFromJSON,
    WebhookDtoToJSON,
    WebhookTestResult,
    WebhookTestResultFromJSON,
    WebhookTestResultToJSON,
} from '../models';

export interface CreateWebhookRequest {
    inboxId: string;
    webhookOptions: CreateWebhookOptions;
}

export interface DeleteWebhookRequest {
    inboxId: string;
    webhookId: string;
}

export interface GetAllWebhooksRequest {
    page?: number;
    size?: number;
    sort?: GetAllWebhooksSortEnum;
}

export interface GetWebhookRequest {
    webhookId: string;
}

export interface GetWebhooksRequest {
    inboxId: string;
}

export interface SendTestDataRequest {
    webhookId: string;
}

/**
 * no description
 */
export class WebhookControllerApi extends runtime.BaseAPI {

    /**
     * Get notified whenever an inbox receives an email via a WebHook URL. An emailID will be posted to this URL every time an email is received for this inbox. The URL must be publicly reachable by the MailSlurp server. You can provide basicAuth values if you wish to secure this endpoint.
     * Attach a WebHook URL to an inbox
     */
    async createWebhookRaw(requestParameters: CreateWebhookRequest): Promise<runtime.ApiResponse<WebhookDto>> {
        if (requestParameters.inboxId === null || requestParameters.inboxId === undefined) {
            throw new runtime.RequiredError('inboxId','Required parameter requestParameters.inboxId was null or undefined when calling createWebhook.');
        }

        if (requestParameters.webhookOptions === null || requestParameters.webhookOptions === undefined) {
            throw new runtime.RequiredError('webhookOptions','Required parameter requestParameters.webhookOptions was null or undefined when calling createWebhook.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = this.configuration.apiKey("x-api-key"); // API_KEY authentication
        }

        const response = await this.request({
            path: `/inboxes/{inboxId}/webhooks`.replace(`{${"inboxId"}}`, encodeURIComponent(String(requestParameters.inboxId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateWebhookOptionsToJSON(requestParameters.webhookOptions),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => WebhookDtoFromJSON(jsonValue));
    }

    /**
     * Get notified whenever an inbox receives an email via a WebHook URL. An emailID will be posted to this URL every time an email is received for this inbox. The URL must be publicly reachable by the MailSlurp server. You can provide basicAuth values if you wish to secure this endpoint.
     * Attach a WebHook URL to an inbox
     */
    async createWebhook(requestParameters: CreateWebhookRequest): Promise<WebhookDto> {
        const response = await this.createWebhookRaw(requestParameters);
        return await response.value();
    }

    /**
     * Delete and disable a Webhook for an Inbox
     */
    async deleteWebhookRaw(requestParameters: DeleteWebhookRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.inboxId === null || requestParameters.inboxId === undefined) {
            throw new runtime.RequiredError('inboxId','Required parameter requestParameters.inboxId was null or undefined when calling deleteWebhook.');
        }

        if (requestParameters.webhookId === null || requestParameters.webhookId === undefined) {
            throw new runtime.RequiredError('webhookId','Required parameter requestParameters.webhookId was null or undefined when calling deleteWebhook.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = this.configuration.apiKey("x-api-key"); // API_KEY authentication
        }

        const response = await this.request({
            path: `/inboxes/{inboxId}/webhooks/{webhookId}`.replace(`{${"inboxId"}}`, encodeURIComponent(String(requestParameters.inboxId))).replace(`{${"webhookId"}}`, encodeURIComponent(String(requestParameters.webhookId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete and disable a Webhook for an Inbox
     */
    async deleteWebhook(requestParameters: DeleteWebhookRequest): Promise<void> {
        await this.deleteWebhookRaw(requestParameters);
    }

    /**
     * List webhooks in paginated form. Allows for page index, page size, and sort direction.
     * List Webhooks Paginated
     */
    async getAllWebhooksRaw(requestParameters: GetAllWebhooksRequest): Promise<runtime.ApiResponse<PageWebhookProjection>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = this.configuration.apiKey("x-api-key"); // API_KEY authentication
        }

        const response = await this.request({
            path: `/webhooks/paginated`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PageWebhookProjectionFromJSON(jsonValue));
    }

    /**
     * List webhooks in paginated form. Allows for page index, page size, and sort direction.
     * List Webhooks Paginated
     */
    async getAllWebhooks(requestParameters: GetAllWebhooksRequest): Promise<PageWebhookProjection> {
        const response = await this.getAllWebhooksRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get a webhook for an Inbox
     */
    async getWebhookRaw(requestParameters: GetWebhookRequest): Promise<runtime.ApiResponse<WebhookDto>> {
        if (requestParameters.webhookId === null || requestParameters.webhookId === undefined) {
            throw new runtime.RequiredError('webhookId','Required parameter requestParameters.webhookId was null or undefined when calling getWebhook.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = this.configuration.apiKey("x-api-key"); // API_KEY authentication
        }

        const response = await this.request({
            path: `/webhooks/{webhookId}`.replace(`{${"webhookId"}}`, encodeURIComponent(String(requestParameters.webhookId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => WebhookDtoFromJSON(jsonValue));
    }

    /**
     * Get a webhook for an Inbox
     */
    async getWebhook(requestParameters: GetWebhookRequest): Promise<WebhookDto> {
        const response = await this.getWebhookRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get all Webhooks for an Inbox
     */
    async getWebhooksRaw(requestParameters: GetWebhooksRequest): Promise<runtime.ApiResponse<Array<WebhookDto>>> {
        if (requestParameters.inboxId === null || requestParameters.inboxId === undefined) {
            throw new runtime.RequiredError('inboxId','Required parameter requestParameters.inboxId was null or undefined when calling getWebhooks.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = this.configuration.apiKey("x-api-key"); // API_KEY authentication
        }

        const response = await this.request({
            path: `/inboxes/{inboxId}/webhooks`.replace(`{${"inboxId"}}`, encodeURIComponent(String(requestParameters.inboxId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(WebhookDtoFromJSON));
    }

    /**
     * Get all Webhooks for an Inbox
     */
    async getWebhooks(requestParameters: GetWebhooksRequest): Promise<Array<WebhookDto>> {
        const response = await this.getWebhooksRaw(requestParameters);
        return await response.value();
    }

    /**
     * Send webhook test data
     */
    async sendTestDataRaw(requestParameters: SendTestDataRequest): Promise<runtime.ApiResponse<WebhookTestResult>> {
        if (requestParameters.webhookId === null || requestParameters.webhookId === undefined) {
            throw new runtime.RequiredError('webhookId','Required parameter requestParameters.webhookId was null or undefined when calling sendTestData.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = this.configuration.apiKey("x-api-key"); // API_KEY authentication
        }

        const response = await this.request({
            path: `/webhooks/{webhookId}/test`.replace(`{${"webhookId"}}`, encodeURIComponent(String(requestParameters.webhookId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => WebhookTestResultFromJSON(jsonValue));
    }

    /**
     * Send webhook test data
     */
    async sendTestData(requestParameters: SendTestDataRequest): Promise<WebhookTestResult> {
        const response = await this.sendTestDataRaw(requestParameters);
        return await response.value();
    }

}

/**
    * @export
    * @enum {string}
    */
export enum GetAllWebhooksSortEnum {
    ASC = 'ASC',
    DESC = 'DESC'
}
