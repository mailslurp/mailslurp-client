/* tslint:disable */
/* eslint-disable */
/**
 * MailSlurp API
 * MailSlurp is an API for sending and receiving emails and SMS from dynamically allocated email addresses and phone numbers. It\'s designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
import {
  EmailRecipientsProjection,
  EmailRecipientsProjectionFromJSON,
  EmailRecipientsProjectionFromJSONTyped,
  EmailRecipientsProjectionToJSON,
  SenderProjection,
  SenderProjectionFromJSON,
  SenderProjectionFromJSONTyped,
  SenderProjectionToJSON,
} from './';

/**
 * An email thread is a message thread created for a email based on Message-ID, In-Reply-To, and References headers
 * @export
 * @interface EmailThreadProjection
 */
export interface EmailThreadProjection {
  /**
   * Thread topic subject
   * @type {string}
   * @memberof EmailThreadProjection
   */
  subject?: string;
  /**
   * Created at DateTime
   * @type {Date}
   * @memberof EmailThreadProjection
   */
  createdAt: Date;
  /**
   * Updated at DateTime
   * @type {Date}
   * @memberof EmailThreadProjection
   */
  updatedAt: Date;
  /**
   *
   * @type {SenderProjection}
   * @memberof EmailThreadProjection
   */
  sender?: SenderProjection;
  /**
   *
   * @type {EmailRecipientsProjection}
   * @memberof EmailThreadProjection
   */
  recipients?: EmailRecipientsProjection;
  /**
   * User ID
   * @type {string}
   * @memberof EmailThreadProjection
   */
  userId: string;
  /**
   * Inbox ID
   * @type {string}
   * @memberof EmailThreadProjection
   */
  inboxId?: string;
  /**
   * To recipients
   * @type {Array<string>}
   * @memberof EmailThreadProjection
   */
  to: Array<string>;
  /**
   * CC recipients
   * @type {Array<string>}
   * @memberof EmailThreadProjection
   */
  cc?: Array<string>;
  /**
   * BCC recipients
   * @type {Array<string>}
   * @memberof EmailThreadProjection
   */
  bcc?: Array<string>;
  /**
   * Has attachments
   * @type {boolean}
   * @memberof EmailThreadProjection
   */
  hasAttachments: boolean;
  /**
   * Has unread
   * @type {boolean}
   * @memberof EmailThreadProjection
   */
  unread: boolean;
  /**
   * Number of messages in the thread
   * @type {number}
   * @memberof EmailThreadProjection
   */
  messageCount: number;
  /**
   * Last body excerpt
   * @type {string}
   * @memberof EmailThreadProjection
   */
  lastBodyExcerpt?: string;
  /**
   * Last text excerpt
   * @type {string}
   * @memberof EmailThreadProjection
   */
  lastTextExcerpt?: string;
  /**
   * Last email created time
   * @type {Date}
   * @memberof EmailThreadProjection
   */
  lastCreatedAt?: Date;
  /**
   * Last sender
   * @type {string}
   * @memberof EmailThreadProjection
   */
  lastFrom?: string;
  /**
   *
   * @type {SenderProjection}
   * @memberof EmailThreadProjection
   */
  lastSender?: SenderProjection;
  /**
   * ID of email thread
   * @type {string}
   * @memberof EmailThreadProjection
   */
  id: string;
  /**
   * From sender
   * @type {string}
   * @memberof EmailThreadProjection
   */
  from?: string;
}

export function EmailThreadProjectionFromJSON(
  json: any
): EmailThreadProjection {
  return EmailThreadProjectionFromJSONTyped(json, false);
}

export function EmailThreadProjectionFromJSONTyped(
  json: any,
  ignoreDiscriminator: boolean
): EmailThreadProjection {
  if (json === undefined || json === null) {
    return json;
  }
  return {
    subject: !exists(json, 'subject') ? undefined : json['subject'],
    createdAt: new Date(json['createdAt']),
    updatedAt: new Date(json['updatedAt']),
    sender: !exists(json, 'sender')
      ? undefined
      : SenderProjectionFromJSON(json['sender']),
    recipients: !exists(json, 'recipients')
      ? undefined
      : EmailRecipientsProjectionFromJSON(json['recipients']),
    userId: json['userId'],
    inboxId: !exists(json, 'inboxId') ? undefined : json['inboxId'],
    to: json['to'],
    cc: !exists(json, 'cc') ? undefined : json['cc'],
    bcc: !exists(json, 'bcc') ? undefined : json['bcc'],
    hasAttachments: json['hasAttachments'],
    unread: json['unread'],
    messageCount: json['messageCount'],
    lastBodyExcerpt: !exists(json, 'lastBodyExcerpt')
      ? undefined
      : json['lastBodyExcerpt'],
    lastTextExcerpt: !exists(json, 'lastTextExcerpt')
      ? undefined
      : json['lastTextExcerpt'],
    lastCreatedAt: !exists(json, 'lastCreatedAt')
      ? undefined
      : new Date(json['lastCreatedAt']),
    lastFrom: !exists(json, 'lastFrom') ? undefined : json['lastFrom'],
    lastSender: !exists(json, 'lastSender')
      ? undefined
      : SenderProjectionFromJSON(json['lastSender']),
    id: json['id'],
    from: !exists(json, 'from') ? undefined : json['from'],
  };
}

export function EmailThreadProjectionToJSON(
  value?: EmailThreadProjection | null
): any {
  if (value === undefined) {
    return undefined;
  }
  if (value === null) {
    return null;
  }
  return {
    subject: value.subject,
    createdAt: value.createdAt.toISOString(),
    updatedAt: value.updatedAt.toISOString(),
    sender: SenderProjectionToJSON(value.sender),
    recipients: EmailRecipientsProjectionToJSON(value.recipients),
    userId: value.userId,
    inboxId: value.inboxId,
    to: value.to,
    cc: value.cc,
    bcc: value.bcc,
    hasAttachments: value.hasAttachments,
    unread: value.unread,
    messageCount: value.messageCount,
    lastBodyExcerpt: value.lastBodyExcerpt,
    lastTextExcerpt: value.lastTextExcerpt,
    lastCreatedAt:
      value.lastCreatedAt === undefined
        ? undefined
        : value.lastCreatedAt.toISOString(),
    lastFrom: value.lastFrom,
    lastSender: SenderProjectionToJSON(value.lastSender),
    id: value.id,
    from: value.from,
  };
}
