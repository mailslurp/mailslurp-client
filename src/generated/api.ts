/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * MailSlurp API
 * MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.   ## Resources - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://www.mailslurp.com/docs/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * OpenAPI spec version: 588e28c5bddf1cb7993de97e81314448f67acc34
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as url from 'url';
import * as portableFetch from 'portable-fetch';
import { Configuration } from './configuration';

const BASE_PATH = 'https://api.mailslurp.com'.replace(/\/+$/, '');

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ',',
    ssv: ' ',
    tsv: '\t',
    pipes: '|',
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(
        configuration?: Configuration,
        protected basePath: string = BASE_PATH,
        protected fetch: FetchAPI = portableFetch
    ) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: 'RequiredError';
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 *
 * @export
 * @interface Alias
 */
export interface Alias {
    /**
     *
     * @type {Date}
     * @memberof Alias
     */
    createdAt: Date;
    /**
     *
     * @type {string}
     * @memberof Alias
     */
    emailAddress: string;
    /**
     *
     * @type {string}
     * @memberof Alias
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof Alias
     */
    inboxId?: string;
    /**
     *
     * @type {string}
     * @memberof Alias
     */
    name?: string;
    /**
     *
     * @type {boolean}
     * @memberof Alias
     */
    proxied?: boolean;
    /**
     *
     * @type {Date}
     * @memberof Alias
     */
    updatedAt: Date;
    /**
     *
     * @type {string}
     * @memberof Alias
     */
    userId?: string;
}

/**
 * Meta data associated with an attachment. Attachments are stored as byte blobs so the meta data is stored separately.
 * @export
 * @interface AttachmentMetaData
 */
export interface AttachmentMetaData {
    /**
     * Size of attachment in bytes
     * @type {number}
     * @memberof AttachmentMetaData
     */
    contentLength?: number;
    /**
     * Content type of attachment
     * @type {string}
     * @memberof AttachmentMetaData
     */
    contentType?: string;
    /**
     * ID of attachment
     * @type {string}
     * @memberof AttachmentMetaData
     */
    id?: string;
    /**
     * Name of attachment
     * @type {string}
     * @memberof AttachmentMetaData
     */
    name?: string;
}

/**
 * Basic Authentication options for webhooks. Will be used is present when calling webhook endpoints.
 * @export
 * @interface BasicAuthOptions
 */
export interface BasicAuthOptions {
    /**
     *
     * @type {string}
     * @memberof BasicAuthOptions
     */
    username: string;
    /**
     *
     * @type {string}
     * @memberof BasicAuthOptions
     */
    password: string;
}

/**
 * Options for bulk sending an email from multiple addresses. See regular `sendEmail` methods for more information.
 * @export
 * @interface BulkSendEmailOptions
 */
export interface BulkSendEmailOptions {
    /**
     * Inboxes to send the email from
     * @type {Array<string>}
     * @memberof BulkSendEmailOptions
     */
    inboxIds?: Array<string>;
    /**
     * Options for the email to be sent
     * @type {SendEmailOptions}
     * @memberof BulkSendEmailOptions
     */
    sendEmailOptions?: SendEmailOptions;
}

/**
 *
 * @export
 * @interface ContactDto
 */
export interface ContactDto {
    /**
     *
     * @type {string}
     * @memberof ContactDto
     */
    company?: string;
    /**
     *
     * @type {Date}
     * @memberof ContactDto
     */
    createdAt: Date;
    /**
     *
     * @type {Array<string>}
     * @memberof ContactDto
     */
    emailAddresses: Array<string>;
    /**
     *
     * @type {string}
     * @memberof ContactDto
     */
    firstName?: string;
    /**
     *
     * @type {string}
     * @memberof ContactDto
     */
    groupId?: string;
    /**
     *
     * @type {string}
     * @memberof ContactDto
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof ContactDto
     */
    lastName?: string;
    /**
     *
     * @type {JsonNode}
     * @memberof ContactDto
     */
    metaData?: JsonNode;
    /**
     *
     * @type {boolean}
     * @memberof ContactDto
     */
    optOut?: boolean;
    /**
     *
     * @type {Array<string>}
     * @memberof ContactDto
     */
    tags: Array<string>;
}

/**
 *
 * @export
 * @interface ContactProjection
 */
export interface ContactProjection {
    /**
     *
     * @type {string}
     * @memberof ContactProjection
     */
    company?: string;
    /**
     *
     * @type {Date}
     * @memberof ContactProjection
     */
    createdAt: Date;
    /**
     *
     * @type {string}
     * @memberof ContactProjection
     */
    firstName?: string;
    /**
     *
     * @type {string}
     * @memberof ContactProjection
     */
    groupId?: string;
    /**
     *
     * @type {string}
     * @memberof ContactProjection
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof ContactProjection
     */
    lastName?: string;
    /**
     *
     * @type {boolean}
     * @memberof ContactProjection
     */
    optOut?: boolean;
}

/**
 * Create anonymous email alias options. Email aliases can be used to mask real email addresses behind an ID
 * @export
 * @interface CreateAnonymousAliasOptions
 */
export interface CreateAnonymousAliasOptions {
    /**
     * Email address to be hidden behind alias
     * @type {string}
     * @memberof CreateAnonymousAliasOptions
     */
    emailAddress?: string;
}

/**
 *
 * @export
 * @interface CreateContactOptions
 */
export interface CreateContactOptions {
    /**
     * Set of email addresses belonging to the contact
     * @type {Array<string>}
     * @memberof CreateContactOptions
     */
    emailAddresses?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof CreateContactOptions
     */
    firstName?: string;
    /**
     * Group IDs that contact belongs to
     * @type {string}
     * @memberof CreateContactOptions
     */
    groupId?: string;
    /**
     * User metadata key value pairs to save for this contact. Can be any values you like.
     * @type {JsonNode}
     * @memberof CreateContactOptions
     */
    metaData?: JsonNode;
    /**
     * Has the user explicitly or implicitly opted out of being contacted? If so MailSlurp will ignore them in all actions.
     * @type {boolean}
     * @memberof CreateContactOptions
     */
    optOut?: boolean;
    /**
     * Tags that can be used to search and group contacts
     * @type {Array<string>}
     * @memberof CreateContactOptions
     */
    tags?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof CreateContactOptions
     */
    lastName?: string;
    /**
     *
     * @type {string}
     * @memberof CreateContactOptions
     */
    company?: string;
}

/**
 * Options for creating a domain to use with MailSlurp. You must have ownership access to this domain in order to verify it.
 * @export
 * @interface CreateDomainOptions
 */
export interface CreateDomainOptions {
    /**
     * The top level domain you wish to use with MailSlurp
     * @type {string}
     * @memberof CreateDomainOptions
     */
    domain?: string;
}

/**
 *
 * @export
 * @interface CreateGroupOptions
 */
export interface CreateGroupOptions {
    /**
     *
     * @type {string}
     * @memberof CreateGroupOptions
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof CreateGroupOptions
     */
    description?: string;
}

/**
 * Create email alias options. Email aliases can be used to mask real email addresses behind an ID. You can also attach an inbox to an alias so that any email received by the inbox email address if forwarded to the alias email address.
 * @export
 * @interface CreateOwnedAliasOptions
 */
export interface CreateOwnedAliasOptions {
    /**
     * Email address to be hidden behind alias
     * @type {string}
     * @memberof CreateOwnedAliasOptions
     */
    emailAddress?: string;
    /**
     * Optional inbox ID to attach to alias. Emails received by this inbox will be forwarded to the alias email address
     * @type {string}
     * @memberof CreateOwnedAliasOptions
     */
    inboxId?: string;
    /**
     * Optional name for alias
     * @type {string}
     * @memberof CreateOwnedAliasOptions
     */
    name?: string;
    /**
     * Optional proxied flag. When proxied is true alias will forward the incoming emails to the aliased email address via a proxy inbox. A new proxy is created for every new email thread. By replying to the proxy you can correspond with using your email alias without revealing your real email address.
     * @type {boolean}
     * @memberof CreateOwnedAliasOptions
     */
    proxied?: boolean;
}

/**
 *
 * @export
 * @interface CreateTemplateOptions
 */
export interface CreateTemplateOptions {
    /**
     *
     * @type {string}
     * @memberof CreateTemplateOptions
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof CreateTemplateOptions
     */
    content: string;
}

/**
 * Options for creating a webhook. Webhooks can be attached to inboxes and MailSlurp will POST a webhook payload to the URL specified whenever the inbox receives an email. Webhooks are great for processing many inbound emails.
 * @export
 * @interface CreateWebhookOptions
 */
export interface CreateWebhookOptions {
    /**
     * Optional basic authentication that MailSlurp should use when calling the URL. For instance if your URL is https://example.com then basic auth will call a URL like https://{username}@{password}:example.com
     * @type {BasicAuthOptions}
     * @memberof CreateWebhookOptions
     */
    basicAuth?: BasicAuthOptions;
    /**
     * Optional name for the webhook
     * @type {string}
     * @memberof CreateWebhookOptions
     */
    name?: string;
    /**
     * Public URL on your server that MailSlurp can post WebhookNotification payload to when an email is received. The payload of the submitted JSON is described by https://api.mailslurp.com/schemas/webhook-payload
     * @type {string}
     * @memberof CreateWebhookOptions
     */
    url?: string;
}

/**
 *
 * @export
 * @interface DescribeDomainOptions
 */
export interface DescribeDomainOptions {
    /**
     *
     * @type {string}
     * @memberof DescribeDomainOptions
     */
    domain: string;
}

/**
 * Name Server lookup result
 * @export
 * @interface DescribeMailServerDomainResult
 */
export interface DescribeMailServerDomainResult {
    /**
     *
     * @type {string}
     * @memberof DescribeMailServerDomainResult
     */
    domain: string;
    /**
     *
     * @type {string}
     * @memberof DescribeMailServerDomainResult
     */
    message?: string;
    /**
     *
     * @type {Array<NameServerRecord>}
     * @memberof DescribeMailServerDomainResult
     */
    mxRecords: Array<NameServerRecord>;
}

/**
 * Domain plus verification records and status
 * @export
 * @interface DomainDto
 */
export interface DomainDto {
    /**
     *
     * @type {Date}
     * @memberof DomainDto
     */
    createdAt: Date;
    /**
     *
     * @type {string}
     * @memberof DomainDto
     */
    domain: string;
    /**
     *
     * @type {string}
     * @memberof DomainDto
     */
    id: string;
    /**
     *
     * @type {boolean}
     * @memberof DomainDto
     */
    isVerified: boolean;
    /**
     *
     * @type {Date}
     * @memberof DomainDto
     */
    updatedAt: Date;
    /**
     *
     * @type {string}
     * @memberof DomainDto
     */
    userId: string;
    /**
     *
     * @type {string}
     * @memberof DomainDto
     */
    verificationToken: string;
}

/**
 * Preview object for domain entity
 * @export
 * @interface DomainPreview
 */
export interface DomainPreview {
    /**
     *
     * @type {Date}
     * @memberof DomainPreview
     */
    createdAt: Date;
    /**
     *
     * @type {string}
     * @memberof DomainPreview
     */
    domain: string;
    /**
     *
     * @type {string}
     * @memberof DomainPreview
     */
    id: string;
}

/**
 * Content of attachment
 * @export
 * @interface DownloadAttachmentDto
 */
export interface DownloadAttachmentDto {
    /**
     * Base64 encoded string of attachment bytes. Decode the base64 string to get the raw file bytes
     * @type {string}
     * @memberof DownloadAttachmentDto
     */
    base64FileContents?: string;
    /**
     * Content type of attachment
     * @type {string}
     * @memberof DownloadAttachmentDto
     */
    contentType?: string;
    /**
     * Size in bytes of attachment
     * @type {number}
     * @memberof DownloadAttachmentDto
     */
    sizeBytes?: number;
}

/**
 * Email model (also referred to as EmailDto). Represents an email that was received by an inbox. If you want the original SMTP message see the `getRawEmail` endpoint.
 * @export
 * @interface Email
 */
export interface Email {
    /**
     * Smart analysis of email content including spam ratings\"
     * @type {EmailAnalysis}
     * @memberof Email
     */
    analysis?: EmailAnalysis;
    /**
     * List of IDs of attachments found in the email. Use these IDs with the Inbox and Email Controllers to download attachments and attachment meta data such as filesize, name, extension.
     * @type {Array<string>}
     * @memberof Email
     */
    attachments?: Array<string>;
    /**
     * List of `BCC` recipients email was addressed to
     * @type {Array<string>}
     * @memberof Email
     */
    bcc?: Array<string>;
    /**
     * The body of the email message
     * @type {string}
     * @memberof Email
     */
    body?: string;
    /**
     * A hash signature of the email message
     * @type {string}
     * @memberof Email
     */
    bodyMD5Hash?: string;
    /**
     * List of `CC` recipients email was addressed to
     * @type {Array<string>}
     * @memberof Email
     */
    cc?: Array<string>;
    /**
     * Detected character set of the email body such as UTF-8
     * @type {string}
     * @memberof Email
     */
    charset?: string;
    /**
     * When was the email received by MailSlurp
     * @type {Date}
     * @memberof Email
     */
    createdAt?: Date;
    /**
     * Who the email was sent from
     * @type {string}
     * @memberof Email
     */
    from?: string;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof Email
     */
    headers?: { [key: string]: string };
    /**
     * ID of the email
     * @type {string}
     * @memberof Email
     */
    id?: string;
    /**
     * ID of the inbox that received the email
     * @type {string}
     * @memberof Email
     */
    inboxId?: string;
    /**
     * Was HTML sent in the email body
     * @type {boolean}
     * @memberof Email
     */
    isHTML?: boolean;
    /**
     * Has the email been viewed ever
     * @type {boolean}
     * @memberof Email
     */
    read?: boolean;
    /**
     * The subject line of the email message
     * @type {string}
     * @memberof Email
     */
    subject?: string;
    /**
     * List of `To` recipients email was addressed to
     * @type {Array<string>}
     * @memberof Email
     */
    to?: Array<string>;
    /**
     * When was the email last updated
     * @type {Date}
     * @memberof Email
     */
    updatedAt?: Date;
    /**
     * ID of user that email belongs
     * @type {string}
     * @memberof Email
     */
    userId?: string;
}

/**
 * Analysis result for email. Each verdict property is a string PASS|FAIL|GRAY or dynamic error message
 * @export
 * @interface EmailAnalysis
 */
export interface EmailAnalysis {
    /**
     * Verdict of DomainKeys Identified Mail analysis
     * @type {string}
     * @memberof EmailAnalysis
     */
    dkimVerdict?: string;
    /**
     * Verdict of Domain-based Message Authentication Reporting and Conformance analysis
     * @type {string}
     * @memberof EmailAnalysis
     */
    dmarcVerdict?: string;
    /**
     * Verdict of spam ranking analysis
     * @type {string}
     * @memberof EmailAnalysis
     */
    spamVerdict?: string;
    /**
     * Verdict of Send Policy Framework record spoofing analysis
     * @type {string}
     * @memberof EmailAnalysis
     */
    spfVerdict?: string;
    /**
     * Verdict of virus scan analysis
     * @type {string}
     * @memberof EmailAnalysis
     */
    virusVerdict?: string;
}

/**
 * Preview of an email message. For full message (including body and attachments) call the `getEmail` or other email endpoints with the provided email ID.
 * @export
 * @interface EmailPreview
 */
export interface EmailPreview {
    /**
     * List of IDs of attachments found in the email. Use these IDs with the Inbox and Email Controllers to download attachments and attachment meta data such as filesize, name, extension.
     * @type {Array<string>}
     * @memberof EmailPreview
     */
    attachments?: Array<string>;
    /**
     * List of `BCC` recipients email was addressed to
     * @type {Array<string>}
     * @memberof EmailPreview
     */
    bcc?: Array<string>;
    /**
     * List of `CC` recipients email was addressed to
     * @type {Array<string>}
     * @memberof EmailPreview
     */
    cc?: Array<string>;
    /**
     * When was the email received by MailSlurp
     * @type {Date}
     * @memberof EmailPreview
     */
    createdAt?: Date;
    /**
     * Who the email was sent from
     * @type {string}
     * @memberof EmailPreview
     */
    from?: string;
    /**
     * ID of the email
     * @type {string}
     * @memberof EmailPreview
     */
    id?: string;
    /**
     * Has the email been viewed ever
     * @type {boolean}
     * @memberof EmailPreview
     */
    read?: boolean;
    /**
     * The subject line of the email message
     * @type {string}
     * @memberof EmailPreview
     */
    subject?: string;
    /**
     * List of `To` recipients email was addressed to
     * @type {Array<string>}
     * @memberof EmailPreview
     */
    to?: Array<string>;
}

/**
 * A compact representation of a full email. Used in list endpoints to keep response sizes low. Body and attachments are not included. To get all fields of the email use the `getEmail` method with the email projection's ID. See `EmailDto` for documentation on projection properties.
 * @export
 * @interface EmailProjection
 */
export interface EmailProjection {
    /**
     *
     * @type {Array<string>}
     * @memberof EmailProjection
     */
    attachments?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof EmailProjection
     */
    bcc?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof EmailProjection
     */
    bodyMD5Hash?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof EmailProjection
     */
    cc?: Array<string>;
    /**
     *
     * @type {Date}
     * @memberof EmailProjection
     */
    createdAt: Date;
    /**
     *
     * @type {string}
     * @memberof EmailProjection
     */
    from?: string;
    /**
     *
     * @type {string}
     * @memberof EmailProjection
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof EmailProjection
     */
    inboxId: string;
    /**
     *
     * @type {boolean}
     * @memberof EmailProjection
     */
    read?: boolean;
    /**
     *
     * @type {string}
     * @memberof EmailProjection
     */
    subject?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof EmailProjection
     */
    to: Array<string>;
}

/**
 * Email verification result. Valid means email address exists according to response from mail server running at the domian and port given.
 * @export
 * @interface EmailVerificationResult
 */
export interface EmailVerificationResult {
    /**
     *
     * @type {string}
     * @memberof EmailVerificationResult
     */
    domainName: string;
    /**
     *
     * @type {string}
     * @memberof EmailVerificationResult
     */
    emailAddress: string;
    /**
     *
     * @type {string}
     * @memberof EmailVerificationResult
     */
    error?: string;
    /**
     *
     * @type {boolean}
     * @memberof EmailVerificationResult
     */
    isValid: boolean;
    /**
     *
     * @type {number}
     * @memberof EmailVerificationResult
     */
    port: number;
}

/**
 * Options for forwarding an email
 * @export
 * @interface ForwardEmailOptions
 */
export interface ForwardEmailOptions {
    /**
     * Optional bcc recipients
     * @type {Array<string>}
     * @memberof ForwardEmailOptions
     */
    bcc?: Array<string>;
    /**
     * Optional cc recipients
     * @type {Array<string>}
     * @memberof ForwardEmailOptions
     */
    cc?: Array<string>;
    /**
     * Subject for forwarded email
     * @type {string}
     * @memberof ForwardEmailOptions
     */
    subject?: string;
    /**
     * To recipients for forwarded email
     * @type {Array<string>}
     * @memberof ForwardEmailOptions
     */
    to?: Array<string>;
}

/**
 *
 * @export
 * @interface GroupContactsDto
 */
export interface GroupContactsDto {
    /**
     *
     * @type {Array<ContactDto>}
     * @memberof GroupContactsDto
     */
    contacts: Array<ContactDto>;
    /**
     *
     * @type {GroupDto}
     * @memberof GroupContactsDto
     */
    group: GroupDto;
}

/**
 *
 * @export
 * @interface GroupDto
 */
export interface GroupDto {
    /**
     *
     * @type {Date}
     * @memberof GroupDto
     */
    createdAt: Date;
    /**
     *
     * @type {string}
     * @memberof GroupDto
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof GroupDto
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof GroupDto
     */
    name: string;
}

/**
 *
 * @export
 * @interface GroupProjection
 */
export interface GroupProjection {
    /**
     *
     * @type {Date}
     * @memberof GroupProjection
     */
    createdAt: Date;
    /**
     *
     * @type {string}
     * @memberof GroupProjection
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof GroupProjection
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof GroupProjection
     */
    name: string;
}

/**
 * HTML Validation Results
 * @export
 * @interface HTMLValidationResult
 */
export interface HTMLValidationResult {
    /**
     *
     * @type {Array<ValidationMessage>}
     * @memberof HTMLValidationResult
     */
    errors: Array<ValidationMessage>;
    /**
     *
     * @type {boolean}
     * @memberof HTMLValidationResult
     */
    isValid: boolean;
    /**
     *
     * @type {Array<ValidationMessage>}
     * @memberof HTMLValidationResult
     */
    warnings: Array<ValidationMessage>;
}

/**
 * Representation of an inbox with an email address. Emails can be sent to or from this email address.
 * @export
 * @interface Inbox
 */
export interface Inbox {
    /**
     * When was the inbox created
     * @type {Date}
     * @memberof Inbox
     */
    createdAt?: Date;
    /**
     * Optional description of an inbox for labelling purposes
     * @type {string}
     * @memberof Inbox
     */
    description?: string;
    /**
     * The inbox's email address. Send an email to this address and the inbox will receive and store it for you. To retrieve the email use the Inbox and Email Controller endpoints.
     * @type {string}
     * @memberof Inbox
     */
    emailAddress?: string;
    /**
     * When, if ever, will the inbox expire and be deleted. If null then this inbox is permanent and the emails in it won't be deleted. Timestamp passed as string.
     * @type {string}
     * @memberof Inbox
     */
    expiresAt?: string;
    /**
     * Is the inbox favourited
     * @type {boolean}
     * @memberof Inbox
     */
    favourite?: boolean;
    /**
     * ID of the inbox
     * @type {string}
     * @memberof Inbox
     */
    id?: string;
    /**
     * Optional name of the inbox. Displayed in the dashboard for easier search
     * @type {string}
     * @memberof Inbox
     */
    name?: string;
    /**
     * Tags that inbox has been tagged with
     * @type {Array<string>}
     * @memberof Inbox
     */
    tags?: Array<string>;
    /**
     * ID of user that inbox belongs to
     * @type {string}
     * @memberof Inbox
     */
    userId?: string;
}

/**
 *
 * @export
 * @interface InboxProjection
 */
export interface InboxProjection {
    /**
     *
     * @type {Date}
     * @memberof InboxProjection
     */
    createdAt: Date;
    /**
     *
     * @type {string}
     * @memberof InboxProjection
     */
    emailAddress?: string;
    /**
     *
     * @type {boolean}
     * @memberof InboxProjection
     */
    favourite: boolean;
    /**
     *
     * @type {string}
     * @memberof InboxProjection
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof InboxProjection
     */
    name?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof InboxProjection
     */
    tags?: Array<string>;
}

/**
 *
 * @export
 * @interface JsonNode
 */
export interface JsonNode {}

/**
 * Options for matching emails in an inbox. Each match option object contains a `field`, `should` and `value` property. Together they form logical conditions such as `SUBJECT` should `CONTAIN` value.
 * @export
 * @interface MatchOption
 */
export interface MatchOption {
    /**
     * The email property to match on. One of SUBJECT, TO, BCC, CC or FROM
     * @type {string}
     * @memberof MatchOption
     */
    field?: MatchOption.FieldEnum;
    /**
     * What criteria to apply. CONTAIN or EQUAL. Note CONTAIN is recommended due to some SMTP servers adding new lines to fields and body content.
     * @type {string}
     * @memberof MatchOption
     */
    should?: MatchOption.ShouldEnum;
    /**
     * The value you wish to compare with the value of the field specified using the `should` value passed. For example `BODY` should `CONTAIN` a value passed.
     * @type {string}
     * @memberof MatchOption
     */
    value?: string;
}

/**
 * @export
 * @namespace MatchOption
 */
export namespace MatchOption {
    /**
     * @export
     * @enum {string}
     */
    export enum FieldEnum {
        SUBJECT = <any>'SUBJECT',
        TO = <any>'TO',
        BCC = <any>'BCC',
        CC = <any>'CC',
        FROM = <any>'FROM',
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ShouldEnum {
        CONTAIN = <any>'CONTAIN',
        EQUAL = <any>'EQUAL',
    }
}

/**
 * Optional filter for matching emails based on fields. For instance filter results to only include emails whose `SUBJECT` value does `CONTAIN` given match value.
 * @export
 * @interface MatchOptions
 */
export interface MatchOptions {
    /**
     * 1 or more match options. Options are additive so if one does not match the email is excluded from results
     * @type {Array<MatchOption>}
     * @memberof MatchOptions
     */
    matches?: Array<MatchOption>;
}

/**
 * Name Server Record
 * @export
 * @interface NameServerRecord
 */
export interface NameServerRecord {
    /**
     *
     * @type {string}
     * @memberof NameServerRecord
     */
    priority: string;
    /**
     *
     * @type {string}
     * @memberof NameServerRecord
     */
    raw: string;
    /**
     *
     * @type {string}
     * @memberof NameServerRecord
     */
    recordType: string;
    /**
     *
     * @type {string}
     * @memberof NameServerRecord
     */
    value: string;
}

/**
 * Paginated email alias results. Page index starts at zero. Projection results may omit larger entity fields. For fetching a full inbox entity use the projection ID with individual method calls.
 * @export
 * @interface PageAlias
 */
export interface PageAlias {
    /**
     *
     * @type {Array<Alias>}
     * @memberof PageAlias
     */
    content?: Array<Alias>;
    /**
     *
     * @type {boolean}
     * @memberof PageAlias
     */
    empty?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageAlias
     */
    first?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageAlias
     */
    last?: boolean;
    /**
     *
     * @type {number}
     * @memberof PageAlias
     */
    number?: number;
    /**
     *
     * @type {number}
     * @memberof PageAlias
     */
    numberOfElements?: number;
    /**
     *
     * @type {Pageable}
     * @memberof PageAlias
     */
    pageable?: Pageable;
    /**
     *
     * @type {number}
     * @memberof PageAlias
     */
    size?: number;
    /**
     *
     * @type {Sort}
     * @memberof PageAlias
     */
    sort?: Sort;
    /**
     *
     * @type {number}
     * @memberof PageAlias
     */
    totalElements?: number;
    /**
     *
     * @type {number}
     * @memberof PageAlias
     */
    totalPages?: number;
}

/**
 * Paginated contact results. Page index starts at zero. Projection results may omit larger entity fields. For fetching a full inbox entity use the projection ID with individual method calls.
 * @export
 * @interface PageContactProjection
 */
export interface PageContactProjection {
    /**
     *
     * @type {Array<ContactProjection>}
     * @memberof PageContactProjection
     */
    content?: Array<ContactProjection>;
    /**
     *
     * @type {boolean}
     * @memberof PageContactProjection
     */
    empty?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageContactProjection
     */
    first?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageContactProjection
     */
    last?: boolean;
    /**
     *
     * @type {number}
     * @memberof PageContactProjection
     */
    number?: number;
    /**
     *
     * @type {number}
     * @memberof PageContactProjection
     */
    numberOfElements?: number;
    /**
     *
     * @type {Pageable}
     * @memberof PageContactProjection
     */
    pageable?: Pageable;
    /**
     *
     * @type {number}
     * @memberof PageContactProjection
     */
    size?: number;
    /**
     *
     * @type {Sort}
     * @memberof PageContactProjection
     */
    sort?: Sort;
    /**
     *
     * @type {number}
     * @memberof PageContactProjection
     */
    totalElements?: number;
    /**
     *
     * @type {number}
     * @memberof PageContactProjection
     */
    totalPages?: number;
}

/**
 * Paginated email preview results. EmailProjections and EmailPreviews are essentially the same but have legacy naming issues. Page index starts at zero. Projection results may omit larger entity fields. For fetching a full entity use the projection ID with individual method calls. For emails there are several methods for fetching message bodies and attachments.
 * @export
 * @interface PageEmailPreview
 */
export interface PageEmailPreview {
    /**
     *
     * @type {Array<EmailPreview>}
     * @memberof PageEmailPreview
     */
    content?: Array<EmailPreview>;
    /**
     *
     * @type {boolean}
     * @memberof PageEmailPreview
     */
    empty?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageEmailPreview
     */
    first?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageEmailPreview
     */
    last?: boolean;
    /**
     *
     * @type {number}
     * @memberof PageEmailPreview
     */
    number?: number;
    /**
     *
     * @type {number}
     * @memberof PageEmailPreview
     */
    numberOfElements?: number;
    /**
     *
     * @type {Pageable}
     * @memberof PageEmailPreview
     */
    pageable?: Pageable;
    /**
     *
     * @type {number}
     * @memberof PageEmailPreview
     */
    size?: number;
    /**
     *
     * @type {Sort}
     * @memberof PageEmailPreview
     */
    sort?: Sort;
    /**
     *
     * @type {number}
     * @memberof PageEmailPreview
     */
    totalElements?: number;
    /**
     *
     * @type {number}
     * @memberof PageEmailPreview
     */
    totalPages?: number;
}

/**
 * Paginated email projection results. EmailProjections and EmailPreviews are essentially the same but have legacy naming issues. Page index starts at zero. Projection results may omit larger entity fields. For fetching a full email entity use the projection ID with individual method calls. For emails there are several methods for fetching message bodies and attachments.
 * @export
 * @interface PageEmailProjection
 */
export interface PageEmailProjection {
    /**
     *
     * @type {Array<EmailProjection>}
     * @memberof PageEmailProjection
     */
    content?: Array<EmailProjection>;
    /**
     *
     * @type {boolean}
     * @memberof PageEmailProjection
     */
    empty?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageEmailProjection
     */
    first?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageEmailProjection
     */
    last?: boolean;
    /**
     *
     * @type {number}
     * @memberof PageEmailProjection
     */
    number?: number;
    /**
     *
     * @type {number}
     * @memberof PageEmailProjection
     */
    numberOfElements?: number;
    /**
     *
     * @type {Pageable}
     * @memberof PageEmailProjection
     */
    pageable?: Pageable;
    /**
     *
     * @type {number}
     * @memberof PageEmailProjection
     */
    size?: number;
    /**
     *
     * @type {Sort}
     * @memberof PageEmailProjection
     */
    sort?: Sort;
    /**
     *
     * @type {number}
     * @memberof PageEmailProjection
     */
    totalElements?: number;
    /**
     *
     * @type {number}
     * @memberof PageEmailProjection
     */
    totalPages?: number;
}

/**
 * Paginated contact group results. Page index starts at zero. Projection results may omit larger entity fields. For fetching a full inbox entity use the projection ID with individual method calls.
 * @export
 * @interface PageGroupProjection
 */
export interface PageGroupProjection {
    /**
     *
     * @type {Array<GroupProjection>}
     * @memberof PageGroupProjection
     */
    content?: Array<GroupProjection>;
    /**
     *
     * @type {boolean}
     * @memberof PageGroupProjection
     */
    empty?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageGroupProjection
     */
    first?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageGroupProjection
     */
    last?: boolean;
    /**
     *
     * @type {number}
     * @memberof PageGroupProjection
     */
    number?: number;
    /**
     *
     * @type {number}
     * @memberof PageGroupProjection
     */
    numberOfElements?: number;
    /**
     *
     * @type {Pageable}
     * @memberof PageGroupProjection
     */
    pageable?: Pageable;
    /**
     *
     * @type {number}
     * @memberof PageGroupProjection
     */
    size?: number;
    /**
     *
     * @type {Sort}
     * @memberof PageGroupProjection
     */
    sort?: Sort;
    /**
     *
     * @type {number}
     * @memberof PageGroupProjection
     */
    totalElements?: number;
    /**
     *
     * @type {number}
     * @memberof PageGroupProjection
     */
    totalPages?: number;
}

/**
 * Paginated inbox results. Page index starts at zero. Projection results may omit larger entity fields. For fetching a full inbox entity use the projection ID with individual method calls.
 * @export
 * @interface PageInboxProjection
 */
export interface PageInboxProjection {
    /**
     *
     * @type {Array<InboxProjection>}
     * @memberof PageInboxProjection
     */
    content?: Array<InboxProjection>;
    /**
     *
     * @type {boolean}
     * @memberof PageInboxProjection
     */
    empty?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageInboxProjection
     */
    first?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageInboxProjection
     */
    last?: boolean;
    /**
     *
     * @type {number}
     * @memberof PageInboxProjection
     */
    number?: number;
    /**
     *
     * @type {number}
     * @memberof PageInboxProjection
     */
    numberOfElements?: number;
    /**
     *
     * @type {Pageable}
     * @memberof PageInboxProjection
     */
    pageable?: Pageable;
    /**
     *
     * @type {number}
     * @memberof PageInboxProjection
     */
    size?: number;
    /**
     *
     * @type {Sort}
     * @memberof PageInboxProjection
     */
    sort?: Sort;
    /**
     *
     * @type {number}
     * @memberof PageInboxProjection
     */
    totalElements?: number;
    /**
     *
     * @type {number}
     * @memberof PageInboxProjection
     */
    totalPages?: number;
}

/**
 * Paginated sent email results. Page index starts at zero. Projection results may omit larger entity fields. For fetching a full sent email entity use the projection ID with individual method calls.
 * @export
 * @interface PageSentEmailProjection
 */
export interface PageSentEmailProjection {
    /**
     *
     * @type {Array<SentEmailProjection>}
     * @memberof PageSentEmailProjection
     */
    content?: Array<SentEmailProjection>;
    /**
     *
     * @type {boolean}
     * @memberof PageSentEmailProjection
     */
    empty?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageSentEmailProjection
     */
    first?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageSentEmailProjection
     */
    last?: boolean;
    /**
     *
     * @type {number}
     * @memberof PageSentEmailProjection
     */
    number?: number;
    /**
     *
     * @type {number}
     * @memberof PageSentEmailProjection
     */
    numberOfElements?: number;
    /**
     *
     * @type {Pageable}
     * @memberof PageSentEmailProjection
     */
    pageable?: Pageable;
    /**
     *
     * @type {number}
     * @memberof PageSentEmailProjection
     */
    size?: number;
    /**
     *
     * @type {Sort}
     * @memberof PageSentEmailProjection
     */
    sort?: Sort;
    /**
     *
     * @type {number}
     * @memberof PageSentEmailProjection
     */
    totalElements?: number;
    /**
     *
     * @type {number}
     * @memberof PageSentEmailProjection
     */
    totalPages?: number;
}

/**
 * Paginated email template results. Page index starts at zero. Projection results may omit larger entity fields. For fetching a full inbox entity use the projection ID with individual method calls.
 * @export
 * @interface PageTemplateProjection
 */
export interface PageTemplateProjection {
    /**
     *
     * @type {Array<TemplateProjection>}
     * @memberof PageTemplateProjection
     */
    content?: Array<TemplateProjection>;
    /**
     *
     * @type {boolean}
     * @memberof PageTemplateProjection
     */
    empty?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageTemplateProjection
     */
    first?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageTemplateProjection
     */
    last?: boolean;
    /**
     *
     * @type {number}
     * @memberof PageTemplateProjection
     */
    number?: number;
    /**
     *
     * @type {number}
     * @memberof PageTemplateProjection
     */
    numberOfElements?: number;
    /**
     *
     * @type {Pageable}
     * @memberof PageTemplateProjection
     */
    pageable?: Pageable;
    /**
     *
     * @type {number}
     * @memberof PageTemplateProjection
     */
    size?: number;
    /**
     *
     * @type {Sort}
     * @memberof PageTemplateProjection
     */
    sort?: Sort;
    /**
     *
     * @type {number}
     * @memberof PageTemplateProjection
     */
    totalElements?: number;
    /**
     *
     * @type {number}
     * @memberof PageTemplateProjection
     */
    totalPages?: number;
}

/**
 * Paginated webhook results. Page index starts at zero. Projection results may omit larger entity fields. For fetching a full inbox entity use the projection ID with individual method calls.
 * @export
 * @interface PageWebhookProjection
 */
export interface PageWebhookProjection {
    /**
     *
     * @type {Array<WebhookProjection>}
     * @memberof PageWebhookProjection
     */
    content?: Array<WebhookProjection>;
    /**
     *
     * @type {boolean}
     * @memberof PageWebhookProjection
     */
    empty?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageWebhookProjection
     */
    first?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageWebhookProjection
     */
    last?: boolean;
    /**
     *
     * @type {number}
     * @memberof PageWebhookProjection
     */
    number?: number;
    /**
     *
     * @type {number}
     * @memberof PageWebhookProjection
     */
    numberOfElements?: number;
    /**
     *
     * @type {Pageable}
     * @memberof PageWebhookProjection
     */
    pageable?: Pageable;
    /**
     *
     * @type {number}
     * @memberof PageWebhookProjection
     */
    size?: number;
    /**
     *
     * @type {Sort}
     * @memberof PageWebhookProjection
     */
    sort?: Sort;
    /**
     *
     * @type {number}
     * @memberof PageWebhookProjection
     */
    totalElements?: number;
    /**
     *
     * @type {number}
     * @memberof PageWebhookProjection
     */
    totalPages?: number;
}

/**
 *
 * @export
 * @interface Pageable
 */
export interface Pageable {
    /**
     *
     * @type {number}
     * @memberof Pageable
     */
    offset?: number;
    /**
     *
     * @type {number}
     * @memberof Pageable
     */
    pageNumber?: number;
    /**
     *
     * @type {number}
     * @memberof Pageable
     */
    pageSize?: number;
    /**
     *
     * @type {boolean}
     * @memberof Pageable
     */
    paged?: boolean;
    /**
     *
     * @type {Sort}
     * @memberof Pageable
     */
    sort?: Sort;
    /**
     *
     * @type {boolean}
     * @memberof Pageable
     */
    unpaged?: boolean;
}

/**
 *
 * @export
 * @interface RawEmailJson
 */
export interface RawEmailJson {
    /**
     *
     * @type {string}
     * @memberof RawEmailJson
     */
    content: string;
}

/**
 * Options for sending an email message from an inbox. You must provide one of: `to`, `toGroup`, or `toContacts` to send an email. All other parameters are optional.
 * @export
 * @interface SendEmailOptions
 */
export interface SendEmailOptions {
    /**
     * Optional list of attachment IDs to send with this email. You must first upload each attachment separately in order to obtain attachment IDs. This way you can reuse attachments with different emails once uploaded.
     * @type {Array<string>}
     * @memberof SendEmailOptions
     */
    attachments?: Array<string>;
    /**
     * Optional list of bcc destination email addresses
     * @type {Array<string>}
     * @memberof SendEmailOptions
     */
    bcc?: Array<string>;
    /**
     * Optional contents of email. If body contains HTML then set `isHTML` to true to ensure that email clients render it correctly. You can use moustache template syntax in the email body in conjunction with `toGroup` contact variables or `templateVariables` data. If you need more templating control consider creating a template and using the `template` property instead of the body.
     * @type {string}
     * @memberof SendEmailOptions
     */
    body?: string;
    /**
     * Optional list of cc destination email addresses
     * @type {Array<string>}
     * @memberof SendEmailOptions
     */
    cc?: Array<string>;
    /**
     * Optional charset
     * @type {string}
     * @memberof SendEmailOptions
     */
    charset?: string;
    /**
     * Optional from address. If not set the source inbox address will be used for this field. Beware of potential spam penalties when setting this field to an address not used by the inbox. For custom email addresses use a custom domain.
     * @type {string}
     * @memberof SendEmailOptions
     */
    from?: string;
    /**
     * Optional HTML flag. If true the `content-type` of the email will be `text/html`. Set to true when sending HTML to ensure proper rending on email clients
     * @type {boolean}
     * @memberof SendEmailOptions
     */
    isHTML?: boolean;
    /**
     * Optional replyTo header
     * @type {string}
     * @memberof SendEmailOptions
     */
    replyTo?: string;
    /**
     * Optional strategy to use when sending the email
     * @type {string}
     * @memberof SendEmailOptions
     */
    sendStrategy?: SendEmailOptions.SendStrategyEnum;
    /**
     * Optional email subject line
     * @type {string}
     * @memberof SendEmailOptions
     */
    subject?: string;
    /**
     * Optional template ID to use for body. Will override body if provided. When using a template make sure you pass the corresponding map of `templateVariables`. You can find which variables are needed by fetching the template itself or viewing it in the dashboard.
     * @type {string}
     * @memberof SendEmailOptions
     */
    template?: string;
    /**
     * Optional map of template variables. Will replace moustache syntax variables in subject and body or template with the associated values if found.
     * @type {any}
     * @memberof SendEmailOptions
     */
    templateVariables?: any;
    /**
     * List of destination email addresses. Even single recipients must be in array form. Maximum recipients per email depends on your plan. If you need to send many emails try using contacts or contact groups or use a non standard sendStrategy to ensure that spam filters are not triggered (many recipients in one email can affect your spam rating).
     * @type {Array<string>}
     * @memberof SendEmailOptions
     */
    to?: Array<string>;
    /**
     * Optional list of contact IDs to send email to. Manage your contacts via the API or dashboard. When contacts are used the email is sent to each contact separately so they will not see other recipients.
     * @type {Array<string>}
     * @memberof SendEmailOptions
     */
    toContacts?: Array<string>;
    /**
     * Optional contact group ID to send email to. You can create contacts and contact groups in the API or dashboard and use them for email campaigns. When contact groups are used the email is sent to each contact separately so they will not see other recipients
     * @type {string}
     * @memberof SendEmailOptions
     */
    toGroup?: string;
}

/**
 * @export
 * @namespace SendEmailOptions
 */
export namespace SendEmailOptions {
    /**
     * @export
     * @enum {string}
     */
    export enum SendStrategyEnum {
        SINGLEMESSAGE = <any>'SINGLE_MESSAGE',
    }
}

/**
 *
 * @export
 * @interface SentEmail
 */
export interface SentEmail {
    /**
     *
     * @type {Array<string>}
     * @memberof SentEmail
     */
    attachments?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof SentEmail
     */
    bcc?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof SentEmail
     */
    bodyMD5Hash?: string;
    /**
     *
     * @type {string}
     * @memberof SentEmail
     */
    bodyS3Key?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof SentEmail
     */
    cc?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof SentEmail
     */
    charset?: string;
    /**
     *
     * @type {Date}
     * @memberof SentEmail
     */
    createdAt: Date;
    /**
     *
     * @type {string}
     * @memberof SentEmail
     */
    from?: string;
    /**
     *
     * @type {string}
     * @memberof SentEmail
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof SentEmail
     */
    inboxId: string;
    /**
     *
     * @type {boolean}
     * @memberof SentEmail
     */
    isHTML?: boolean;
    /**
     *
     * @type {string}
     * @memberof SentEmail
     */
    subject?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof SentEmail
     */
    to?: Array<string>;
    /**
     *
     * @type {Date}
     * @memberof SentEmail
     */
    updatedAt: Date;
    /**
     *
     * @type {string}
     * @memberof SentEmail
     */
    userId: string;
}

/**
 *
 * @export
 * @interface SentEmailDto
 */
export interface SentEmailDto {
    /**
     *
     * @type {Array<string>}
     * @memberof SentEmailDto
     */
    attachments?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof SentEmailDto
     */
    bcc?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof SentEmailDto
     */
    body?: string;
    /**
     *
     * @type {string}
     * @memberof SentEmailDto
     */
    bodyMD5Hash?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof SentEmailDto
     */
    cc?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof SentEmailDto
     */
    charset?: string;
    /**
     *
     * @type {string}
     * @memberof SentEmailDto
     */
    from?: string;
    /**
     *
     * @type {string}
     * @memberof SentEmailDto
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof SentEmailDto
     */
    inboxId: string;
    /**
     *
     * @type {boolean}
     * @memberof SentEmailDto
     */
    isHTML?: boolean;
    /**
     *
     * @type {Date}
     * @memberof SentEmailDto
     */
    sentAt: Date;
    /**
     *
     * @type {string}
     * @memberof SentEmailDto
     */
    subject?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof SentEmailDto
     */
    to?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof SentEmailDto
     */
    userId: string;
}

/**
 *
 * @export
 * @interface SentEmailProjection
 */
export interface SentEmailProjection {
    /**
     *
     * @type {Array<string>}
     * @memberof SentEmailProjection
     */
    attachments: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof SentEmailProjection
     */
    bcc: Array<string>;
    /**
     *
     * @type {string}
     * @memberof SentEmailProjection
     */
    bodyMD5Hash?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof SentEmailProjection
     */
    cc: Array<string>;
    /**
     *
     * @type {Date}
     * @memberof SentEmailProjection
     */
    createdAt: Date;
    /**
     *
     * @type {string}
     * @memberof SentEmailProjection
     */
    from?: string;
    /**
     *
     * @type {string}
     * @memberof SentEmailProjection
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof SentEmailProjection
     */
    inboxId: string;
    /**
     *
     * @type {string}
     * @memberof SentEmailProjection
     */
    subject?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof SentEmailProjection
     */
    to: Array<string>;
    /**
     *
     * @type {string}
     * @memberof SentEmailProjection
     */
    userId: string;
}

/**
 * Options for setting inbox favourite state
 * @export
 * @interface SetInboxFavouritedOptions
 */
export interface SetInboxFavouritedOptions {
    /**
     * Should the inbox be favourited?
     * @type {boolean}
     * @memberof SetInboxFavouritedOptions
     */
    state?: boolean;
}

/**
 *
 * @export
 * @interface SimpleSendEmailOptions
 */
export interface SimpleSendEmailOptions {
    /**
     * Body of the email message. Supports HTML
     * @type {string}
     * @memberof SimpleSendEmailOptions
     */
    body?: string;
    /**
     * ID of inbox to send from
     * @type {string}
     * @memberof SimpleSendEmailOptions
     */
    senderId?: string;
    /**
     * Subject line of the email
     * @type {string}
     * @memberof SimpleSendEmailOptions
     */
    subject?: string;
    /**
     * Email address to send to
     * @type {string}
     * @memberof SimpleSendEmailOptions
     */
    to?: string;
}

/**
 *
 * @export
 * @interface Sort
 */
export interface Sort {
    /**
     *
     * @type {boolean}
     * @memberof Sort
     */
    empty?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof Sort
     */
    sorted?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof Sort
     */
    unsorted?: boolean;
}

/**
 *
 * @export
 * @interface TemplateDto
 */
export interface TemplateDto {
    /**
     *
     * @type {string}
     * @memberof TemplateDto
     */
    content: string;
    /**
     *
     * @type {Date}
     * @memberof TemplateDto
     */
    createdAt: Date;
    /**
     *
     * @type {string}
     * @memberof TemplateDto
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof TemplateDto
     */
    name: string;
    /**
     *
     * @type {Array<TemplateVariable>}
     * @memberof TemplateDto
     */
    variables: Array<TemplateVariable>;
}

/**
 *
 * @export
 * @interface TemplateProjection
 */
export interface TemplateProjection {
    /**
     *
     * @type {Date}
     * @memberof TemplateProjection
     */
    createdAt: Date;
    /**
     *
     * @type {string}
     * @memberof TemplateProjection
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof TemplateProjection
     */
    name: string;
    /**
     *
     * @type {Date}
     * @memberof TemplateProjection
     */
    updatedAt: Date;
    /**
     *
     * @type {Array<string>}
     * @memberof TemplateProjection
     */
    variables: Array<string>;
}

/**
 *
 * @export
 * @interface TemplateVariable
 */
export interface TemplateVariable {
    /**
     *
     * @type {string}
     * @memberof TemplateVariable
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof TemplateVariable
     */
    variableType: TemplateVariable.VariableTypeEnum;
}

/**
 * @export
 * @namespace TemplateVariable
 */
export namespace TemplateVariable {
    /**
     * @export
     * @enum {string}
     */
    export enum VariableTypeEnum {
        STRING = <any>'STRING',
    }
}

/**
 *
 * @export
 * @interface UnreadCount
 */
export interface UnreadCount {
    /**
     *
     * @type {number}
     * @memberof UnreadCount
     */
    count: number;
}

/**
 *
 * @export
 * @interface UpdateGroupContacts
 */
export interface UpdateGroupContacts {
    /**
     *
     * @type {Array<string>}
     * @memberof UpdateGroupContacts
     */
    contactIds: Array<string>;
}

/**
 * Options for updating inbox properties
 * @export
 * @interface UpdateInboxOptions
 */
export interface UpdateInboxOptions {
    /**
     * Optional description of an inbox for labelling purposes
     * @type {string}
     * @memberof UpdateInboxOptions
     */
    description?: string;
    /**
     * When, if ever, will the inbox expire and be deleted. If null then this inbox is permanent and the emails in it won't be deleted. Timestamp passed as string.
     * @type {Date}
     * @memberof UpdateInboxOptions
     */
    expiresAt?: Date;
    /**
     * Is the inbox favourited
     * @type {boolean}
     * @memberof UpdateInboxOptions
     */
    favourite?: boolean;
    /**
     * Optional name of the inbox. Displayed in the dashboard for easier search
     * @type {string}
     * @memberof UpdateInboxOptions
     */
    name?: string;
    /**
     * Tags that inbox has been tagged with
     * @type {Array<string>}
     * @memberof UpdateInboxOptions
     */
    tags?: Array<string>;
}

/**
 * Options for uploading files for attachments. When sending emails with the API that require attachments first upload each attachment. Then use the returned attachment ID in your `SendEmailOptions` when sending an email. This way you can use attachments multiple times once they have been uploaded.
 * @export
 * @interface UploadAttachmentOptions
 */
export interface UploadAttachmentOptions {
    /**
     * Base64 encoded string of file contents. Typically this means reading the bytes or string content of a file and then converting that to a base64 encoded string.
     * @type {string}
     * @memberof UploadAttachmentOptions
     */
    base64Contents?: string;
    /**
     * Optional contentType for file. For instance `application/pdf`
     * @type {string}
     * @memberof UploadAttachmentOptions
     */
    contentType?: string;
    /**
     * Optional filename to save upload with
     * @type {string}
     * @memberof UploadAttachmentOptions
     */
    filename?: string;
}

/**
 * Response object for email validation operation
 * @export
 * @interface ValidationDto
 */
export interface ValidationDto {
    /**
     * ID of the email validated
     * @type {string}
     * @memberof ValidationDto
     */
    emailId?: string;
    /**
     * Result of HTML validation
     * @type {HTMLValidationResult}
     * @memberof ValidationDto
     */
    html?: HTMLValidationResult;
}

/**
 *
 * @export
 * @interface ValidationMessage
 */
export interface ValidationMessage {
    /**
     *
     * @type {number}
     * @memberof ValidationMessage
     */
    lineNumber: number;
    /**
     *
     * @type {string}
     * @memberof ValidationMessage
     */
    message?: string;
}

/**
 * Options for verifying that an email address exists at a remote mail server.
 * @export
 * @interface VerifyEmailAddressOptions
 */
export interface VerifyEmailAddressOptions {
    /**
     *
     * @type {string}
     * @memberof VerifyEmailAddressOptions
     */
    mailServerDomain?: string;
    /**
     *
     * @type {string}
     * @memberof VerifyEmailAddressOptions
     */
    emailAddress: string;
    /**
     *
     * @type {string}
     * @memberof VerifyEmailAddressOptions
     */
    senderEmailAddress?: string;
    /**
     *
     * @type {number}
     * @memberof VerifyEmailAddressOptions
     */
    port?: number;
}

/**
 * Conditions that a `waitForXEmails` endpoint operates on. The methods wait until given conditions are met or a timeout is reached. If the conditions are met without needing to wait the results will be returned immediately.
 * @export
 * @interface WaitForConditions
 */
export interface WaitForConditions {
    /**
     * Number of results that should match conditions. Either exactly or at least this amount based on the `countType`. If count condition is not met and the timeout has not been reached the `waitFor` method will retry the operation.
     * @type {number}
     * @memberof WaitForConditions
     */
    count?: number;
    /**
     * How should the found count be compared to the expected count.
     * @type {string}
     * @memberof WaitForConditions
     */
    countType?: WaitForConditions.CountTypeEnum;
    /**
     * ID of inbox to search within and apply conditions to. Essentially filtering the emails found to give a count.
     * @type {string}
     * @memberof WaitForConditions
     */
    inboxId?: string;
    /**
     * Conditions that should be matched for an email to qualify for results. Each condition will be applied in order to each email within an inbox to filter a result list of matching emails you are waiting for.
     * @type {Array<MatchOption>}
     * @memberof WaitForConditions
     */
    matches?: Array<MatchOption>;
    /**
     * Direction to sort matching emails by created time
     * @type {string}
     * @memberof WaitForConditions
     */
    sortDirection?: WaitForConditions.SortDirectionEnum;
    /**
     * Max time in milliseconds to retry the `waitFor` operation until conditions are met.
     * @type {number}
     * @memberof WaitForConditions
     */
    timeout?: number;
    /**
     * Apply conditions only to **unread** emails. All emails begin with `read=false`. An email is marked `read=true` when an `EmailDto` representation of it has been returned to the user at least once. For example you have called `getEmail` or `waitForLatestEmail` etc., or you have viewed the email in the dashboard.
     * @type {boolean}
     * @memberof WaitForConditions
     */
    unreadOnly?: boolean;
}

/**
 * @export
 * @namespace WaitForConditions
 */
export namespace WaitForConditions {
    /**
     * @export
     * @enum {string}
     */
    export enum CountTypeEnum {
        EXACTLY = <any>'EXACTLY',
        ATLEAST = <any>'ATLEAST',
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SortDirectionEnum {
        ASC = <any>'ASC',
        DESC = <any>'DESC',
    }
}

/**
 * Representation of a webhook for an inbox. The URL specified will be using by MailSlurp whenever an email is received by the attached inbox.
 * @export
 * @interface WebhookDto
 */
export interface WebhookDto {
    /**
     * Does webhook expect basic authentication? If true it means you created this webhook with a username and password. MailSlurp will use these in the URL to authenticate itself.
     * @type {boolean}
     * @memberof WebhookDto
     */
    basicAuth?: boolean;
    /**
     * When the webhook was created
     * @type {Date}
     * @memberof WebhookDto
     */
    createdAt?: Date;
    /**
     * ID of the Webhook
     * @type {string}
     * @memberof WebhookDto
     */
    id?: string;
    /**
     * The inbox that the Webhook will be triggered by
     * @type {string}
     * @memberof WebhookDto
     */
    inboxId?: string;
    /**
     * HTTP method that your server endpoint must listen for
     * @type {string}
     * @memberof WebhookDto
     */
    method?: WebhookDto.MethodEnum;
    /**
     * Name of the webhook
     * @type {string}
     * @memberof WebhookDto
     */
    name?: string;
    /**
     * JSON Schema for the payload that will be sent to your URL via the HTTP method described.
     * @type {string}
     * @memberof WebhookDto
     */
    payloadJsonSchema?: string;
    /**
     *
     * @type {Date}
     * @memberof WebhookDto
     */
    updatedAt: Date;
    /**
     * URL of your server that the webhook will be sent to. The schema of the JSON that is sent is described by the payloadJsonSchema.
     * @type {string}
     * @memberof WebhookDto
     */
    url?: string;
}

/**
 * @export
 * @namespace WebhookDto
 */
export namespace WebhookDto {
    /**
     * @export
     * @enum {string}
     */
    export enum MethodEnum {
        GET = <any>'GET',
        HEAD = <any>'HEAD',
        POST = <any>'POST',
        PUT = <any>'PUT',
        PATCH = <any>'PATCH',
        DELETE = <any>'DELETE',
        OPTIONS = <any>'OPTIONS',
        TRACE = <any>'TRACE',
    }
}

/**
 * Representation of a webhook
 * @export
 * @interface WebhookProjection
 */
export interface WebhookProjection {
    /**
     *
     * @type {Date}
     * @memberof WebhookProjection
     */
    createdAt: Date;
    /**
     *
     * @type {string}
     * @memberof WebhookProjection
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof WebhookProjection
     */
    inboxId: string;
    /**
     *
     * @type {string}
     * @memberof WebhookProjection
     */
    name?: string;
    /**
     *
     * @type {Date}
     * @memberof WebhookProjection
     */
    updatedAt: Date;
    /**
     *
     * @type {string}
     * @memberof WebhookProjection
     */
    url: string;
}

/**
 *
 * @export
 * @interface WebhookTestRequest
 */
export interface WebhookTestRequest {
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof WebhookTestRequest
     */
    headers: { [key: string]: string };
    /**
     *
     * @type {string}
     * @memberof WebhookTestRequest
     */
    method: WebhookTestRequest.MethodEnum;
    /**
     *
     * @type {string}
     * @memberof WebhookTestRequest
     */
    payload?: string;
    /**
     *
     * @type {string}
     * @memberof WebhookTestRequest
     */
    url: string;
}

/**
 * @export
 * @namespace WebhookTestRequest
 */
export namespace WebhookTestRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum MethodEnum {
        GET = <any>'GET',
        HEAD = <any>'HEAD',
        POST = <any>'POST',
        PUT = <any>'PUT',
        PATCH = <any>'PATCH',
        DELETE = <any>'DELETE',
        OPTIONS = <any>'OPTIONS',
        TRACE = <any>'TRACE',
    }
}

/**
 *
 * @export
 * @interface WebhookTestResponse
 */
export interface WebhookTestResponse {
    /**
     *
     * @type {string}
     * @memberof WebhookTestResponse
     */
    message?: string;
    /**
     *
     * @type {number}
     * @memberof WebhookTestResponse
     */
    statusCode?: number;
}

/**
 * Results of testing a webhook
 * @export
 * @interface WebhookTestResult
 */
export interface WebhookTestResult {
    /**
     *
     * @type {string}
     * @memberof WebhookTestResult
     */
    message?: string;
    /**
     *
     * @type {WebhookTestRequest}
     * @memberof WebhookTestResult
     */
    request: WebhookTestRequest;
    /**
     *
     * @type {WebhookTestResponse}
     * @memberof WebhookTestResult
     */
    response: WebhookTestResponse;
}

/**
 * AliasControllerApi - fetch parameter creator
 * @export
 */
export const AliasControllerApiFetchParamCreator = function(
    configuration?: Configuration
) {
    return {
        /**
         * Create an email alias belonging to a user ID. To create anonymous aliases use the `createAnonymousAlias` method.
         * @summary Create an email alias
         * @param {CreateOwnedAliasOptions} createOwnedAliasOptions createOwnedAliasOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlias(
            createOwnedAliasOptions: CreateOwnedAliasOptions,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'createOwnedAliasOptions' is not null or undefined
            if (
                createOwnedAliasOptions === null ||
                createOwnedAliasOptions === undefined
            ) {
                throw new RequiredError(
                    'createOwnedAliasOptions',
                    'Required parameter createOwnedAliasOptions was null or undefined when calling createAlias.'
                );
            }
            const localVarPath = `/aliases`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'CreateOwnedAliasOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(createOwnedAliasOptions || {})
                : createOwnedAliasOptions || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create an anonymous email alias
         * @param {CreateAnonymousAliasOptions} createAnonymousAliasOptions createAnonymousAliasOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnonymousAlias(
            createAnonymousAliasOptions: CreateAnonymousAliasOptions,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'createAnonymousAliasOptions' is not null or undefined
            if (
                createAnonymousAliasOptions === null ||
                createAnonymousAliasOptions === undefined
            ) {
                throw new RequiredError(
                    'createAnonymousAliasOptions',
                    'Required parameter createAnonymousAliasOptions was null or undefined when calling createAnonymousAlias.'
                );
            }
            const localVarPath = `/aliases/anonymous`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'CreateAnonymousAliasOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(createAnonymousAliasOptions || {})
                : createAnonymousAliasOptions || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete an owned alias
         * @param {string} aliasId aliasId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlias(aliasId: string, options: any = {}): FetchArgs {
            // verify required parameter 'aliasId' is not null or undefined
            if (aliasId === null || aliasId === undefined) {
                throw new RequiredError(
                    'aliasId',
                    'Required parameter aliasId was null or undefined when calling deleteAlias.'
                );
            }
            const localVarPath = `/aliases/{aliasId}`.replace(
                `{${'aliasId'}}`,
                encodeURIComponent(String(aliasId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'DELETE' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an email alias by ID
         * @summary Get an email alias
         * @param {string} aliasId aliasId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlias(aliasId: string, options: any = {}): FetchArgs {
            // verify required parameter 'aliasId' is not null or undefined
            if (aliasId === null || aliasId === undefined) {
                throw new RequiredError(
                    'aliasId',
                    'Required parameter aliasId was null or undefined when calling getAlias.'
                );
            }
            const localVarPath = `/aliases/{aliasId}`.replace(
                `{${'aliasId'}}`,
                encodeURIComponent(String(aliasId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all email aliases in paginated form
         * @summary Get all email aliases
         * @param {number} [page] Optional page index in alias list pagination
         * @param {number} [size] Optional page size in alias list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAliases(
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options: any = {}
        ): FetchArgs {
            const localVarPath = `/aliases`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update an owned alias
         * @param {string} aliasId aliasId
         * @param {CreateOwnedAliasOptions} createOwnedAliasOptions createOwnedAliasOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlias(
            aliasId: string,
            createOwnedAliasOptions: CreateOwnedAliasOptions,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'aliasId' is not null or undefined
            if (aliasId === null || aliasId === undefined) {
                throw new RequiredError(
                    'aliasId',
                    'Required parameter aliasId was null or undefined when calling updateAlias.'
                );
            }
            // verify required parameter 'createOwnedAliasOptions' is not null or undefined
            if (
                createOwnedAliasOptions === null ||
                createOwnedAliasOptions === undefined
            ) {
                throw new RequiredError(
                    'createOwnedAliasOptions',
                    'Required parameter createOwnedAliasOptions was null or undefined when calling updateAlias.'
                );
            }
            const localVarPath = `/aliases/{aliasId}`.replace(
                `{${'aliasId'}}`,
                encodeURIComponent(String(aliasId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'PUT' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'CreateOwnedAliasOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(createOwnedAliasOptions || {})
                : createOwnedAliasOptions || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * AliasControllerApi - functional programming interface
 * @export
 */
export const AliasControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create an email alias belonging to a user ID. To create anonymous aliases use the `createAnonymousAlias` method.
         * @summary Create an email alias
         * @param {CreateOwnedAliasOptions} createOwnedAliasOptions createOwnedAliasOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlias(
            createOwnedAliasOptions: CreateOwnedAliasOptions,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AliasControllerApiFetchParamCreator(
                configuration
            ).createAlias(createOwnedAliasOptions, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Create an anonymous email alias
         * @param {CreateAnonymousAliasOptions} createAnonymousAliasOptions createAnonymousAliasOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnonymousAlias(
            createAnonymousAliasOptions: CreateAnonymousAliasOptions,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Alias> {
            const localVarFetchArgs = AliasControllerApiFetchParamCreator(
                configuration
            ).createAnonymousAlias(createAnonymousAliasOptions, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete an owned alias
         * @param {string} aliasId aliasId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlias(
            aliasId: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AliasControllerApiFetchParamCreator(
                configuration
            ).deleteAlias(aliasId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get an email alias by ID
         * @summary Get an email alias
         * @param {string} aliasId aliasId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlias(
            aliasId: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Alias> {
            const localVarFetchArgs = AliasControllerApiFetchParamCreator(
                configuration
            ).getAlias(aliasId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all email aliases in paginated form
         * @summary Get all email aliases
         * @param {number} [page] Optional page index in alias list pagination
         * @param {number} [size] Optional page size in alias list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAliases(
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<PageAlias> {
            const localVarFetchArgs = AliasControllerApiFetchParamCreator(
                configuration
            ).getAliases(page, size, sort, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update an owned alias
         * @param {string} aliasId aliasId
         * @param {CreateOwnedAliasOptions} createOwnedAliasOptions createOwnedAliasOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlias(
            aliasId: string,
            createOwnedAliasOptions: CreateOwnedAliasOptions,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AliasControllerApiFetchParamCreator(
                configuration
            ).updateAlias(aliasId, createOwnedAliasOptions, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    };
};

/**
 * AliasControllerApi - factory interface
 * @export
 */
export const AliasControllerApiFactory = function(
    configuration?: Configuration,
    fetch?: FetchAPI,
    basePath?: string
) {
    return {
        /**
         * Create an email alias belonging to a user ID. To create anonymous aliases use the `createAnonymousAlias` method.
         * @summary Create an email alias
         * @param {CreateOwnedAliasOptions} createOwnedAliasOptions createOwnedAliasOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlias(
            createOwnedAliasOptions: CreateOwnedAliasOptions,
            options?: any
        ) {
            return AliasControllerApiFp(configuration).createAlias(
                createOwnedAliasOptions,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Create an anonymous email alias
         * @param {CreateAnonymousAliasOptions} createAnonymousAliasOptions createAnonymousAliasOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnonymousAlias(
            createAnonymousAliasOptions: CreateAnonymousAliasOptions,
            options?: any
        ) {
            return AliasControllerApiFp(configuration).createAnonymousAlias(
                createAnonymousAliasOptions,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Delete an owned alias
         * @param {string} aliasId aliasId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlias(aliasId: string, options?: any) {
            return AliasControllerApiFp(configuration).deleteAlias(
                aliasId,
                options
            )(fetch, basePath);
        },
        /**
         * Get an email alias by ID
         * @summary Get an email alias
         * @param {string} aliasId aliasId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlias(aliasId: string, options?: any) {
            return AliasControllerApiFp(configuration).getAlias(
                aliasId,
                options
            )(fetch, basePath);
        },
        /**
         * Get all email aliases in paginated form
         * @summary Get all email aliases
         * @param {number} [page] Optional page index in alias list pagination
         * @param {number} [size] Optional page size in alias list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAliases(
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ) {
            return AliasControllerApiFp(configuration).getAliases(
                page,
                size,
                sort,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Update an owned alias
         * @param {string} aliasId aliasId
         * @param {CreateOwnedAliasOptions} createOwnedAliasOptions createOwnedAliasOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlias(
            aliasId: string,
            createOwnedAliasOptions: CreateOwnedAliasOptions,
            options?: any
        ) {
            return AliasControllerApiFp(configuration).updateAlias(
                aliasId,
                createOwnedAliasOptions,
                options
            )(fetch, basePath);
        },
    };
};

/**
 * AliasControllerApi - object-oriented interface
 * @export
 * @class AliasControllerApi
 * @extends {BaseAPI}
 */
export class AliasControllerApi extends BaseAPI {
    /**
     * Create an email alias belonging to a user ID. To create anonymous aliases use the `createAnonymousAlias` method.
     * @summary Create an email alias
     * @param {CreateOwnedAliasOptions} createOwnedAliasOptions createOwnedAliasOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasControllerApi
     */
    public createAlias(
        createOwnedAliasOptions: CreateOwnedAliasOptions,
        options?: any
    ) {
        return AliasControllerApiFp(this.configuration).createAlias(
            createOwnedAliasOptions,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Create an anonymous email alias
     * @param {CreateAnonymousAliasOptions} createAnonymousAliasOptions createAnonymousAliasOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasControllerApi
     */
    public createAnonymousAlias(
        createAnonymousAliasOptions: CreateAnonymousAliasOptions,
        options?: any
    ) {
        return AliasControllerApiFp(this.configuration).createAnonymousAlias(
            createAnonymousAliasOptions,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Delete an owned alias
     * @param {string} aliasId aliasId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasControllerApi
     */
    public deleteAlias(aliasId: string, options?: any) {
        return AliasControllerApiFp(this.configuration).deleteAlias(
            aliasId,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Get an email alias by ID
     * @summary Get an email alias
     * @param {string} aliasId aliasId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasControllerApi
     */
    public getAlias(aliasId: string, options?: any) {
        return AliasControllerApiFp(this.configuration).getAlias(
            aliasId,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Get all email aliases in paginated form
     * @summary Get all email aliases
     * @param {number} [page] Optional page index in alias list pagination
     * @param {number} [size] Optional page size in alias list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasControllerApi
     */
    public getAliases(
        page?: number,
        size?: number,
        sort?: 'ASC' | 'DESC',
        options?: any
    ) {
        return AliasControllerApiFp(this.configuration).getAliases(
            page,
            size,
            sort,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Update an owned alias
     * @param {string} aliasId aliasId
     * @param {CreateOwnedAliasOptions} createOwnedAliasOptions createOwnedAliasOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasControllerApi
     */
    public updateAlias(
        aliasId: string,
        createOwnedAliasOptions: CreateOwnedAliasOptions,
        options?: any
    ) {
        return AliasControllerApiFp(this.configuration).updateAlias(
            aliasId,
            createOwnedAliasOptions,
            options
        )(this.fetch, this.basePath);
    }
}

/**
 * AttachmentControllerApi - fetch parameter creator
 * @export
 */
export const AttachmentControllerApiFetchParamCreator = function(
    configuration?: Configuration
) {
    return {
        /**
         * When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment IDs. For legacy reasons the ID is returned in an array. Only a single ID is ever returned at one time. To send the attachments pass a list of attachment IDs with SendEmailOptions when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
         * @summary Upload an attachment for sending using base64 file encoding. Returns an array whose first element is the ID of the uploaded attachment.
         * @param {UploadAttachmentOptions} uploadOptions uploadOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAttachment(
            uploadOptions: UploadAttachmentOptions,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'uploadOptions' is not null or undefined
            if (uploadOptions === null || uploadOptions === undefined) {
                throw new RequiredError(
                    'uploadOptions',
                    'Required parameter uploadOptions was null or undefined when calling uploadAttachment.'
                );
            }
            const localVarPath = `/attachments`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'UploadAttachmentOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(uploadOptions || {})
                : uploadOptions || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment IDs. For legacy reasons the ID is returned in an array. Only a single ID is ever returned at one time. To send the attachments pass a list of attachment IDs with SendEmailOptions when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
         * @summary Upload an attachment for sending using file byte stream input octet stream. Returns an array whose first element is the ID of the uploaded attachment.
         * @param {string} [string] Optional contentType for file. For instance &#x60;application/pdf&#x60;
         * @param {string} [byteArray] Byte array request body
         * @param {string} [filename] Optional filename to save upload with
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAttachmentBytes(
            string?: string,
            byteArray?: string,
            filename?: string,
            options: any = {}
        ): FetchArgs {
            const localVarPath = `/attachments/bytes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (string !== undefined) {
                localVarQueryParameter['String'] = string;
            }

            if (filename !== undefined) {
                localVarQueryParameter['filename'] = filename;
            }

            localVarHeaderParameter['Content-Type'] =
                'application/octet-stream';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'string' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(byteArray || {})
                : byteArray || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment IDs. For legacy reasons the ID is returned in an array. Only a single ID is ever returned at one time. To send the attachments pass a list of attachment IDs with SendEmailOptions when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
         * @summary Upload an attachment for sending using a Multipart Form request. Returns an array whose first element is the ID of the uploaded attachment.
         * @param {any} file file
         * @param {string} [contentType] Optional content type of attachment
         * @param {string} [contentTypeHeader] Optional content type header of attachment
         * @param {string} [filename] Optional name of file
         * @param {string} [xFilename] Optional content type header of attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMultipartForm(
            file: any,
            contentType?: string,
            contentTypeHeader?: string,
            filename?: string,
            xFilename?: string,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError(
                    'file',
                    'Required parameter file was null or undefined when calling uploadMultipartForm.'
                );
            }
            const localVarPath = `/attachments/multipart`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (contentType !== undefined) {
                localVarQueryParameter['contentType'] = contentType;
            }

            if (filename !== undefined) {
                localVarQueryParameter['filename'] = filename;
            }

            if (xFilename !== undefined) {
                localVarQueryParameter['x-filename'] = xFilename;
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] =
                'application/x-www-form-urlencoded';

            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            localVarRequestOptions.body = localVarFormParams.toString();
            const needsSerialization =
                <any>'string' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(contentTypeHeader || {})
                : contentTypeHeader || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * AttachmentControllerApi - functional programming interface
 * @export
 */
export const AttachmentControllerApiFp = function(
    configuration?: Configuration
) {
    return {
        /**
         * When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment IDs. For legacy reasons the ID is returned in an array. Only a single ID is ever returned at one time. To send the attachments pass a list of attachment IDs with SendEmailOptions when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
         * @summary Upload an attachment for sending using base64 file encoding. Returns an array whose first element is the ID of the uploaded attachment.
         * @param {UploadAttachmentOptions} uploadOptions uploadOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAttachment(
            uploadOptions: UploadAttachmentOptions,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = AttachmentControllerApiFetchParamCreator(
                configuration
            ).uploadAttachment(uploadOptions, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment IDs. For legacy reasons the ID is returned in an array. Only a single ID is ever returned at one time. To send the attachments pass a list of attachment IDs with SendEmailOptions when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
         * @summary Upload an attachment for sending using file byte stream input octet stream. Returns an array whose first element is the ID of the uploaded attachment.
         * @param {string} [string] Optional contentType for file. For instance &#x60;application/pdf&#x60;
         * @param {string} [byteArray] Byte array request body
         * @param {string} [filename] Optional filename to save upload with
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAttachmentBytes(
            string?: string,
            byteArray?: string,
            filename?: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = AttachmentControllerApiFetchParamCreator(
                configuration
            ).uploadAttachmentBytes(string, byteArray, filename, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment IDs. For legacy reasons the ID is returned in an array. Only a single ID is ever returned at one time. To send the attachments pass a list of attachment IDs with SendEmailOptions when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
         * @summary Upload an attachment for sending using a Multipart Form request. Returns an array whose first element is the ID of the uploaded attachment.
         * @param {any} file file
         * @param {string} [contentType] Optional content type of attachment
         * @param {string} [contentTypeHeader] Optional content type header of attachment
         * @param {string} [filename] Optional name of file
         * @param {string} [xFilename] Optional content type header of attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMultipartForm(
            file: any,
            contentType?: string,
            contentTypeHeader?: string,
            filename?: string,
            xFilename?: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = AttachmentControllerApiFetchParamCreator(
                configuration
            ).uploadMultipartForm(
                file,
                contentType,
                contentTypeHeader,
                filename,
                xFilename,
                options
            );
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    };
};

/**
 * AttachmentControllerApi - factory interface
 * @export
 */
export const AttachmentControllerApiFactory = function(
    configuration?: Configuration,
    fetch?: FetchAPI,
    basePath?: string
) {
    return {
        /**
         * When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment IDs. For legacy reasons the ID is returned in an array. Only a single ID is ever returned at one time. To send the attachments pass a list of attachment IDs with SendEmailOptions when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
         * @summary Upload an attachment for sending using base64 file encoding. Returns an array whose first element is the ID of the uploaded attachment.
         * @param {UploadAttachmentOptions} uploadOptions uploadOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAttachment(
            uploadOptions: UploadAttachmentOptions,
            options?: any
        ) {
            return AttachmentControllerApiFp(configuration).uploadAttachment(
                uploadOptions,
                options
            )(fetch, basePath);
        },
        /**
         * When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment IDs. For legacy reasons the ID is returned in an array. Only a single ID is ever returned at one time. To send the attachments pass a list of attachment IDs with SendEmailOptions when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
         * @summary Upload an attachment for sending using file byte stream input octet stream. Returns an array whose first element is the ID of the uploaded attachment.
         * @param {string} [string] Optional contentType for file. For instance &#x60;application/pdf&#x60;
         * @param {string} [byteArray] Byte array request body
         * @param {string} [filename] Optional filename to save upload with
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAttachmentBytes(
            string?: string,
            byteArray?: string,
            filename?: string,
            options?: any
        ) {
            return AttachmentControllerApiFp(
                configuration
            ).uploadAttachmentBytes(string, byteArray, filename, options)(
                fetch,
                basePath
            );
        },
        /**
         * When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment IDs. For legacy reasons the ID is returned in an array. Only a single ID is ever returned at one time. To send the attachments pass a list of attachment IDs with SendEmailOptions when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
         * @summary Upload an attachment for sending using a Multipart Form request. Returns an array whose first element is the ID of the uploaded attachment.
         * @param {any} file file
         * @param {string} [contentType] Optional content type of attachment
         * @param {string} [contentTypeHeader] Optional content type header of attachment
         * @param {string} [filename] Optional name of file
         * @param {string} [xFilename] Optional content type header of attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMultipartForm(
            file: any,
            contentType?: string,
            contentTypeHeader?: string,
            filename?: string,
            xFilename?: string,
            options?: any
        ) {
            return AttachmentControllerApiFp(configuration).uploadMultipartForm(
                file,
                contentType,
                contentTypeHeader,
                filename,
                xFilename,
                options
            )(fetch, basePath);
        },
    };
};

/**
 * AttachmentControllerApi - object-oriented interface
 * @export
 * @class AttachmentControllerApi
 * @extends {BaseAPI}
 */
export class AttachmentControllerApi extends BaseAPI {
    /**
     * When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment IDs. For legacy reasons the ID is returned in an array. Only a single ID is ever returned at one time. To send the attachments pass a list of attachment IDs with SendEmailOptions when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
     * @summary Upload an attachment for sending using base64 file encoding. Returns an array whose first element is the ID of the uploaded attachment.
     * @param {UploadAttachmentOptions} uploadOptions uploadOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentControllerApi
     */
    public uploadAttachment(
        uploadOptions: UploadAttachmentOptions,
        options?: any
    ) {
        return AttachmentControllerApiFp(this.configuration).uploadAttachment(
            uploadOptions,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment IDs. For legacy reasons the ID is returned in an array. Only a single ID is ever returned at one time. To send the attachments pass a list of attachment IDs with SendEmailOptions when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
     * @summary Upload an attachment for sending using file byte stream input octet stream. Returns an array whose first element is the ID of the uploaded attachment.
     * @param {string} [string] Optional contentType for file. For instance &#x60;application/pdf&#x60;
     * @param {string} [byteArray] Byte array request body
     * @param {string} [filename] Optional filename to save upload with
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentControllerApi
     */
    public uploadAttachmentBytes(
        string?: string,
        byteArray?: string,
        filename?: string,
        options?: any
    ) {
        return AttachmentControllerApiFp(
            this.configuration
        ).uploadAttachmentBytes(string, byteArray, filename, options)(
            this.fetch,
            this.basePath
        );
    }

    /**
     * When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment IDs. For legacy reasons the ID is returned in an array. Only a single ID is ever returned at one time. To send the attachments pass a list of attachment IDs with SendEmailOptions when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
     * @summary Upload an attachment for sending using a Multipart Form request. Returns an array whose first element is the ID of the uploaded attachment.
     * @param {any} file file
     * @param {string} [contentType] Optional content type of attachment
     * @param {string} [contentTypeHeader] Optional content type header of attachment
     * @param {string} [filename] Optional name of file
     * @param {string} [xFilename] Optional content type header of attachment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentControllerApi
     */
    public uploadMultipartForm(
        file: any,
        contentType?: string,
        contentTypeHeader?: string,
        filename?: string,
        xFilename?: string,
        options?: any
    ) {
        return AttachmentControllerApiFp(
            this.configuration
        ).uploadMultipartForm(
            file,
            contentType,
            contentTypeHeader,
            filename,
            xFilename,
            options
        )(this.fetch, this.basePath);
    }
}

/**
 * BulkActionsControllerApi - fetch parameter creator
 * @export
 */
export const BulkActionsControllerApiFetchParamCreator = function(
    configuration?: Configuration
) {
    return {
        /**
         *
         * @summary Bulk create Inboxes (email addresses)
         * @param {number} count Number of inboxes to be created in bulk
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkCreateInboxes(count: number, options: any = {}): FetchArgs {
            // verify required parameter 'count' is not null or undefined
            if (count === null || count === undefined) {
                throw new RequiredError(
                    'count',
                    'Required parameter count was null or undefined when calling bulkCreateInboxes.'
                );
            }
            const localVarPath = `/bulk/inboxes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Bulk Delete Inboxes
         * @param {Array<string>} ids ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkDeleteInboxes(ids: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'ids' is not null or undefined
            if (ids === null || ids === undefined) {
                throw new RequiredError(
                    'ids',
                    'Required parameter ids was null or undefined when calling bulkDeleteInboxes.'
                );
            }
            const localVarPath = `/bulk/inboxes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'DELETE' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'Array&lt;string&gt;' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(ids || {})
                : ids || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Bulk Send Emails
         * @param {BulkSendEmailOptions} bulkSendEmailOptions bulkSendEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkSendEmails(
            bulkSendEmailOptions: BulkSendEmailOptions,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'bulkSendEmailOptions' is not null or undefined
            if (
                bulkSendEmailOptions === null ||
                bulkSendEmailOptions === undefined
            ) {
                throw new RequiredError(
                    'bulkSendEmailOptions',
                    'Required parameter bulkSendEmailOptions was null or undefined when calling bulkSendEmails.'
                );
            }
            const localVarPath = `/bulk/send`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'BulkSendEmailOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(bulkSendEmailOptions || {})
                : bulkSendEmailOptions || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * BulkActionsControllerApi - functional programming interface
 * @export
 */
export const BulkActionsControllerApiFp = function(
    configuration?: Configuration
) {
    return {
        /**
         *
         * @summary Bulk create Inboxes (email addresses)
         * @param {number} count Number of inboxes to be created in bulk
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkCreateInboxes(
            count: number,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Inbox>> {
            const localVarFetchArgs = BulkActionsControllerApiFetchParamCreator(
                configuration
            ).bulkCreateInboxes(count, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Bulk Delete Inboxes
         * @param {Array<string>} ids ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkDeleteInboxes(
            ids: Array<string>,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BulkActionsControllerApiFetchParamCreator(
                configuration
            ).bulkDeleteInboxes(ids, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Bulk Send Emails
         * @param {BulkSendEmailOptions} bulkSendEmailOptions bulkSendEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkSendEmails(
            bulkSendEmailOptions: BulkSendEmailOptions,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BulkActionsControllerApiFetchParamCreator(
                configuration
            ).bulkSendEmails(bulkSendEmailOptions, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    };
};

/**
 * BulkActionsControllerApi - factory interface
 * @export
 */
export const BulkActionsControllerApiFactory = function(
    configuration?: Configuration,
    fetch?: FetchAPI,
    basePath?: string
) {
    return {
        /**
         *
         * @summary Bulk create Inboxes (email addresses)
         * @param {number} count Number of inboxes to be created in bulk
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkCreateInboxes(count: number, options?: any) {
            return BulkActionsControllerApiFp(configuration).bulkCreateInboxes(
                count,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Bulk Delete Inboxes
         * @param {Array<string>} ids ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkDeleteInboxes(ids: Array<string>, options?: any) {
            return BulkActionsControllerApiFp(configuration).bulkDeleteInboxes(
                ids,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Bulk Send Emails
         * @param {BulkSendEmailOptions} bulkSendEmailOptions bulkSendEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkSendEmails(
            bulkSendEmailOptions: BulkSendEmailOptions,
            options?: any
        ) {
            return BulkActionsControllerApiFp(configuration).bulkSendEmails(
                bulkSendEmailOptions,
                options
            )(fetch, basePath);
        },
    };
};

/**
 * BulkActionsControllerApi - object-oriented interface
 * @export
 * @class BulkActionsControllerApi
 * @extends {BaseAPI}
 */
export class BulkActionsControllerApi extends BaseAPI {
    /**
     *
     * @summary Bulk create Inboxes (email addresses)
     * @param {number} count Number of inboxes to be created in bulk
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BulkActionsControllerApi
     */
    public bulkCreateInboxes(count: number, options?: any) {
        return BulkActionsControllerApiFp(this.configuration).bulkCreateInboxes(
            count,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Bulk Delete Inboxes
     * @param {Array<string>} ids ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BulkActionsControllerApi
     */
    public bulkDeleteInboxes(ids: Array<string>, options?: any) {
        return BulkActionsControllerApiFp(this.configuration).bulkDeleteInboxes(
            ids,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Bulk Send Emails
     * @param {BulkSendEmailOptions} bulkSendEmailOptions bulkSendEmailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BulkActionsControllerApi
     */
    public bulkSendEmails(
        bulkSendEmailOptions: BulkSendEmailOptions,
        options?: any
    ) {
        return BulkActionsControllerApiFp(this.configuration).bulkSendEmails(
            bulkSendEmailOptions,
            options
        )(this.fetch, this.basePath);
    }
}

/**
 * CommonActionsControllerApi - fetch parameter creator
 * @export
 */
export const CommonActionsControllerApiFetchParamCreator = function(
    configuration?: Configuration
) {
    return {
        /**
         * Returns an Inbox with an `id` and an `emailAddress`
         * @summary Create new random inbox
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewEmailAddress(options: any = {}): FetchArgs {
            const localVarPath = `/createInbox`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an Inbox with an `id` and an `emailAddress`
         * @summary Create new random inbox
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewEmailAddress1(options: any = {}): FetchArgs {
            const localVarPath = `/newEmailAddress`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes all emails
         * @summary Delete all emails in an inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emptyInbox(inboxId: string, options: any = {}): FetchArgs {
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError(
                    'inboxId',
                    'Required parameter inboxId was null or undefined when calling emptyInbox.'
                );
            }
            const localVarPath = `/emptyInbox`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'DELETE' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (inboxId !== undefined) {
                localVarQueryParameter['inboxId'] = inboxId;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If no senderId or inboxId provided a random email address will be used to send from.
         * @summary Send an email
         * @param {SimpleSendEmailOptions} emailOptions emailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailSimple(
            emailOptions: SimpleSendEmailOptions,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'emailOptions' is not null or undefined
            if (emailOptions === null || emailOptions === undefined) {
                throw new RequiredError(
                    'emailOptions',
                    'Required parameter emailOptions was null or undefined when calling sendEmailSimple.'
                );
            }
            const localVarPath = `/sendEmail`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'SimpleSendEmailOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(emailOptions || {})
                : emailOptions || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * CommonActionsControllerApi - functional programming interface
 * @export
 */
export const CommonActionsControllerApiFp = function(
    configuration?: Configuration
) {
    return {
        /**
         * Returns an Inbox with an `id` and an `emailAddress`
         * @summary Create new random inbox
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewEmailAddress(
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Inbox> {
            const localVarFetchArgs = CommonActionsControllerApiFetchParamCreator(
                configuration
            ).createNewEmailAddress(options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns an Inbox with an `id` and an `emailAddress`
         * @summary Create new random inbox
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewEmailAddress1(
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Inbox> {
            const localVarFetchArgs = CommonActionsControllerApiFetchParamCreator(
                configuration
            ).createNewEmailAddress1(options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes all emails
         * @summary Delete all emails in an inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emptyInbox(
            inboxId: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CommonActionsControllerApiFetchParamCreator(
                configuration
            ).emptyInbox(inboxId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * If no senderId or inboxId provided a random email address will be used to send from.
         * @summary Send an email
         * @param {SimpleSendEmailOptions} emailOptions emailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailSimple(
            emailOptions: SimpleSendEmailOptions,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CommonActionsControllerApiFetchParamCreator(
                configuration
            ).sendEmailSimple(emailOptions, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    };
};

/**
 * CommonActionsControllerApi - factory interface
 * @export
 */
export const CommonActionsControllerApiFactory = function(
    configuration?: Configuration,
    fetch?: FetchAPI,
    basePath?: string
) {
    return {
        /**
         * Returns an Inbox with an `id` and an `emailAddress`
         * @summary Create new random inbox
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewEmailAddress(options?: any) {
            return CommonActionsControllerApiFp(
                configuration
            ).createNewEmailAddress(options)(fetch, basePath);
        },
        /**
         * Returns an Inbox with an `id` and an `emailAddress`
         * @summary Create new random inbox
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewEmailAddress1(options?: any) {
            return CommonActionsControllerApiFp(
                configuration
            ).createNewEmailAddress1(options)(fetch, basePath);
        },
        /**
         * Deletes all emails
         * @summary Delete all emails in an inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emptyInbox(inboxId: string, options?: any) {
            return CommonActionsControllerApiFp(configuration).emptyInbox(
                inboxId,
                options
            )(fetch, basePath);
        },
        /**
         * If no senderId or inboxId provided a random email address will be used to send from.
         * @summary Send an email
         * @param {SimpleSendEmailOptions} emailOptions emailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailSimple(emailOptions: SimpleSendEmailOptions, options?: any) {
            return CommonActionsControllerApiFp(configuration).sendEmailSimple(
                emailOptions,
                options
            )(fetch, basePath);
        },
    };
};

/**
 * CommonActionsControllerApi - object-oriented interface
 * @export
 * @class CommonActionsControllerApi
 * @extends {BaseAPI}
 */
export class CommonActionsControllerApi extends BaseAPI {
    /**
     * Returns an Inbox with an `id` and an `emailAddress`
     * @summary Create new random inbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonActionsControllerApi
     */
    public createNewEmailAddress(options?: any) {
        return CommonActionsControllerApiFp(
            this.configuration
        ).createNewEmailAddress(options)(this.fetch, this.basePath);
    }

    /**
     * Returns an Inbox with an `id` and an `emailAddress`
     * @summary Create new random inbox
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonActionsControllerApi
     */
    public createNewEmailAddress1(options?: any) {
        return CommonActionsControllerApiFp(
            this.configuration
        ).createNewEmailAddress1(options)(this.fetch, this.basePath);
    }

    /**
     * Deletes all emails
     * @summary Delete all emails in an inbox
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonActionsControllerApi
     */
    public emptyInbox(inboxId: string, options?: any) {
        return CommonActionsControllerApiFp(this.configuration).emptyInbox(
            inboxId,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * If no senderId or inboxId provided a random email address will be used to send from.
     * @summary Send an email
     * @param {SimpleSendEmailOptions} emailOptions emailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonActionsControllerApi
     */
    public sendEmailSimple(
        emailOptions: SimpleSendEmailOptions,
        options?: any
    ) {
        return CommonActionsControllerApiFp(this.configuration).sendEmailSimple(
            emailOptions,
            options
        )(this.fetch, this.basePath);
    }
}

/**
 * ContactControllerApi - fetch parameter creator
 * @export
 */
export const ContactControllerApiFetchParamCreator = function(
    configuration?: Configuration
) {
    return {
        /**
         *
         * @summary Create a contact
         * @param {CreateContactOptions} createContactOptions createContactOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContact(
            createContactOptions: CreateContactOptions,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'createContactOptions' is not null or undefined
            if (
                createContactOptions === null ||
                createContactOptions === undefined
            ) {
                throw new RequiredError(
                    'createContactOptions',
                    'Required parameter createContactOptions was null or undefined when calling createContact.'
                );
            }
            const localVarPath = `/contacts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'CreateContactOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(createContactOptions || {})
                : createContactOptions || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete contact
         * @param {string} contactId contactId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContact(contactId: string, options: any = {}): FetchArgs {
            // verify required parameter 'contactId' is not null or undefined
            if (contactId === null || contactId === undefined) {
                throw new RequiredError(
                    'contactId',
                    'Required parameter contactId was null or undefined when calling deleteContact.'
                );
            }
            const localVarPath = `/contacts/{contactId}`.replace(
                `{${'contactId'}}`,
                encodeURIComponent(String(contactId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'DELETE' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all contacts
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllContacts(
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options: any = {}
        ): FetchArgs {
            const localVarPath = `/contacts/paginated`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get contact
         * @param {string} contactId contactId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContact(contactId: string, options: any = {}): FetchArgs {
            // verify required parameter 'contactId' is not null or undefined
            if (contactId === null || contactId === undefined) {
                throw new RequiredError(
                    'contactId',
                    'Required parameter contactId was null or undefined when calling getContact.'
                );
            }
            const localVarPath = `/contacts/{contactId}`.replace(
                `{${'contactId'}}`,
                encodeURIComponent(String(contactId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all contacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContacts(options: any = {}): FetchArgs {
            const localVarPath = `/contacts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * ContactControllerApi - functional programming interface
 * @export
 */
export const ContactControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a contact
         * @param {CreateContactOptions} createContactOptions createContactOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContact(
            createContactOptions: CreateContactOptions,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<ContactDto> {
            const localVarFetchArgs = ContactControllerApiFetchParamCreator(
                configuration
            ).createContact(createContactOptions, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete contact
         * @param {string} contactId contactId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContact(
            contactId: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ContactControllerApiFetchParamCreator(
                configuration
            ).deleteContact(contactId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all contacts
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllContacts(
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<PageContactProjection> {
            const localVarFetchArgs = ContactControllerApiFetchParamCreator(
                configuration
            ).getAllContacts(page, size, sort, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get contact
         * @param {string} contactId contactId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContact(
            contactId: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<ContactDto> {
            const localVarFetchArgs = ContactControllerApiFetchParamCreator(
                configuration
            ).getContact(contactId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all contacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContacts(
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<Array<ContactProjection>> {
            const localVarFetchArgs = ContactControllerApiFetchParamCreator(
                configuration
            ).getContacts(options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    };
};

/**
 * ContactControllerApi - factory interface
 * @export
 */
export const ContactControllerApiFactory = function(
    configuration?: Configuration,
    fetch?: FetchAPI,
    basePath?: string
) {
    return {
        /**
         *
         * @summary Create a contact
         * @param {CreateContactOptions} createContactOptions createContactOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContact(
            createContactOptions: CreateContactOptions,
            options?: any
        ) {
            return ContactControllerApiFp(configuration).createContact(
                createContactOptions,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Delete contact
         * @param {string} contactId contactId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContact(contactId: string, options?: any) {
            return ContactControllerApiFp(configuration).deleteContact(
                contactId,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Get all contacts
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllContacts(
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ) {
            return ContactControllerApiFp(configuration).getAllContacts(
                page,
                size,
                sort,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Get contact
         * @param {string} contactId contactId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContact(contactId: string, options?: any) {
            return ContactControllerApiFp(configuration).getContact(
                contactId,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Get all contacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContacts(options?: any) {
            return ContactControllerApiFp(configuration).getContacts(options)(
                fetch,
                basePath
            );
        },
    };
};

/**
 * ContactControllerApi - object-oriented interface
 * @export
 * @class ContactControllerApi
 * @extends {BaseAPI}
 */
export class ContactControllerApi extends BaseAPI {
    /**
     *
     * @summary Create a contact
     * @param {CreateContactOptions} createContactOptions createContactOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactControllerApi
     */
    public createContact(
        createContactOptions: CreateContactOptions,
        options?: any
    ) {
        return ContactControllerApiFp(this.configuration).createContact(
            createContactOptions,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Delete contact
     * @param {string} contactId contactId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactControllerApi
     */
    public deleteContact(contactId: string, options?: any) {
        return ContactControllerApiFp(this.configuration).deleteContact(
            contactId,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get all contacts
     * @param {number} [page] Optional page index in inbox list pagination
     * @param {number} [size] Optional page size in inbox list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactControllerApi
     */
    public getAllContacts(
        page?: number,
        size?: number,
        sort?: 'ASC' | 'DESC',
        options?: any
    ) {
        return ContactControllerApiFp(this.configuration).getAllContacts(
            page,
            size,
            sort,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get contact
     * @param {string} contactId contactId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactControllerApi
     */
    public getContact(contactId: string, options?: any) {
        return ContactControllerApiFp(this.configuration).getContact(
            contactId,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get all contacts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactControllerApi
     */
    public getContacts(options?: any) {
        return ContactControllerApiFp(this.configuration).getContacts(options)(
            this.fetch,
            this.basePath
        );
    }
}

/**
 * DomainControllerApi - fetch parameter creator
 * @export
 */
export const DomainControllerApiFetchParamCreator = function(
    configuration?: Configuration
) {
    return {
        /**
         * Link a domain that you own with MailSlurp so you can create email addresses using it. Endpoint returns DNS records used for validation. You must add these verification records to your host provider's DNS setup to verify the domain.
         * @summary Create Domain
         * @param {CreateDomainOptions} domainOptions domainOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDomain(
            domainOptions: CreateDomainOptions,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'domainOptions' is not null or undefined
            if (domainOptions === null || domainOptions === undefined) {
                throw new RequiredError(
                    'domainOptions',
                    'Required parameter domainOptions was null or undefined when calling createDomain.'
                );
            }
            const localVarPath = `/domains`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'CreateDomainOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(domainOptions || {})
                : domainOptions || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a domain. This will disable any existing inboxes that use this domain.
         * @summary Delete a domain
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDomain(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError(
                    'id',
                    'Required parameter id was null or undefined when calling deleteDomain.'
                );
            }
            const localVarPath = `/domains/{id}`.replace(
                `{${'id'}}`,
                encodeURIComponent(String(id))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'DELETE' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns domain verification status and tokens for a given domain
         * @summary Get a domain
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomain(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError(
                    'id',
                    'Required parameter id was null or undefined when calling getDomain.'
                );
            }
            const localVarPath = `/domains/{id}`.replace(
                `{${'id'}}`,
                encodeURIComponent(String(id))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all custom domains you have created
         * @summary Get domains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomains(options: any = {}): FetchArgs {
            const localVarPath = `/domains`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * DomainControllerApi - functional programming interface
 * @export
 */
export const DomainControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Link a domain that you own with MailSlurp so you can create email addresses using it. Endpoint returns DNS records used for validation. You must add these verification records to your host provider's DNS setup to verify the domain.
         * @summary Create Domain
         * @param {CreateDomainOptions} domainOptions domainOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDomain(
            domainOptions: CreateDomainOptions,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<DomainDto> {
            const localVarFetchArgs = DomainControllerApiFetchParamCreator(
                configuration
            ).createDomain(domainOptions, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a domain. This will disable any existing inboxes that use this domain.
         * @summary Delete a domain
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDomain(
            id: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DomainControllerApiFetchParamCreator(
                configuration
            ).deleteDomain(id, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns domain verification status and tokens for a given domain
         * @summary Get a domain
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomain(
            id: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<DomainDto> {
            const localVarFetchArgs = DomainControllerApiFetchParamCreator(
                configuration
            ).getDomain(id, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all custom domains you have created
         * @summary Get domains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomains(
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<Array<DomainPreview>> {
            const localVarFetchArgs = DomainControllerApiFetchParamCreator(
                configuration
            ).getDomains(options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    };
};

/**
 * DomainControllerApi - factory interface
 * @export
 */
export const DomainControllerApiFactory = function(
    configuration?: Configuration,
    fetch?: FetchAPI,
    basePath?: string
) {
    return {
        /**
         * Link a domain that you own with MailSlurp so you can create email addresses using it. Endpoint returns DNS records used for validation. You must add these verification records to your host provider's DNS setup to verify the domain.
         * @summary Create Domain
         * @param {CreateDomainOptions} domainOptions domainOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDomain(domainOptions: CreateDomainOptions, options?: any) {
            return DomainControllerApiFp(configuration).createDomain(
                domainOptions,
                options
            )(fetch, basePath);
        },
        /**
         * Delete a domain. This will disable any existing inboxes that use this domain.
         * @summary Delete a domain
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDomain(id: string, options?: any) {
            return DomainControllerApiFp(configuration).deleteDomain(
                id,
                options
            )(fetch, basePath);
        },
        /**
         * Returns domain verification status and tokens for a given domain
         * @summary Get a domain
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomain(id: string, options?: any) {
            return DomainControllerApiFp(configuration).getDomain(id, options)(
                fetch,
                basePath
            );
        },
        /**
         * List all custom domains you have created
         * @summary Get domains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomains(options?: any) {
            return DomainControllerApiFp(configuration).getDomains(options)(
                fetch,
                basePath
            );
        },
    };
};

/**
 * DomainControllerApi - object-oriented interface
 * @export
 * @class DomainControllerApi
 * @extends {BaseAPI}
 */
export class DomainControllerApi extends BaseAPI {
    /**
     * Link a domain that you own with MailSlurp so you can create email addresses using it. Endpoint returns DNS records used for validation. You must add these verification records to your host provider's DNS setup to verify the domain.
     * @summary Create Domain
     * @param {CreateDomainOptions} domainOptions domainOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainControllerApi
     */
    public createDomain(domainOptions: CreateDomainOptions, options?: any) {
        return DomainControllerApiFp(this.configuration).createDomain(
            domainOptions,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Delete a domain. This will disable any existing inboxes that use this domain.
     * @summary Delete a domain
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainControllerApi
     */
    public deleteDomain(id: string, options?: any) {
        return DomainControllerApiFp(this.configuration).deleteDomain(
            id,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Returns domain verification status and tokens for a given domain
     * @summary Get a domain
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainControllerApi
     */
    public getDomain(id: string, options?: any) {
        return DomainControllerApiFp(this.configuration).getDomain(id, options)(
            this.fetch,
            this.basePath
        );
    }

    /**
     * List all custom domains you have created
     * @summary Get domains
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainControllerApi
     */
    public getDomains(options?: any) {
        return DomainControllerApiFp(this.configuration).getDomains(options)(
            this.fetch,
            this.basePath
        );
    }
}

/**
 * EmailControllerApi - fetch parameter creator
 * @export
 */
export const EmailControllerApiFetchParamCreator = function(
    configuration?: Configuration
) {
    return {
        /**
         * Deletes all emails in your account. Be careful as emails cannot be recovered
         * @summary Delete all emails
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllEmails(options: any = {}): FetchArgs {
            const localVarPath = `/emails`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'DELETE' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an email and removes it from the inbox. Deleted emails cannot be recovered.
         * @summary Delete an email
         * @param {string} emailId ID of email to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmail(emailId: string, options: any = {}): FetchArgs {
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError(
                    'emailId',
                    'Required parameter emailId was null or undefined when calling deleteEmail.'
                );
            }
            const localVarPath = `/emails/{emailId}`.replace(
                `{${'emailId'}}`,
                encodeURIComponent(String(emailId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'DELETE' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified attachment for a given email as a stream / array of bytes. You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
         * @summary Get email attachment bytes. If you have trouble with byte responses try the `downloadAttachmentBase64` response endpoints.
         * @param {string} attachmentId ID of attachment
         * @param {string} emailId ID of email
         * @param {string} [apiKey] Can pass apiKey in url for this request if you wish to download the file in a browser. Content type will be set to original content type of the attachment file. This is so that browsers can download the file correctly.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachment(
            attachmentId: string,
            emailId: string,
            apiKey?: string,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError(
                    'attachmentId',
                    'Required parameter attachmentId was null or undefined when calling downloadAttachment.'
                );
            }
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError(
                    'emailId',
                    'Required parameter emailId was null or undefined when calling downloadAttachment.'
                );
            }
            const localVarPath = `/emails/{emailId}/attachments/{attachmentId}`
                .replace(
                    `{${'attachmentId'}}`,
                    encodeURIComponent(String(attachmentId))
                )
                .replace(`{${'emailId'}}`, encodeURIComponent(String(emailId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (apiKey !== undefined) {
                localVarQueryParameter['apiKey'] = apiKey;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified attachment for a given email as a base 64 encoded string. The response type is application/json. This method is similar to the `downloadAttachment` method but allows some clients to get around issues with binary responses.
         * @summary Get email attachment as base64 encoded string (alternative to binary responses)
         * @param {string} attachmentId ID of attachment
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachmentBase64(
            attachmentId: string,
            emailId: string,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError(
                    'attachmentId',
                    'Required parameter attachmentId was null or undefined when calling downloadAttachmentBase64.'
                );
            }
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError(
                    'emailId',
                    'Required parameter emailId was null or undefined when calling downloadAttachmentBase64.'
                );
            }
            const localVarPath = `/emails/{emailId}/attachments/{attachmentId}/base64`
                .replace(
                    `{${'attachmentId'}}`,
                    encodeURIComponent(String(attachmentId))
                )
                .replace(`{${'emailId'}}`, encodeURIComponent(String(emailId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Forward an existing email to new recipients.
         * @summary Forward email
         * @param {string} emailId ID of email
         * @param {ForwardEmailOptions} forwardEmailOptions forwardEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forwardEmail(
            emailId: string,
            forwardEmailOptions: ForwardEmailOptions,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError(
                    'emailId',
                    'Required parameter emailId was null or undefined when calling forwardEmail.'
                );
            }
            // verify required parameter 'forwardEmailOptions' is not null or undefined
            if (
                forwardEmailOptions === null ||
                forwardEmailOptions === undefined
            ) {
                throw new RequiredError(
                    'forwardEmailOptions',
                    'Required parameter forwardEmailOptions was null or undefined when calling forwardEmail.'
                );
            }
            const localVarPath = `/emails/{emailId}/forward`.replace(
                `{${'emailId'}}`,
                encodeURIComponent(String(emailId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'ForwardEmailOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(forwardEmailOptions || {})
                : forwardEmailOptions || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the metadata such as name and content-type for a given attachment and email.
         * @summary Get email attachment metadata
         * @param {string} attachmentId ID of attachment
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachmentMetaData(
            attachmentId: string,
            emailId: string,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError(
                    'attachmentId',
                    'Required parameter attachmentId was null or undefined when calling getAttachmentMetaData.'
                );
            }
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError(
                    'emailId',
                    'Required parameter emailId was null or undefined when calling getAttachmentMetaData.'
                );
            }
            const localVarPath = `/emails/{emailId}/attachments/{attachmentId}/metadata`
                .replace(
                    `{${'attachmentId'}}`,
                    encodeURIComponent(String(attachmentId))
                )
                .replace(`{${'emailId'}}`, encodeURIComponent(String(emailId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of attachment metadata such as name and content-type for a given email if present.
         * @summary Get all email attachment metadata
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachments(emailId: string, options: any = {}): FetchArgs {
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError(
                    'emailId',
                    'Required parameter emailId was null or undefined when calling getAttachments.'
                );
            }
            const localVarPath = `/emails/{emailId}/attachments`.replace(
                `{${'emailId'}}`,
                encodeURIComponent(String(emailId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawEmail endpoints
         * @summary Get email content
         * @param {string} emailId emailId
         * @param {boolean} [decode] Decode email body quoted-printable encoding to plain text. SMTP servers often encode text using quoted-printable format (for instance &#x60;&#x3D;D7&#x60;). This can be a pain for testing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmail(
            emailId: string,
            decode?: boolean,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError(
                    'emailId',
                    'Required parameter emailId was null or undefined when calling getEmail.'
                );
            }
            const localVarPath = `/emails/{emailId}`.replace(
                `{${'emailId'}}`,
                encodeURIComponent(String(emailId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (decode !== undefined) {
                localVarQueryParameter['decode'] = decode;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve email content as HTML response for viewing in browsers. Decodes quoted-printable entities and converts charset to UTF-8. Pass your API KEY as a request parameter when viewing in a browser: `?apiKey=xxx`
         * @summary Get email content as HTML
         * @param {string} emailId emailId
         * @param {boolean} [decode] decode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailHTML(
            emailId: string,
            decode?: boolean,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError(
                    'emailId',
                    'Required parameter emailId was null or undefined when calling getEmailHTML.'
                );
            }
            const localVarPath = `/emails/{emailId}/html`.replace(
                `{${'emailId'}}`,
                encodeURIComponent(String(emailId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (decode !== undefined) {
                localVarQueryParameter['decode'] = decode;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
         * @summary Get all emails
         * @param {Array<string>} [inboxId] Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account.
         * @param {number} [page] Optional page index in email list pagination
         * @param {number} [size] Optional page size in email list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {boolean} [unreadOnly] Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailsPaginated(
            inboxId?: Array<string>,
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            unreadOnly?: boolean,
            options: any = {}
        ): FetchArgs {
            const localVarPath = `/emails`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (inboxId) {
                localVarQueryParameter['inboxId'] = inboxId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (unreadOnly !== undefined) {
                localVarQueryParameter['unreadOnly'] = unreadOnly;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a raw, unparsed, and unprocessed email. If your client has issues processing the response it is likely due to the response content-type which is text/plain. If you need a JSON response content-type use the getRawEmailJson endpoint
         * @summary Get raw email string
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawEmailContents(emailId: string, options: any = {}): FetchArgs {
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError(
                    'emailId',
                    'Required parameter emailId was null or undefined when calling getRawEmailContents.'
                );
            }
            const localVarPath = `/emails/{emailId}/raw`.replace(
                `{${'emailId'}}`,
                encodeURIComponent(String(emailId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a raw, unparsed, and unprocessed email wrapped in a JSON response object for easier handling when compared with the getRawEmail text/plain response
         * @summary Get raw email in JSON
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawEmailJson(emailId: string, options: any = {}): FetchArgs {
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError(
                    'emailId',
                    'Required parameter emailId was null or undefined when calling getRawEmailJson.'
                );
            }
            const localVarPath = `/emails/{emailId}/raw/json`.replace(
                `{${'emailId'}}`,
                encodeURIComponent(String(emailId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get number of emails unread
         * @summary Get unread email count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnreadEmailCount(options: any = {}): FetchArgs {
            const localVarPath = `/emails/unreadCount`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate the HTML content of email if HTML is found. Considered valid if no HTML.
         * @summary Validate email
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateEmail(emailId: string, options: any = {}): FetchArgs {
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError(
                    'emailId',
                    'Required parameter emailId was null or undefined when calling validateEmail.'
                );
            }
            const localVarPath = `/emails/{emailId}/validate`.replace(
                `{${'emailId'}}`,
                encodeURIComponent(String(emailId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * EmailControllerApi - functional programming interface
 * @export
 */
export const EmailControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Deletes all emails in your account. Be careful as emails cannot be recovered
         * @summary Delete all emails
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllEmails(
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EmailControllerApiFetchParamCreator(
                configuration
            ).deleteAllEmails(options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes an email and removes it from the inbox. Deleted emails cannot be recovered.
         * @summary Delete an email
         * @param {string} emailId ID of email to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmail(
            emailId: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EmailControllerApiFetchParamCreator(
                configuration
            ).deleteEmail(emailId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the specified attachment for a given email as a stream / array of bytes. You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
         * @summary Get email attachment bytes. If you have trouble with byte responses try the `downloadAttachmentBase64` response endpoints.
         * @param {string} attachmentId ID of attachment
         * @param {string} emailId ID of email
         * @param {string} [apiKey] Can pass apiKey in url for this request if you wish to download the file in a browser. Content type will be set to original content type of the attachment file. This is so that browsers can download the file correctly.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachment(
            attachmentId: string,
            emailId: string,
            apiKey?: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = EmailControllerApiFetchParamCreator(
                configuration
            ).downloadAttachment(attachmentId, emailId, apiKey, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the specified attachment for a given email as a base 64 encoded string. The response type is application/json. This method is similar to the `downloadAttachment` method but allows some clients to get around issues with binary responses.
         * @summary Get email attachment as base64 encoded string (alternative to binary responses)
         * @param {string} attachmentId ID of attachment
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachmentBase64(
            attachmentId: string,
            emailId: string,
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<DownloadAttachmentDto> {
            const localVarFetchArgs = EmailControllerApiFetchParamCreator(
                configuration
            ).downloadAttachmentBase64(attachmentId, emailId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Forward an existing email to new recipients.
         * @summary Forward email
         * @param {string} emailId ID of email
         * @param {ForwardEmailOptions} forwardEmailOptions forwardEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forwardEmail(
            emailId: string,
            forwardEmailOptions: ForwardEmailOptions,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EmailControllerApiFetchParamCreator(
                configuration
            ).forwardEmail(emailId, forwardEmailOptions, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the metadata such as name and content-type for a given attachment and email.
         * @summary Get email attachment metadata
         * @param {string} attachmentId ID of attachment
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachmentMetaData(
            attachmentId: string,
            emailId: string,
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<AttachmentMetaData> {
            const localVarFetchArgs = EmailControllerApiFetchParamCreator(
                configuration
            ).getAttachmentMetaData(attachmentId, emailId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns an array of attachment metadata such as name and content-type for a given email if present.
         * @summary Get all email attachment metadata
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachments(
            emailId: string,
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<Array<AttachmentMetaData>> {
            const localVarFetchArgs = EmailControllerApiFetchParamCreator(
                configuration
            ).getAttachments(emailId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawEmail endpoints
         * @summary Get email content
         * @param {string} emailId emailId
         * @param {boolean} [decode] Decode email body quoted-printable encoding to plain text. SMTP servers often encode text using quoted-printable format (for instance &#x60;&#x3D;D7&#x60;). This can be a pain for testing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmail(
            emailId: string,
            decode?: boolean,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Email> {
            const localVarFetchArgs = EmailControllerApiFetchParamCreator(
                configuration
            ).getEmail(emailId, decode, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve email content as HTML response for viewing in browsers. Decodes quoted-printable entities and converts charset to UTF-8. Pass your API KEY as a request parameter when viewing in a browser: `?apiKey=xxx`
         * @summary Get email content as HTML
         * @param {string} emailId emailId
         * @param {boolean} [decode] decode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailHTML(
            emailId: string,
            decode?: boolean,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = EmailControllerApiFetchParamCreator(
                configuration
            ).getEmailHTML(emailId, decode, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
         * @summary Get all emails
         * @param {Array<string>} [inboxId] Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account.
         * @param {number} [page] Optional page index in email list pagination
         * @param {number} [size] Optional page size in email list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {boolean} [unreadOnly] Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailsPaginated(
            inboxId?: Array<string>,
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            unreadOnly?: boolean,
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<PageEmailProjection> {
            const localVarFetchArgs = EmailControllerApiFetchParamCreator(
                configuration
            ).getEmailsPaginated(
                inboxId,
                page,
                size,
                sort,
                unreadOnly,
                options
            );
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a raw, unparsed, and unprocessed email. If your client has issues processing the response it is likely due to the response content-type which is text/plain. If you need a JSON response content-type use the getRawEmailJson endpoint
         * @summary Get raw email string
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawEmailContents(
            emailId: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = EmailControllerApiFetchParamCreator(
                configuration
            ).getRawEmailContents(emailId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a raw, unparsed, and unprocessed email wrapped in a JSON response object for easier handling when compared with the getRawEmail text/plain response
         * @summary Get raw email in JSON
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawEmailJson(
            emailId: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<RawEmailJson> {
            const localVarFetchArgs = EmailControllerApiFetchParamCreator(
                configuration
            ).getRawEmailJson(emailId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get number of emails unread
         * @summary Get unread email count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnreadEmailCount(
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<UnreadCount> {
            const localVarFetchArgs = EmailControllerApiFetchParamCreator(
                configuration
            ).getUnreadEmailCount(options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Validate the HTML content of email if HTML is found. Considered valid if no HTML.
         * @summary Validate email
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateEmail(
            emailId: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<ValidationDto> {
            const localVarFetchArgs = EmailControllerApiFetchParamCreator(
                configuration
            ).validateEmail(emailId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    };
};

/**
 * EmailControllerApi - factory interface
 * @export
 */
export const EmailControllerApiFactory = function(
    configuration?: Configuration,
    fetch?: FetchAPI,
    basePath?: string
) {
    return {
        /**
         * Deletes all emails in your account. Be careful as emails cannot be recovered
         * @summary Delete all emails
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllEmails(options?: any) {
            return EmailControllerApiFp(configuration).deleteAllEmails(options)(
                fetch,
                basePath
            );
        },
        /**
         * Deletes an email and removes it from the inbox. Deleted emails cannot be recovered.
         * @summary Delete an email
         * @param {string} emailId ID of email to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmail(emailId: string, options?: any) {
            return EmailControllerApiFp(configuration).deleteEmail(
                emailId,
                options
            )(fetch, basePath);
        },
        /**
         * Returns the specified attachment for a given email as a stream / array of bytes. You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
         * @summary Get email attachment bytes. If you have trouble with byte responses try the `downloadAttachmentBase64` response endpoints.
         * @param {string} attachmentId ID of attachment
         * @param {string} emailId ID of email
         * @param {string} [apiKey] Can pass apiKey in url for this request if you wish to download the file in a browser. Content type will be set to original content type of the attachment file. This is so that browsers can download the file correctly.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachment(
            attachmentId: string,
            emailId: string,
            apiKey?: string,
            options?: any
        ) {
            return EmailControllerApiFp(configuration).downloadAttachment(
                attachmentId,
                emailId,
                apiKey,
                options
            )(fetch, basePath);
        },
        /**
         * Returns the specified attachment for a given email as a base 64 encoded string. The response type is application/json. This method is similar to the `downloadAttachment` method but allows some clients to get around issues with binary responses.
         * @summary Get email attachment as base64 encoded string (alternative to binary responses)
         * @param {string} attachmentId ID of attachment
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachmentBase64(
            attachmentId: string,
            emailId: string,
            options?: any
        ) {
            return EmailControllerApiFp(configuration).downloadAttachmentBase64(
                attachmentId,
                emailId,
                options
            )(fetch, basePath);
        },
        /**
         * Forward an existing email to new recipients.
         * @summary Forward email
         * @param {string} emailId ID of email
         * @param {ForwardEmailOptions} forwardEmailOptions forwardEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forwardEmail(
            emailId: string,
            forwardEmailOptions: ForwardEmailOptions,
            options?: any
        ) {
            return EmailControllerApiFp(configuration).forwardEmail(
                emailId,
                forwardEmailOptions,
                options
            )(fetch, basePath);
        },
        /**
         * Returns the metadata such as name and content-type for a given attachment and email.
         * @summary Get email attachment metadata
         * @param {string} attachmentId ID of attachment
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachmentMetaData(
            attachmentId: string,
            emailId: string,
            options?: any
        ) {
            return EmailControllerApiFp(configuration).getAttachmentMetaData(
                attachmentId,
                emailId,
                options
            )(fetch, basePath);
        },
        /**
         * Returns an array of attachment metadata such as name and content-type for a given email if present.
         * @summary Get all email attachment metadata
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachments(emailId: string, options?: any) {
            return EmailControllerApiFp(configuration).getAttachments(
                emailId,
                options
            )(fetch, basePath);
        },
        /**
         * Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawEmail endpoints
         * @summary Get email content
         * @param {string} emailId emailId
         * @param {boolean} [decode] Decode email body quoted-printable encoding to plain text. SMTP servers often encode text using quoted-printable format (for instance &#x60;&#x3D;D7&#x60;). This can be a pain for testing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmail(emailId: string, decode?: boolean, options?: any) {
            return EmailControllerApiFp(configuration).getEmail(
                emailId,
                decode,
                options
            )(fetch, basePath);
        },
        /**
         * Retrieve email content as HTML response for viewing in browsers. Decodes quoted-printable entities and converts charset to UTF-8. Pass your API KEY as a request parameter when viewing in a browser: `?apiKey=xxx`
         * @summary Get email content as HTML
         * @param {string} emailId emailId
         * @param {boolean} [decode] decode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailHTML(emailId: string, decode?: boolean, options?: any) {
            return EmailControllerApiFp(configuration).getEmailHTML(
                emailId,
                decode,
                options
            )(fetch, basePath);
        },
        /**
         * By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
         * @summary Get all emails
         * @param {Array<string>} [inboxId] Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account.
         * @param {number} [page] Optional page index in email list pagination
         * @param {number} [size] Optional page size in email list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {boolean} [unreadOnly] Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailsPaginated(
            inboxId?: Array<string>,
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            unreadOnly?: boolean,
            options?: any
        ) {
            return EmailControllerApiFp(configuration).getEmailsPaginated(
                inboxId,
                page,
                size,
                sort,
                unreadOnly,
                options
            )(fetch, basePath);
        },
        /**
         * Returns a raw, unparsed, and unprocessed email. If your client has issues processing the response it is likely due to the response content-type which is text/plain. If you need a JSON response content-type use the getRawEmailJson endpoint
         * @summary Get raw email string
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawEmailContents(emailId: string, options?: any) {
            return EmailControllerApiFp(configuration).getRawEmailContents(
                emailId,
                options
            )(fetch, basePath);
        },
        /**
         * Returns a raw, unparsed, and unprocessed email wrapped in a JSON response object for easier handling when compared with the getRawEmail text/plain response
         * @summary Get raw email in JSON
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawEmailJson(emailId: string, options?: any) {
            return EmailControllerApiFp(configuration).getRawEmailJson(
                emailId,
                options
            )(fetch, basePath);
        },
        /**
         * Get number of emails unread
         * @summary Get unread email count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnreadEmailCount(options?: any) {
            return EmailControllerApiFp(configuration).getUnreadEmailCount(
                options
            )(fetch, basePath);
        },
        /**
         * Validate the HTML content of email if HTML is found. Considered valid if no HTML.
         * @summary Validate email
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateEmail(emailId: string, options?: any) {
            return EmailControllerApiFp(configuration).validateEmail(
                emailId,
                options
            )(fetch, basePath);
        },
    };
};

/**
 * EmailControllerApi - object-oriented interface
 * @export
 * @class EmailControllerApi
 * @extends {BaseAPI}
 */
export class EmailControllerApi extends BaseAPI {
    /**
     * Deletes all emails in your account. Be careful as emails cannot be recovered
     * @summary Delete all emails
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    public deleteAllEmails(options?: any) {
        return EmailControllerApiFp(this.configuration).deleteAllEmails(
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Deletes an email and removes it from the inbox. Deleted emails cannot be recovered.
     * @summary Delete an email
     * @param {string} emailId ID of email to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    public deleteEmail(emailId: string, options?: any) {
        return EmailControllerApiFp(this.configuration).deleteEmail(
            emailId,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Returns the specified attachment for a given email as a stream / array of bytes. You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
     * @summary Get email attachment bytes. If you have trouble with byte responses try the `downloadAttachmentBase64` response endpoints.
     * @param {string} attachmentId ID of attachment
     * @param {string} emailId ID of email
     * @param {string} [apiKey] Can pass apiKey in url for this request if you wish to download the file in a browser. Content type will be set to original content type of the attachment file. This is so that browsers can download the file correctly.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    public downloadAttachment(
        attachmentId: string,
        emailId: string,
        apiKey?: string,
        options?: any
    ) {
        return EmailControllerApiFp(this.configuration).downloadAttachment(
            attachmentId,
            emailId,
            apiKey,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Returns the specified attachment for a given email as a base 64 encoded string. The response type is application/json. This method is similar to the `downloadAttachment` method but allows some clients to get around issues with binary responses.
     * @summary Get email attachment as base64 encoded string (alternative to binary responses)
     * @param {string} attachmentId ID of attachment
     * @param {string} emailId ID of email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    public downloadAttachmentBase64(
        attachmentId: string,
        emailId: string,
        options?: any
    ) {
        return EmailControllerApiFp(
            this.configuration
        ).downloadAttachmentBase64(attachmentId, emailId, options)(
            this.fetch,
            this.basePath
        );
    }

    /**
     * Forward an existing email to new recipients.
     * @summary Forward email
     * @param {string} emailId ID of email
     * @param {ForwardEmailOptions} forwardEmailOptions forwardEmailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    public forwardEmail(
        emailId: string,
        forwardEmailOptions: ForwardEmailOptions,
        options?: any
    ) {
        return EmailControllerApiFp(this.configuration).forwardEmail(
            emailId,
            forwardEmailOptions,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Returns the metadata such as name and content-type for a given attachment and email.
     * @summary Get email attachment metadata
     * @param {string} attachmentId ID of attachment
     * @param {string} emailId ID of email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    public getAttachmentMetaData(
        attachmentId: string,
        emailId: string,
        options?: any
    ) {
        return EmailControllerApiFp(this.configuration).getAttachmentMetaData(
            attachmentId,
            emailId,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Returns an array of attachment metadata such as name and content-type for a given email if present.
     * @summary Get all email attachment metadata
     * @param {string} emailId ID of email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    public getAttachments(emailId: string, options?: any) {
        return EmailControllerApiFp(this.configuration).getAttachments(
            emailId,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawEmail endpoints
     * @summary Get email content
     * @param {string} emailId emailId
     * @param {boolean} [decode] Decode email body quoted-printable encoding to plain text. SMTP servers often encode text using quoted-printable format (for instance &#x60;&#x3D;D7&#x60;). This can be a pain for testing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    public getEmail(emailId: string, decode?: boolean, options?: any) {
        return EmailControllerApiFp(this.configuration).getEmail(
            emailId,
            decode,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Retrieve email content as HTML response for viewing in browsers. Decodes quoted-printable entities and converts charset to UTF-8. Pass your API KEY as a request parameter when viewing in a browser: `?apiKey=xxx`
     * @summary Get email content as HTML
     * @param {string} emailId emailId
     * @param {boolean} [decode] decode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    public getEmailHTML(emailId: string, decode?: boolean, options?: any) {
        return EmailControllerApiFp(this.configuration).getEmailHTML(
            emailId,
            decode,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
     * @summary Get all emails
     * @param {Array<string>} [inboxId] Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account.
     * @param {number} [page] Optional page index in email list pagination
     * @param {number} [size] Optional page size in email list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {boolean} [unreadOnly] Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    public getEmailsPaginated(
        inboxId?: Array<string>,
        page?: number,
        size?: number,
        sort?: 'ASC' | 'DESC',
        unreadOnly?: boolean,
        options?: any
    ) {
        return EmailControllerApiFp(this.configuration).getEmailsPaginated(
            inboxId,
            page,
            size,
            sort,
            unreadOnly,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Returns a raw, unparsed, and unprocessed email. If your client has issues processing the response it is likely due to the response content-type which is text/plain. If you need a JSON response content-type use the getRawEmailJson endpoint
     * @summary Get raw email string
     * @param {string} emailId ID of email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    public getRawEmailContents(emailId: string, options?: any) {
        return EmailControllerApiFp(this.configuration).getRawEmailContents(
            emailId,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Returns a raw, unparsed, and unprocessed email wrapped in a JSON response object for easier handling when compared with the getRawEmail text/plain response
     * @summary Get raw email in JSON
     * @param {string} emailId ID of email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    public getRawEmailJson(emailId: string, options?: any) {
        return EmailControllerApiFp(this.configuration).getRawEmailJson(
            emailId,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Get number of emails unread
     * @summary Get unread email count
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    public getUnreadEmailCount(options?: any) {
        return EmailControllerApiFp(this.configuration).getUnreadEmailCount(
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Validate the HTML content of email if HTML is found. Considered valid if no HTML.
     * @summary Validate email
     * @param {string} emailId ID of email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    public validateEmail(emailId: string, options?: any) {
        return EmailControllerApiFp(this.configuration).validateEmail(
            emailId,
            options
        )(this.fetch, this.basePath);
    }
}

/**
 * FormControllerApi - fetch parameter creator
 * @export
 */
export const FormControllerApiFetchParamCreator = function(
    configuration?: Configuration
) {
    return {
        /**
         * This endpoint allows you to submit HTML forms and receive the field values and files via email.   #### Parameters The endpoint looks for special meta parameters in the form fields OR in the URL request parameters. The meta parameters can be used to specify the behaviour of the email.   You must provide at-least a `_to` email address or a `_toAlias` email alias ID to tell the endpoint where the form should be emailed. These can be submitted as hidden HTML input fields with the corresponding `name` attributes or as URL query parameters such as `?_to=test@example.com`  The endpoint takes all other form fields that are named and includes them in the message body of the email. Files are sent as attachments.  #### Submitting This endpoint accepts form submission via POST method. It accepts `application/x-www-form-urlencoded`, and `multipart/form-data` content-types.  #### HTML Example ```html <form    action=\"https://api.mailslurp.com/forms\"   method=\"post\" >   <input name=\"_to\" type=\"hidden\" value=\"test@example.com\"/>   <textarea name=\"feedback\"></textarea>   <button type=\"submit\">Submit</button> </form> ```  #### URL Example ```html <form    action=\"https://api.mailslurp.com/forms?_toAlias=test@example.com\"   method=\"post\" >   <textarea name=\"feedback\"></textarea>   <button type=\"submit\">Submit</button> </form> ```    The email address is specified by a `_to` field OR is extracted from an email alias specified by a `_toAlias` field (see the alias controller for more information).  Endpoint accepts .  You can specify a content type in HTML forms using the `enctype` attribute, for instance: `<form enctype=\"multipart/form-data\">`.
         * @summary Submit a form to be parsed and sent as an email to an address determined by the form fields
         * @param {string} [emailAddress] Email address of the submitting user. Include this if you wish to record the submitters email address and reply to it later.
         * @param {string} [redirectTo] Optional URL to redirect form submitter to after submission. If not present user will see a success message.
         * @param {string} [spamCheck] Optional but recommended field that catches spammers out. Include as a hidden form field but LEAVE EMPTY. Spam-bots will usually fill every field. If the _spamCheck field is filled the form submission will be ignored.
         * @param {string} [subject] Optional subject of the email that will be sent.
         * @param {string} [successMessage] Optional success message to display if no _redirectTo present.
         * @param {string} [to] The email address that submitted form should be sent to. Either this or _toAlias must be present for a form to be successfully submitted..
         * @param {string} [toAlias] ID of an email alias to that form should be sent to. Aliases must be created before submission and can be used to hide an email address and reduce spam.
         * @param {string} [otherParameters] All other parameters or fields will be accepted and attached to the sent email. This includes files and any HTML form field with a name. These fields will become the body of the email that is sent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitForm(
            emailAddress?: string,
            redirectTo?: string,
            spamCheck?: string,
            subject?: string,
            successMessage?: string,
            to?: string,
            toAlias?: string,
            otherParameters?: string,
            options: any = {}
        ): FetchArgs {
            const localVarPath = `/forms`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (emailAddress !== undefined) {
                localVarFormParams.set('_emailAddress', emailAddress as any);
            }

            if (redirectTo !== undefined) {
                localVarFormParams.set('_redirectTo', redirectTo as any);
            }

            if (spamCheck !== undefined) {
                localVarFormParams.set('_spamCheck', spamCheck as any);
            }

            if (subject !== undefined) {
                localVarFormParams.set('_subject', subject as any);
            }

            if (successMessage !== undefined) {
                localVarFormParams.set(
                    '_successMessage',
                    successMessage as any
                );
            }

            if (to !== undefined) {
                localVarFormParams.set('_to', to as any);
            }

            if (toAlias !== undefined) {
                localVarFormParams.set('_toAlias', toAlias as any);
            }

            if (otherParameters !== undefined) {
                localVarFormParams.set(
                    'otherParameters',
                    otherParameters as any
                );
            }

            localVarHeaderParameter['Content-Type'] =
                'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * FormControllerApi - functional programming interface
 * @export
 */
export const FormControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This endpoint allows you to submit HTML forms and receive the field values and files via email.   #### Parameters The endpoint looks for special meta parameters in the form fields OR in the URL request parameters. The meta parameters can be used to specify the behaviour of the email.   You must provide at-least a `_to` email address or a `_toAlias` email alias ID to tell the endpoint where the form should be emailed. These can be submitted as hidden HTML input fields with the corresponding `name` attributes or as URL query parameters such as `?_to=test@example.com`  The endpoint takes all other form fields that are named and includes them in the message body of the email. Files are sent as attachments.  #### Submitting This endpoint accepts form submission via POST method. It accepts `application/x-www-form-urlencoded`, and `multipart/form-data` content-types.  #### HTML Example ```html <form    action=\"https://api.mailslurp.com/forms\"   method=\"post\" >   <input name=\"_to\" type=\"hidden\" value=\"test@example.com\"/>   <textarea name=\"feedback\"></textarea>   <button type=\"submit\">Submit</button> </form> ```  #### URL Example ```html <form    action=\"https://api.mailslurp.com/forms?_toAlias=test@example.com\"   method=\"post\" >   <textarea name=\"feedback\"></textarea>   <button type=\"submit\">Submit</button> </form> ```    The email address is specified by a `_to` field OR is extracted from an email alias specified by a `_toAlias` field (see the alias controller for more information).  Endpoint accepts .  You can specify a content type in HTML forms using the `enctype` attribute, for instance: `<form enctype=\"multipart/form-data\">`.
         * @summary Submit a form to be parsed and sent as an email to an address determined by the form fields
         * @param {string} [emailAddress] Email address of the submitting user. Include this if you wish to record the submitters email address and reply to it later.
         * @param {string} [redirectTo] Optional URL to redirect form submitter to after submission. If not present user will see a success message.
         * @param {string} [spamCheck] Optional but recommended field that catches spammers out. Include as a hidden form field but LEAVE EMPTY. Spam-bots will usually fill every field. If the _spamCheck field is filled the form submission will be ignored.
         * @param {string} [subject] Optional subject of the email that will be sent.
         * @param {string} [successMessage] Optional success message to display if no _redirectTo present.
         * @param {string} [to] The email address that submitted form should be sent to. Either this or _toAlias must be present for a form to be successfully submitted..
         * @param {string} [toAlias] ID of an email alias to that form should be sent to. Aliases must be created before submission and can be used to hide an email address and reduce spam.
         * @param {string} [otherParameters] All other parameters or fields will be accepted and attached to the sent email. This includes files and any HTML form field with a name. These fields will become the body of the email that is sent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitForm(
            emailAddress?: string,
            redirectTo?: string,
            spamCheck?: string,
            subject?: string,
            successMessage?: string,
            to?: string,
            toAlias?: string,
            otherParameters?: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = FormControllerApiFetchParamCreator(
                configuration
            ).submitForm(
                emailAddress,
                redirectTo,
                spamCheck,
                subject,
                successMessage,
                to,
                toAlias,
                otherParameters,
                options
            );
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    };
};

/**
 * FormControllerApi - factory interface
 * @export
 */
export const FormControllerApiFactory = function(
    configuration?: Configuration,
    fetch?: FetchAPI,
    basePath?: string
) {
    return {
        /**
         * This endpoint allows you to submit HTML forms and receive the field values and files via email.   #### Parameters The endpoint looks for special meta parameters in the form fields OR in the URL request parameters. The meta parameters can be used to specify the behaviour of the email.   You must provide at-least a `_to` email address or a `_toAlias` email alias ID to tell the endpoint where the form should be emailed. These can be submitted as hidden HTML input fields with the corresponding `name` attributes or as URL query parameters such as `?_to=test@example.com`  The endpoint takes all other form fields that are named and includes them in the message body of the email. Files are sent as attachments.  #### Submitting This endpoint accepts form submission via POST method. It accepts `application/x-www-form-urlencoded`, and `multipart/form-data` content-types.  #### HTML Example ```html <form    action=\"https://api.mailslurp.com/forms\"   method=\"post\" >   <input name=\"_to\" type=\"hidden\" value=\"test@example.com\"/>   <textarea name=\"feedback\"></textarea>   <button type=\"submit\">Submit</button> </form> ```  #### URL Example ```html <form    action=\"https://api.mailslurp.com/forms?_toAlias=test@example.com\"   method=\"post\" >   <textarea name=\"feedback\"></textarea>   <button type=\"submit\">Submit</button> </form> ```    The email address is specified by a `_to` field OR is extracted from an email alias specified by a `_toAlias` field (see the alias controller for more information).  Endpoint accepts .  You can specify a content type in HTML forms using the `enctype` attribute, for instance: `<form enctype=\"multipart/form-data\">`.
         * @summary Submit a form to be parsed and sent as an email to an address determined by the form fields
         * @param {string} [emailAddress] Email address of the submitting user. Include this if you wish to record the submitters email address and reply to it later.
         * @param {string} [redirectTo] Optional URL to redirect form submitter to after submission. If not present user will see a success message.
         * @param {string} [spamCheck] Optional but recommended field that catches spammers out. Include as a hidden form field but LEAVE EMPTY. Spam-bots will usually fill every field. If the _spamCheck field is filled the form submission will be ignored.
         * @param {string} [subject] Optional subject of the email that will be sent.
         * @param {string} [successMessage] Optional success message to display if no _redirectTo present.
         * @param {string} [to] The email address that submitted form should be sent to. Either this or _toAlias must be present for a form to be successfully submitted..
         * @param {string} [toAlias] ID of an email alias to that form should be sent to. Aliases must be created before submission and can be used to hide an email address and reduce spam.
         * @param {string} [otherParameters] All other parameters or fields will be accepted and attached to the sent email. This includes files and any HTML form field with a name. These fields will become the body of the email that is sent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitForm(
            emailAddress?: string,
            redirectTo?: string,
            spamCheck?: string,
            subject?: string,
            successMessage?: string,
            to?: string,
            toAlias?: string,
            otherParameters?: string,
            options?: any
        ) {
            return FormControllerApiFp(configuration).submitForm(
                emailAddress,
                redirectTo,
                spamCheck,
                subject,
                successMessage,
                to,
                toAlias,
                otherParameters,
                options
            )(fetch, basePath);
        },
    };
};

/**
 * FormControllerApi - object-oriented interface
 * @export
 * @class FormControllerApi
 * @extends {BaseAPI}
 */
export class FormControllerApi extends BaseAPI {
    /**
     * This endpoint allows you to submit HTML forms and receive the field values and files via email.   #### Parameters The endpoint looks for special meta parameters in the form fields OR in the URL request parameters. The meta parameters can be used to specify the behaviour of the email.   You must provide at-least a `_to` email address or a `_toAlias` email alias ID to tell the endpoint where the form should be emailed. These can be submitted as hidden HTML input fields with the corresponding `name` attributes or as URL query parameters such as `?_to=test@example.com`  The endpoint takes all other form fields that are named and includes them in the message body of the email. Files are sent as attachments.  #### Submitting This endpoint accepts form submission via POST method. It accepts `application/x-www-form-urlencoded`, and `multipart/form-data` content-types.  #### HTML Example ```html <form    action=\"https://api.mailslurp.com/forms\"   method=\"post\" >   <input name=\"_to\" type=\"hidden\" value=\"test@example.com\"/>   <textarea name=\"feedback\"></textarea>   <button type=\"submit\">Submit</button> </form> ```  #### URL Example ```html <form    action=\"https://api.mailslurp.com/forms?_toAlias=test@example.com\"   method=\"post\" >   <textarea name=\"feedback\"></textarea>   <button type=\"submit\">Submit</button> </form> ```    The email address is specified by a `_to` field OR is extracted from an email alias specified by a `_toAlias` field (see the alias controller for more information).  Endpoint accepts .  You can specify a content type in HTML forms using the `enctype` attribute, for instance: `<form enctype=\"multipart/form-data\">`.
     * @summary Submit a form to be parsed and sent as an email to an address determined by the form fields
     * @param {string} [emailAddress] Email address of the submitting user. Include this if you wish to record the submitters email address and reply to it later.
     * @param {string} [redirectTo] Optional URL to redirect form submitter to after submission. If not present user will see a success message.
     * @param {string} [spamCheck] Optional but recommended field that catches spammers out. Include as a hidden form field but LEAVE EMPTY. Spam-bots will usually fill every field. If the _spamCheck field is filled the form submission will be ignored.
     * @param {string} [subject] Optional subject of the email that will be sent.
     * @param {string} [successMessage] Optional success message to display if no _redirectTo present.
     * @param {string} [to] The email address that submitted form should be sent to. Either this or _toAlias must be present for a form to be successfully submitted..
     * @param {string} [toAlias] ID of an email alias to that form should be sent to. Aliases must be created before submission and can be used to hide an email address and reduce spam.
     * @param {string} [otherParameters] All other parameters or fields will be accepted and attached to the sent email. This includes files and any HTML form field with a name. These fields will become the body of the email that is sent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormControllerApi
     */
    public submitForm(
        emailAddress?: string,
        redirectTo?: string,
        spamCheck?: string,
        subject?: string,
        successMessage?: string,
        to?: string,
        toAlias?: string,
        otherParameters?: string,
        options?: any
    ) {
        return FormControllerApiFp(this.configuration).submitForm(
            emailAddress,
            redirectTo,
            spamCheck,
            subject,
            successMessage,
            to,
            toAlias,
            otherParameters,
            options
        )(this.fetch, this.basePath);
    }
}

/**
 * GroupControllerApi - fetch parameter creator
 * @export
 */
export const GroupControllerApiFetchParamCreator = function(
    configuration?: Configuration
) {
    return {
        /**
         *
         * @summary Add contacts to a group
         * @param {string} groupId groupId
         * @param {UpdateGroupContacts} updateGroupContactsOption updateGroupContactsOption
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addContactsToGroup(
            groupId: string,
            updateGroupContactsOption: UpdateGroupContacts,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError(
                    'groupId',
                    'Required parameter groupId was null or undefined when calling addContactsToGroup.'
                );
            }
            // verify required parameter 'updateGroupContactsOption' is not null or undefined
            if (
                updateGroupContactsOption === null ||
                updateGroupContactsOption === undefined
            ) {
                throw new RequiredError(
                    'updateGroupContactsOption',
                    'Required parameter updateGroupContactsOption was null or undefined when calling addContactsToGroup.'
                );
            }
            const localVarPath = `/groups/{groupId}/contacts`.replace(
                `{${'groupId'}}`,
                encodeURIComponent(String(groupId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'PUT' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'UpdateGroupContacts' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(updateGroupContactsOption || {})
                : updateGroupContactsOption || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a group
         * @param {CreateGroupOptions} createGroupOptions createGroupOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(
            createGroupOptions: CreateGroupOptions,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'createGroupOptions' is not null or undefined
            if (
                createGroupOptions === null ||
                createGroupOptions === undefined
            ) {
                throw new RequiredError(
                    'createGroupOptions',
                    'Required parameter createGroupOptions was null or undefined when calling createGroup.'
                );
            }
            const localVarPath = `/groups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'CreateGroupOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(createGroupOptions || {})
                : createGroupOptions || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete group
         * @param {string} groupId groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(groupId: string, options: any = {}): FetchArgs {
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError(
                    'groupId',
                    'Required parameter groupId was null or undefined when calling deleteGroup.'
                );
            }
            const localVarPath = `/groups/{groupId}`.replace(
                `{${'groupId'}}`,
                encodeURIComponent(String(groupId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'DELETE' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Contact Groups in paginated format
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllGroups(
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options: any = {}
        ): FetchArgs {
            const localVarPath = `/groups/paginated`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get group
         * @param {string} groupId groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(groupId: string, options: any = {}): FetchArgs {
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError(
                    'groupId',
                    'Required parameter groupId was null or undefined when calling getGroup.'
                );
            }
            const localVarPath = `/groups/{groupId}`.replace(
                `{${'groupId'}}`,
                encodeURIComponent(String(groupId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get group and contacts belonging to it
         * @param {string} groupId groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupWithContacts(groupId: string, options: any = {}): FetchArgs {
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError(
                    'groupId',
                    'Required parameter groupId was null or undefined when calling getGroupWithContacts.'
                );
            }
            const localVarPath = `/groups/{groupId}/contacts`.replace(
                `{${'groupId'}}`,
                encodeURIComponent(String(groupId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get group and paginated contacts belonging to it
         * @param {string} groupId groupId
         * @param {number} [page] Optional page index in group contact pagination
         * @param {number} [size] Optional page size in group contact pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupWithContactsPaginated(
            groupId: string,
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError(
                    'groupId',
                    'Required parameter groupId was null or undefined when calling getGroupWithContactsPaginated.'
                );
            }
            const localVarPath = `/groups/{groupId}/contacts-paginated`.replace(
                `{${'groupId'}}`,
                encodeURIComponent(String(groupId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups(options: any = {}): FetchArgs {
            const localVarPath = `/groups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Remove contacts from a group
         * @param {string} groupId groupId
         * @param {UpdateGroupContacts} updateGroupContactsOption updateGroupContactsOption
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeContactsFromGroup(
            groupId: string,
            updateGroupContactsOption: UpdateGroupContacts,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError(
                    'groupId',
                    'Required parameter groupId was null or undefined when calling removeContactsFromGroup.'
                );
            }
            // verify required parameter 'updateGroupContactsOption' is not null or undefined
            if (
                updateGroupContactsOption === null ||
                updateGroupContactsOption === undefined
            ) {
                throw new RequiredError(
                    'updateGroupContactsOption',
                    'Required parameter updateGroupContactsOption was null or undefined when calling removeContactsFromGroup.'
                );
            }
            const localVarPath = `/groups/{groupId}/contacts`.replace(
                `{${'groupId'}}`,
                encodeURIComponent(String(groupId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'DELETE' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'UpdateGroupContacts' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(updateGroupContactsOption || {})
                : updateGroupContactsOption || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * GroupControllerApi - functional programming interface
 * @export
 */
export const GroupControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Add contacts to a group
         * @param {string} groupId groupId
         * @param {UpdateGroupContacts} updateGroupContactsOption updateGroupContactsOption
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addContactsToGroup(
            groupId: string,
            updateGroupContactsOption: UpdateGroupContacts,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<GroupContactsDto> {
            const localVarFetchArgs = GroupControllerApiFetchParamCreator(
                configuration
            ).addContactsToGroup(groupId, updateGroupContactsOption, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Create a group
         * @param {CreateGroupOptions} createGroupOptions createGroupOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(
            createGroupOptions: CreateGroupOptions,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<GroupDto> {
            const localVarFetchArgs = GroupControllerApiFetchParamCreator(
                configuration
            ).createGroup(createGroupOptions, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete group
         * @param {string} groupId groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(
            groupId: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = GroupControllerApiFetchParamCreator(
                configuration
            ).deleteGroup(groupId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all Contact Groups in paginated format
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllGroups(
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<PageGroupProjection> {
            const localVarFetchArgs = GroupControllerApiFetchParamCreator(
                configuration
            ).getAllGroups(page, size, sort, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get group
         * @param {string} groupId groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(
            groupId: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<GroupDto> {
            const localVarFetchArgs = GroupControllerApiFetchParamCreator(
                configuration
            ).getGroup(groupId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get group and contacts belonging to it
         * @param {string} groupId groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupWithContacts(
            groupId: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<GroupContactsDto> {
            const localVarFetchArgs = GroupControllerApiFetchParamCreator(
                configuration
            ).getGroupWithContacts(groupId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get group and paginated contacts belonging to it
         * @param {string} groupId groupId
         * @param {number} [page] Optional page index in group contact pagination
         * @param {number} [size] Optional page size in group contact pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupWithContactsPaginated(
            groupId: string,
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<PageContactProjection> {
            const localVarFetchArgs = GroupControllerApiFetchParamCreator(
                configuration
            ).getGroupWithContactsPaginated(groupId, page, size, sort, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups(
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<Array<GroupProjection>> {
            const localVarFetchArgs = GroupControllerApiFetchParamCreator(
                configuration
            ).getGroups(options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Remove contacts from a group
         * @param {string} groupId groupId
         * @param {UpdateGroupContacts} updateGroupContactsOption updateGroupContactsOption
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeContactsFromGroup(
            groupId: string,
            updateGroupContactsOption: UpdateGroupContacts,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<GroupContactsDto> {
            const localVarFetchArgs = GroupControllerApiFetchParamCreator(
                configuration
            ).removeContactsFromGroup(
                groupId,
                updateGroupContactsOption,
                options
            );
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    };
};

/**
 * GroupControllerApi - factory interface
 * @export
 */
export const GroupControllerApiFactory = function(
    configuration?: Configuration,
    fetch?: FetchAPI,
    basePath?: string
) {
    return {
        /**
         *
         * @summary Add contacts to a group
         * @param {string} groupId groupId
         * @param {UpdateGroupContacts} updateGroupContactsOption updateGroupContactsOption
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addContactsToGroup(
            groupId: string,
            updateGroupContactsOption: UpdateGroupContacts,
            options?: any
        ) {
            return GroupControllerApiFp(configuration).addContactsToGroup(
                groupId,
                updateGroupContactsOption,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Create a group
         * @param {CreateGroupOptions} createGroupOptions createGroupOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(createGroupOptions: CreateGroupOptions, options?: any) {
            return GroupControllerApiFp(configuration).createGroup(
                createGroupOptions,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Delete group
         * @param {string} groupId groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(groupId: string, options?: any) {
            return GroupControllerApiFp(configuration).deleteGroup(
                groupId,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Get all Contact Groups in paginated format
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllGroups(
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ) {
            return GroupControllerApiFp(configuration).getAllGroups(
                page,
                size,
                sort,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Get group
         * @param {string} groupId groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(groupId: string, options?: any) {
            return GroupControllerApiFp(configuration).getGroup(
                groupId,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Get group and contacts belonging to it
         * @param {string} groupId groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupWithContacts(groupId: string, options?: any) {
            return GroupControllerApiFp(configuration).getGroupWithContacts(
                groupId,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Get group and paginated contacts belonging to it
         * @param {string} groupId groupId
         * @param {number} [page] Optional page index in group contact pagination
         * @param {number} [size] Optional page size in group contact pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupWithContactsPaginated(
            groupId: string,
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ) {
            return GroupControllerApiFp(
                configuration
            ).getGroupWithContactsPaginated(groupId, page, size, sort, options)(
                fetch,
                basePath
            );
        },
        /**
         *
         * @summary Get all groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups(options?: any) {
            return GroupControllerApiFp(configuration).getGroups(options)(
                fetch,
                basePath
            );
        },
        /**
         *
         * @summary Remove contacts from a group
         * @param {string} groupId groupId
         * @param {UpdateGroupContacts} updateGroupContactsOption updateGroupContactsOption
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeContactsFromGroup(
            groupId: string,
            updateGroupContactsOption: UpdateGroupContacts,
            options?: any
        ) {
            return GroupControllerApiFp(configuration).removeContactsFromGroup(
                groupId,
                updateGroupContactsOption,
                options
            )(fetch, basePath);
        },
    };
};

/**
 * GroupControllerApi - object-oriented interface
 * @export
 * @class GroupControllerApi
 * @extends {BaseAPI}
 */
export class GroupControllerApi extends BaseAPI {
    /**
     *
     * @summary Add contacts to a group
     * @param {string} groupId groupId
     * @param {UpdateGroupContacts} updateGroupContactsOption updateGroupContactsOption
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupControllerApi
     */
    public addContactsToGroup(
        groupId: string,
        updateGroupContactsOption: UpdateGroupContacts,
        options?: any
    ) {
        return GroupControllerApiFp(this.configuration).addContactsToGroup(
            groupId,
            updateGroupContactsOption,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Create a group
     * @param {CreateGroupOptions} createGroupOptions createGroupOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupControllerApi
     */
    public createGroup(createGroupOptions: CreateGroupOptions, options?: any) {
        return GroupControllerApiFp(this.configuration).createGroup(
            createGroupOptions,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Delete group
     * @param {string} groupId groupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupControllerApi
     */
    public deleteGroup(groupId: string, options?: any) {
        return GroupControllerApiFp(this.configuration).deleteGroup(
            groupId,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get all Contact Groups in paginated format
     * @param {number} [page] Optional page index in inbox list pagination
     * @param {number} [size] Optional page size in inbox list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupControllerApi
     */
    public getAllGroups(
        page?: number,
        size?: number,
        sort?: 'ASC' | 'DESC',
        options?: any
    ) {
        return GroupControllerApiFp(this.configuration).getAllGroups(
            page,
            size,
            sort,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get group
     * @param {string} groupId groupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupControllerApi
     */
    public getGroup(groupId: string, options?: any) {
        return GroupControllerApiFp(this.configuration).getGroup(
            groupId,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get group and contacts belonging to it
     * @param {string} groupId groupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupControllerApi
     */
    public getGroupWithContacts(groupId: string, options?: any) {
        return GroupControllerApiFp(this.configuration).getGroupWithContacts(
            groupId,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get group and paginated contacts belonging to it
     * @param {string} groupId groupId
     * @param {number} [page] Optional page index in group contact pagination
     * @param {number} [size] Optional page size in group contact pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupControllerApi
     */
    public getGroupWithContactsPaginated(
        groupId: string,
        page?: number,
        size?: number,
        sort?: 'ASC' | 'DESC',
        options?: any
    ) {
        return GroupControllerApiFp(
            this.configuration
        ).getGroupWithContactsPaginated(groupId, page, size, sort, options)(
            this.fetch,
            this.basePath
        );
    }

    /**
     *
     * @summary Get all groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupControllerApi
     */
    public getGroups(options?: any) {
        return GroupControllerApiFp(this.configuration).getGroups(options)(
            this.fetch,
            this.basePath
        );
    }

    /**
     *
     * @summary Remove contacts from a group
     * @param {string} groupId groupId
     * @param {UpdateGroupContacts} updateGroupContactsOption updateGroupContactsOption
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupControllerApi
     */
    public removeContactsFromGroup(
        groupId: string,
        updateGroupContactsOption: UpdateGroupContacts,
        options?: any
    ) {
        return GroupControllerApiFp(this.configuration).removeContactsFromGroup(
            groupId,
            updateGroupContactsOption,
            options
        )(this.fetch, this.basePath);
    }
}

/**
 * InboxControllerApi - fetch parameter creator
 * @export
 */
export const InboxControllerApiFetchParamCreator = function(
    configuration?: Configuration
) {
    return {
        /**
         * Create a new inbox and with a randomized email address to send and receive from. Pass emailAddress parameter if you wish to use a specific email address. Creating an inbox is required before sending or receiving emails. If writing tests it is recommended that you create a new inbox during each test method so that it is unique and empty.
         * @summary Create an Inbox (email address)
         * @param {string} [description] Optional description for an inbox.
         * @param {string} [emailAddress] Optional email address including domain you wish inbox to use (eg: test123@mydomain.com). Only supports domains that you have registered and verified with MailSlurp using dashboard or &#x60;createDomain&#x60; method.
         * @param {Date} [expiresAt] Optional expires at timestamp. If your plan supports this feature you can specify when an inbox should expire. If left empty inbox will exist permanently or expire when your plan dictates
         * @param {boolean} [favourite] Is inbox favourited.
         * @param {string} [name] Optional name for an inbox.
         * @param {Array<string>} [tags] Optional tags for an inbox. Can be used for searching and filtering inboxes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInbox(
            description?: string,
            emailAddress?: string,
            expiresAt?: Date,
            favourite?: boolean,
            name?: string,
            tags?: Array<string>,
            options: any = {}
        ): FetchArgs {
            const localVarPath = `/inboxes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (emailAddress !== undefined) {
                localVarQueryParameter['emailAddress'] = emailAddress;
            }

            if (expiresAt !== undefined) {
                localVarQueryParameter[
                    'expiresAt'
                ] = (expiresAt as any).toISOString();
            }

            if (favourite !== undefined) {
                localVarQueryParameter['favourite'] = favourite;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently delete all inboxes and associated email addresses. This will also delete all emails within the inboxes. Be careful as inboxes cannot be recovered once deleted. Note: deleting inboxes will not impact your usage limits. Monthly inbox creation limits are based on how many inboxes were created in the last 30 days, not how many inboxes you currently have.
         * @summary Delete all inboxes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllInboxes(options: any = {}): FetchArgs {
            const localVarPath = `/inboxes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'DELETE' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently delete an inbox and associated email address aswell as all emails within the given inbox. This action cannot be undone. Note: deleting an inbox will not affect your account usage. Monthly inbox usage is based on how many inboxes you create within 30 days, not how many exist at time of request.
         * @summary Delete inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInbox(inboxId: string, options: any = {}): FetchArgs {
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError(
                    'inboxId',
                    'Required parameter inboxId was null or undefined when calling deleteInbox.'
                );
            }
            const localVarPath = `/inboxes/{inboxId}`.replace(
                `{${'inboxId'}}`,
                encodeURIComponent(String(inboxId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'DELETE' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List inboxes in paginated form. Allows for page index, page size, and sort direction. Can also filter by favourited or email address like pattern.
         * @summary List Inboxes Paginated
         * @param {boolean} [favourite] Optionally filter results for favourites only
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {string} [search] Optionally filter by search words partial matching ID, tags, name, and email address
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {string} [tag] Optionally filter by tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllInboxes(
            favourite?: boolean,
            page?: number,
            search?: string,
            size?: number,
            sort?: 'ASC' | 'DESC',
            tag?: string,
            options: any = {}
        ): FetchArgs {
            const localVarPath = `/inboxes/paginated`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (favourite !== undefined) {
                localVarQueryParameter['favourite'] = favourite;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List emails that an inbox has received. Only emails that are sent to the inbox's email address will appear in the inbox. It may take several seconds for any email you send to an inbox's email address to appear in the inbox. To make this endpoint wait for a minimum number of emails use the `minCount` parameter. The server will retry the inbox database until the `minCount` is satisfied or the `retryTimeout` is reached
         * @summary Get emails in an Inbox
         * @param {string} inboxId Id of inbox that emails belongs to
         * @param {number} [limit] Limit the result set, ordered by received date time sort direction
         * @param {number} [minCount] Minimum acceptable email count. Will cause request to hang (and retry) until minCount is satisfied or retryTimeout is reached.
         * @param {number} [retryTimeout] Maximum milliseconds to spend retrying inbox database until minCount emails are returned
         * @param {Date} [since] Exclude emails received before this ISO 8601 date time
         * @param {'ASC' | 'DESC'} [sort] Sort the results by received date and direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmails(
            inboxId: string,
            limit?: number,
            minCount?: number,
            retryTimeout?: number,
            since?: Date,
            sort?: 'ASC' | 'DESC',
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError(
                    'inboxId',
                    'Required parameter inboxId was null or undefined when calling getEmails.'
                );
            }
            const localVarPath = `/inboxes/{inboxId}/emails`.replace(
                `{${'inboxId'}}`,
                encodeURIComponent(String(inboxId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (minCount !== undefined) {
                localVarQueryParameter['minCount'] = minCount;
            }

            if (retryTimeout !== undefined) {
                localVarQueryParameter['retryTimeout'] = retryTimeout;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = (since as any).toISOString();
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an inbox's properties, including its email address and ID.
         * @summary Get Inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInbox(inboxId: string, options: any = {}): FetchArgs {
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError(
                    'inboxId',
                    'Required parameter inboxId was null or undefined when calling getInbox.'
                );
            }
            const localVarPath = `/inboxes/{inboxId}`.replace(
                `{${'inboxId'}}`,
                encodeURIComponent(String(inboxId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a paginated list of emails in an inbox. Does not hold connections open.
         * @summary Get inbox emails paginated
         * @param {string} inboxId Id of inbox that emails belongs to
         * @param {number} [page] Optional page index in inbox emails list pagination
         * @param {number} [size] Optional page size in inbox emails list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxEmailsPaginated(
            inboxId: string,
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError(
                    'inboxId',
                    'Required parameter inboxId was null or undefined when calling getInboxEmailsPaginated.'
                );
            }
            const localVarPath = `/inboxes/{inboxId}/emails/paginated`.replace(
                `{${'inboxId'}}`,
                encodeURIComponent(String(inboxId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an inbox's sent email receipts. Call individual sent email endpoints for more details. Note for privacy reasons the full body of sent emails is never stored. An MD5 hash hex is available for comparison instead.
         * @summary Get Inbox Sent Emails
         * @param {string} inboxId inboxId
         * @param {number} [page] Optional page index in inbox sent email list pagination
         * @param {number} [size] Optional page size in inbox sent email list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxSentEmails(
            inboxId: string,
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError(
                    'inboxId',
                    'Required parameter inboxId was null or undefined when calling getInboxSentEmails.'
                );
            }
            const localVarPath = `/inboxes/{inboxId}/sent`.replace(
                `{${'inboxId'}}`,
                encodeURIComponent(String(inboxId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all inbox tags
         * @summary Get inbox tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxTags(options: any = {}): FetchArgs {
            const localVarPath = `/inboxes/tags`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the inboxes you have created
         * @summary List Inboxes / Email Addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxes(options: any = {}): FetchArgs {
            const localVarPath = `/inboxes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send an email from an inbox's email address.  The request body should contain the `SendEmailOptions` that include recipients, attachments, body etc. See `SendEmailOptions` for all available properties. Note the `inboxId` refers to the inbox's id not the inbox's email address. See https://www.mailslurp.com/guides/ for more information on how to send emails. This method does not return a sent email entity due to legacy reasons. To send and get a sent email as returned response use the sister method `sendEmailAndConfirm`.
         * @summary Send Email
         * @param {string} inboxId ID of the inbox you want to send the email from
         * @param {SendEmailOptions} [sendEmailOptions] Options for the email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmail(
            inboxId: string,
            sendEmailOptions?: SendEmailOptions,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError(
                    'inboxId',
                    'Required parameter inboxId was null or undefined when calling sendEmail.'
                );
            }
            const localVarPath = `/inboxes/{inboxId}`.replace(
                `{${'inboxId'}}`,
                encodeURIComponent(String(inboxId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'SendEmailOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(sendEmailOptions || {})
                : sendEmailOptions || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sister method for standard `sendEmail` method with the benefit of returning a `SentEmail` entity confirming the successful sending of the email with link the the sent object created for it.
         * @summary Send email and return sent confirmation
         * @param {string} inboxId ID of the inbox you want to send the email from
         * @param {SendEmailOptions} [sendEmailOptions] Options for the email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailAndConfirm(
            inboxId: string,
            sendEmailOptions?: SendEmailOptions,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError(
                    'inboxId',
                    'Required parameter inboxId was null or undefined when calling sendEmailAndConfirm.'
                );
            }
            const localVarPath = `/inboxes/{inboxId}/confirm`.replace(
                `{${'inboxId'}}`,
                encodeURIComponent(String(inboxId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'SendEmailOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(sendEmailOptions || {})
                : sendEmailOptions || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set and return new favourite state for an inbox
         * @summary Set inbox favourited state
         * @param {string} inboxId inboxId
         * @param {SetInboxFavouritedOptions} setInboxFavouritedOptions setInboxFavouritedOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setInboxFavourited(
            inboxId: string,
            setInboxFavouritedOptions: SetInboxFavouritedOptions,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError(
                    'inboxId',
                    'Required parameter inboxId was null or undefined when calling setInboxFavourited.'
                );
            }
            // verify required parameter 'setInboxFavouritedOptions' is not null or undefined
            if (
                setInboxFavouritedOptions === null ||
                setInboxFavouritedOptions === undefined
            ) {
                throw new RequiredError(
                    'setInboxFavouritedOptions',
                    'Required parameter setInboxFavouritedOptions was null or undefined when calling setInboxFavourited.'
                );
            }
            const localVarPath = `/inboxes/{inboxId}/favourite`.replace(
                `{${'inboxId'}}`,
                encodeURIComponent(String(inboxId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'PUT' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'SetInboxFavouritedOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(setInboxFavouritedOptions || {})
                : setInboxFavouritedOptions || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update editable fields on an inbox
         * @summary Update Inbox
         * @param {string} inboxId inboxId
         * @param {UpdateInboxOptions} updateInboxOptions updateInboxOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInbox(
            inboxId: string,
            updateInboxOptions: UpdateInboxOptions,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError(
                    'inboxId',
                    'Required parameter inboxId was null or undefined when calling updateInbox.'
                );
            }
            // verify required parameter 'updateInboxOptions' is not null or undefined
            if (
                updateInboxOptions === null ||
                updateInboxOptions === undefined
            ) {
                throw new RequiredError(
                    'updateInboxOptions',
                    'Required parameter updateInboxOptions was null or undefined when calling updateInbox.'
                );
            }
            const localVarPath = `/inboxes/{inboxId}`.replace(
                `{${'inboxId'}}`,
                encodeURIComponent(String(inboxId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'PATCH' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'UpdateInboxOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(updateInboxOptions || {})
                : updateInboxOptions || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * InboxControllerApi - functional programming interface
 * @export
 */
export const InboxControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a new inbox and with a randomized email address to send and receive from. Pass emailAddress parameter if you wish to use a specific email address. Creating an inbox is required before sending or receiving emails. If writing tests it is recommended that you create a new inbox during each test method so that it is unique and empty.
         * @summary Create an Inbox (email address)
         * @param {string} [description] Optional description for an inbox.
         * @param {string} [emailAddress] Optional email address including domain you wish inbox to use (eg: test123@mydomain.com). Only supports domains that you have registered and verified with MailSlurp using dashboard or &#x60;createDomain&#x60; method.
         * @param {Date} [expiresAt] Optional expires at timestamp. If your plan supports this feature you can specify when an inbox should expire. If left empty inbox will exist permanently or expire when your plan dictates
         * @param {boolean} [favourite] Is inbox favourited.
         * @param {string} [name] Optional name for an inbox.
         * @param {Array<string>} [tags] Optional tags for an inbox. Can be used for searching and filtering inboxes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInbox(
            description?: string,
            emailAddress?: string,
            expiresAt?: Date,
            favourite?: boolean,
            name?: string,
            tags?: Array<string>,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Inbox> {
            const localVarFetchArgs = InboxControllerApiFetchParamCreator(
                configuration
            ).createInbox(
                description,
                emailAddress,
                expiresAt,
                favourite,
                name,
                tags,
                options
            );
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Permanently delete all inboxes and associated email addresses. This will also delete all emails within the inboxes. Be careful as inboxes cannot be recovered once deleted. Note: deleting inboxes will not impact your usage limits. Monthly inbox creation limits are based on how many inboxes were created in the last 30 days, not how many inboxes you currently have.
         * @summary Delete all inboxes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllInboxes(
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = InboxControllerApiFetchParamCreator(
                configuration
            ).deleteAllInboxes(options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Permanently delete an inbox and associated email address aswell as all emails within the given inbox. This action cannot be undone. Note: deleting an inbox will not affect your account usage. Monthly inbox usage is based on how many inboxes you create within 30 days, not how many exist at time of request.
         * @summary Delete inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInbox(
            inboxId: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = InboxControllerApiFetchParamCreator(
                configuration
            ).deleteInbox(inboxId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List inboxes in paginated form. Allows for page index, page size, and sort direction. Can also filter by favourited or email address like pattern.
         * @summary List Inboxes Paginated
         * @param {boolean} [favourite] Optionally filter results for favourites only
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {string} [search] Optionally filter by search words partial matching ID, tags, name, and email address
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {string} [tag] Optionally filter by tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllInboxes(
            favourite?: boolean,
            page?: number,
            search?: string,
            size?: number,
            sort?: 'ASC' | 'DESC',
            tag?: string,
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<PageInboxProjection> {
            const localVarFetchArgs = InboxControllerApiFetchParamCreator(
                configuration
            ).getAllInboxes(favourite, page, search, size, sort, tag, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List emails that an inbox has received. Only emails that are sent to the inbox's email address will appear in the inbox. It may take several seconds for any email you send to an inbox's email address to appear in the inbox. To make this endpoint wait for a minimum number of emails use the `minCount` parameter. The server will retry the inbox database until the `minCount` is satisfied or the `retryTimeout` is reached
         * @summary Get emails in an Inbox
         * @param {string} inboxId Id of inbox that emails belongs to
         * @param {number} [limit] Limit the result set, ordered by received date time sort direction
         * @param {number} [minCount] Minimum acceptable email count. Will cause request to hang (and retry) until minCount is satisfied or retryTimeout is reached.
         * @param {number} [retryTimeout] Maximum milliseconds to spend retrying inbox database until minCount emails are returned
         * @param {Date} [since] Exclude emails received before this ISO 8601 date time
         * @param {'ASC' | 'DESC'} [sort] Sort the results by received date and direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmails(
            inboxId: string,
            limit?: number,
            minCount?: number,
            retryTimeout?: number,
            since?: Date,
            sort?: 'ASC' | 'DESC',
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<Array<EmailPreview>> {
            const localVarFetchArgs = InboxControllerApiFetchParamCreator(
                configuration
            ).getEmails(
                inboxId,
                limit,
                minCount,
                retryTimeout,
                since,
                sort,
                options
            );
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns an inbox's properties, including its email address and ID.
         * @summary Get Inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInbox(
            inboxId: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Inbox> {
            const localVarFetchArgs = InboxControllerApiFetchParamCreator(
                configuration
            ).getInbox(inboxId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a paginated list of emails in an inbox. Does not hold connections open.
         * @summary Get inbox emails paginated
         * @param {string} inboxId Id of inbox that emails belongs to
         * @param {number} [page] Optional page index in inbox emails list pagination
         * @param {number} [size] Optional page size in inbox emails list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxEmailsPaginated(
            inboxId: string,
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<PageEmailPreview> {
            const localVarFetchArgs = InboxControllerApiFetchParamCreator(
                configuration
            ).getInboxEmailsPaginated(inboxId, page, size, sort, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns an inbox's sent email receipts. Call individual sent email endpoints for more details. Note for privacy reasons the full body of sent emails is never stored. An MD5 hash hex is available for comparison instead.
         * @summary Get Inbox Sent Emails
         * @param {string} inboxId inboxId
         * @param {number} [page] Optional page index in inbox sent email list pagination
         * @param {number} [size] Optional page size in inbox sent email list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxSentEmails(
            inboxId: string,
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<PageSentEmailProjection> {
            const localVarFetchArgs = InboxControllerApiFetchParamCreator(
                configuration
            ).getInboxSentEmails(inboxId, page, size, sort, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all inbox tags
         * @summary Get inbox tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxTags(
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = InboxControllerApiFetchParamCreator(
                configuration
            ).getInboxTags(options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List the inboxes you have created
         * @summary List Inboxes / Email Addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxes(
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Inbox>> {
            const localVarFetchArgs = InboxControllerApiFetchParamCreator(
                configuration
            ).getInboxes(options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Send an email from an inbox's email address.  The request body should contain the `SendEmailOptions` that include recipients, attachments, body etc. See `SendEmailOptions` for all available properties. Note the `inboxId` refers to the inbox's id not the inbox's email address. See https://www.mailslurp.com/guides/ for more information on how to send emails. This method does not return a sent email entity due to legacy reasons. To send and get a sent email as returned response use the sister method `sendEmailAndConfirm`.
         * @summary Send Email
         * @param {string} inboxId ID of the inbox you want to send the email from
         * @param {SendEmailOptions} [sendEmailOptions] Options for the email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmail(
            inboxId: string,
            sendEmailOptions?: SendEmailOptions,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = InboxControllerApiFetchParamCreator(
                configuration
            ).sendEmail(inboxId, sendEmailOptions, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Sister method for standard `sendEmail` method with the benefit of returning a `SentEmail` entity confirming the successful sending of the email with link the the sent object created for it.
         * @summary Send email and return sent confirmation
         * @param {string} inboxId ID of the inbox you want to send the email from
         * @param {SendEmailOptions} [sendEmailOptions] Options for the email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailAndConfirm(
            inboxId: string,
            sendEmailOptions?: SendEmailOptions,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<SentEmail> {
            const localVarFetchArgs = InboxControllerApiFetchParamCreator(
                configuration
            ).sendEmailAndConfirm(inboxId, sendEmailOptions, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Set and return new favourite state for an inbox
         * @summary Set inbox favourited state
         * @param {string} inboxId inboxId
         * @param {SetInboxFavouritedOptions} setInboxFavouritedOptions setInboxFavouritedOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setInboxFavourited(
            inboxId: string,
            setInboxFavouritedOptions: SetInboxFavouritedOptions,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Inbox> {
            const localVarFetchArgs = InboxControllerApiFetchParamCreator(
                configuration
            ).setInboxFavourited(inboxId, setInboxFavouritedOptions, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update editable fields on an inbox
         * @summary Update Inbox
         * @param {string} inboxId inboxId
         * @param {UpdateInboxOptions} updateInboxOptions updateInboxOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInbox(
            inboxId: string,
            updateInboxOptions: UpdateInboxOptions,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Inbox> {
            const localVarFetchArgs = InboxControllerApiFetchParamCreator(
                configuration
            ).updateInbox(inboxId, updateInboxOptions, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    };
};

/**
 * InboxControllerApi - factory interface
 * @export
 */
export const InboxControllerApiFactory = function(
    configuration?: Configuration,
    fetch?: FetchAPI,
    basePath?: string
) {
    return {
        /**
         * Create a new inbox and with a randomized email address to send and receive from. Pass emailAddress parameter if you wish to use a specific email address. Creating an inbox is required before sending or receiving emails. If writing tests it is recommended that you create a new inbox during each test method so that it is unique and empty.
         * @summary Create an Inbox (email address)
         * @param {string} [description] Optional description for an inbox.
         * @param {string} [emailAddress] Optional email address including domain you wish inbox to use (eg: test123@mydomain.com). Only supports domains that you have registered and verified with MailSlurp using dashboard or &#x60;createDomain&#x60; method.
         * @param {Date} [expiresAt] Optional expires at timestamp. If your plan supports this feature you can specify when an inbox should expire. If left empty inbox will exist permanently or expire when your plan dictates
         * @param {boolean} [favourite] Is inbox favourited.
         * @param {string} [name] Optional name for an inbox.
         * @param {Array<string>} [tags] Optional tags for an inbox. Can be used for searching and filtering inboxes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInbox(
            description?: string,
            emailAddress?: string,
            expiresAt?: Date,
            favourite?: boolean,
            name?: string,
            tags?: Array<string>,
            options?: any
        ) {
            return InboxControllerApiFp(configuration).createInbox(
                description,
                emailAddress,
                expiresAt,
                favourite,
                name,
                tags,
                options
            )(fetch, basePath);
        },
        /**
         * Permanently delete all inboxes and associated email addresses. This will also delete all emails within the inboxes. Be careful as inboxes cannot be recovered once deleted. Note: deleting inboxes will not impact your usage limits. Monthly inbox creation limits are based on how many inboxes were created in the last 30 days, not how many inboxes you currently have.
         * @summary Delete all inboxes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllInboxes(options?: any) {
            return InboxControllerApiFp(configuration).deleteAllInboxes(
                options
            )(fetch, basePath);
        },
        /**
         * Permanently delete an inbox and associated email address aswell as all emails within the given inbox. This action cannot be undone. Note: deleting an inbox will not affect your account usage. Monthly inbox usage is based on how many inboxes you create within 30 days, not how many exist at time of request.
         * @summary Delete inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInbox(inboxId: string, options?: any) {
            return InboxControllerApiFp(configuration).deleteInbox(
                inboxId,
                options
            )(fetch, basePath);
        },
        /**
         * List inboxes in paginated form. Allows for page index, page size, and sort direction. Can also filter by favourited or email address like pattern.
         * @summary List Inboxes Paginated
         * @param {boolean} [favourite] Optionally filter results for favourites only
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {string} [search] Optionally filter by search words partial matching ID, tags, name, and email address
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {string} [tag] Optionally filter by tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllInboxes(
            favourite?: boolean,
            page?: number,
            search?: string,
            size?: number,
            sort?: 'ASC' | 'DESC',
            tag?: string,
            options?: any
        ) {
            return InboxControllerApiFp(configuration).getAllInboxes(
                favourite,
                page,
                search,
                size,
                sort,
                tag,
                options
            )(fetch, basePath);
        },
        /**
         * List emails that an inbox has received. Only emails that are sent to the inbox's email address will appear in the inbox. It may take several seconds for any email you send to an inbox's email address to appear in the inbox. To make this endpoint wait for a minimum number of emails use the `minCount` parameter. The server will retry the inbox database until the `minCount` is satisfied or the `retryTimeout` is reached
         * @summary Get emails in an Inbox
         * @param {string} inboxId Id of inbox that emails belongs to
         * @param {number} [limit] Limit the result set, ordered by received date time sort direction
         * @param {number} [minCount] Minimum acceptable email count. Will cause request to hang (and retry) until minCount is satisfied or retryTimeout is reached.
         * @param {number} [retryTimeout] Maximum milliseconds to spend retrying inbox database until minCount emails are returned
         * @param {Date} [since] Exclude emails received before this ISO 8601 date time
         * @param {'ASC' | 'DESC'} [sort] Sort the results by received date and direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmails(
            inboxId: string,
            limit?: number,
            minCount?: number,
            retryTimeout?: number,
            since?: Date,
            sort?: 'ASC' | 'DESC',
            options?: any
        ) {
            return InboxControllerApiFp(configuration).getEmails(
                inboxId,
                limit,
                minCount,
                retryTimeout,
                since,
                sort,
                options
            )(fetch, basePath);
        },
        /**
         * Returns an inbox's properties, including its email address and ID.
         * @summary Get Inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInbox(inboxId: string, options?: any) {
            return InboxControllerApiFp(configuration).getInbox(
                inboxId,
                options
            )(fetch, basePath);
        },
        /**
         * Get a paginated list of emails in an inbox. Does not hold connections open.
         * @summary Get inbox emails paginated
         * @param {string} inboxId Id of inbox that emails belongs to
         * @param {number} [page] Optional page index in inbox emails list pagination
         * @param {number} [size] Optional page size in inbox emails list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxEmailsPaginated(
            inboxId: string,
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ) {
            return InboxControllerApiFp(configuration).getInboxEmailsPaginated(
                inboxId,
                page,
                size,
                sort,
                options
            )(fetch, basePath);
        },
        /**
         * Returns an inbox's sent email receipts. Call individual sent email endpoints for more details. Note for privacy reasons the full body of sent emails is never stored. An MD5 hash hex is available for comparison instead.
         * @summary Get Inbox Sent Emails
         * @param {string} inboxId inboxId
         * @param {number} [page] Optional page index in inbox sent email list pagination
         * @param {number} [size] Optional page size in inbox sent email list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxSentEmails(
            inboxId: string,
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ) {
            return InboxControllerApiFp(configuration).getInboxSentEmails(
                inboxId,
                page,
                size,
                sort,
                options
            )(fetch, basePath);
        },
        /**
         * Get all inbox tags
         * @summary Get inbox tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxTags(options?: any) {
            return InboxControllerApiFp(configuration).getInboxTags(options)(
                fetch,
                basePath
            );
        },
        /**
         * List the inboxes you have created
         * @summary List Inboxes / Email Addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxes(options?: any) {
            return InboxControllerApiFp(configuration).getInboxes(options)(
                fetch,
                basePath
            );
        },
        /**
         * Send an email from an inbox's email address.  The request body should contain the `SendEmailOptions` that include recipients, attachments, body etc. See `SendEmailOptions` for all available properties. Note the `inboxId` refers to the inbox's id not the inbox's email address. See https://www.mailslurp.com/guides/ for more information on how to send emails. This method does not return a sent email entity due to legacy reasons. To send and get a sent email as returned response use the sister method `sendEmailAndConfirm`.
         * @summary Send Email
         * @param {string} inboxId ID of the inbox you want to send the email from
         * @param {SendEmailOptions} [sendEmailOptions] Options for the email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmail(
            inboxId: string,
            sendEmailOptions?: SendEmailOptions,
            options?: any
        ) {
            return InboxControllerApiFp(configuration).sendEmail(
                inboxId,
                sendEmailOptions,
                options
            )(fetch, basePath);
        },
        /**
         * Sister method for standard `sendEmail` method with the benefit of returning a `SentEmail` entity confirming the successful sending of the email with link the the sent object created for it.
         * @summary Send email and return sent confirmation
         * @param {string} inboxId ID of the inbox you want to send the email from
         * @param {SendEmailOptions} [sendEmailOptions] Options for the email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailAndConfirm(
            inboxId: string,
            sendEmailOptions?: SendEmailOptions,
            options?: any
        ) {
            return InboxControllerApiFp(configuration).sendEmailAndConfirm(
                inboxId,
                sendEmailOptions,
                options
            )(fetch, basePath);
        },
        /**
         * Set and return new favourite state for an inbox
         * @summary Set inbox favourited state
         * @param {string} inboxId inboxId
         * @param {SetInboxFavouritedOptions} setInboxFavouritedOptions setInboxFavouritedOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setInboxFavourited(
            inboxId: string,
            setInboxFavouritedOptions: SetInboxFavouritedOptions,
            options?: any
        ) {
            return InboxControllerApiFp(configuration).setInboxFavourited(
                inboxId,
                setInboxFavouritedOptions,
                options
            )(fetch, basePath);
        },
        /**
         * Update editable fields on an inbox
         * @summary Update Inbox
         * @param {string} inboxId inboxId
         * @param {UpdateInboxOptions} updateInboxOptions updateInboxOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInbox(
            inboxId: string,
            updateInboxOptions: UpdateInboxOptions,
            options?: any
        ) {
            return InboxControllerApiFp(configuration).updateInbox(
                inboxId,
                updateInboxOptions,
                options
            )(fetch, basePath);
        },
    };
};

/**
 * InboxControllerApi - object-oriented interface
 * @export
 * @class InboxControllerApi
 * @extends {BaseAPI}
 */
export class InboxControllerApi extends BaseAPI {
    /**
     * Create a new inbox and with a randomized email address to send and receive from. Pass emailAddress parameter if you wish to use a specific email address. Creating an inbox is required before sending or receiving emails. If writing tests it is recommended that you create a new inbox during each test method so that it is unique and empty.
     * @summary Create an Inbox (email address)
     * @param {string} [description] Optional description for an inbox.
     * @param {string} [emailAddress] Optional email address including domain you wish inbox to use (eg: test123@mydomain.com). Only supports domains that you have registered and verified with MailSlurp using dashboard or &#x60;createDomain&#x60; method.
     * @param {Date} [expiresAt] Optional expires at timestamp. If your plan supports this feature you can specify when an inbox should expire. If left empty inbox will exist permanently or expire when your plan dictates
     * @param {boolean} [favourite] Is inbox favourited.
     * @param {string} [name] Optional name for an inbox.
     * @param {Array<string>} [tags] Optional tags for an inbox. Can be used for searching and filtering inboxes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    public createInbox(
        description?: string,
        emailAddress?: string,
        expiresAt?: Date,
        favourite?: boolean,
        name?: string,
        tags?: Array<string>,
        options?: any
    ) {
        return InboxControllerApiFp(this.configuration).createInbox(
            description,
            emailAddress,
            expiresAt,
            favourite,
            name,
            tags,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Permanently delete all inboxes and associated email addresses. This will also delete all emails within the inboxes. Be careful as inboxes cannot be recovered once deleted. Note: deleting inboxes will not impact your usage limits. Monthly inbox creation limits are based on how many inboxes were created in the last 30 days, not how many inboxes you currently have.
     * @summary Delete all inboxes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    public deleteAllInboxes(options?: any) {
        return InboxControllerApiFp(this.configuration).deleteAllInboxes(
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Permanently delete an inbox and associated email address aswell as all emails within the given inbox. This action cannot be undone. Note: deleting an inbox will not affect your account usage. Monthly inbox usage is based on how many inboxes you create within 30 days, not how many exist at time of request.
     * @summary Delete inbox
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    public deleteInbox(inboxId: string, options?: any) {
        return InboxControllerApiFp(this.configuration).deleteInbox(
            inboxId,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * List inboxes in paginated form. Allows for page index, page size, and sort direction. Can also filter by favourited or email address like pattern.
     * @summary List Inboxes Paginated
     * @param {boolean} [favourite] Optionally filter results for favourites only
     * @param {number} [page] Optional page index in inbox list pagination
     * @param {string} [search] Optionally filter by search words partial matching ID, tags, name, and email address
     * @param {number} [size] Optional page size in inbox list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {string} [tag] Optionally filter by tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    public getAllInboxes(
        favourite?: boolean,
        page?: number,
        search?: string,
        size?: number,
        sort?: 'ASC' | 'DESC',
        tag?: string,
        options?: any
    ) {
        return InboxControllerApiFp(this.configuration).getAllInboxes(
            favourite,
            page,
            search,
            size,
            sort,
            tag,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * List emails that an inbox has received. Only emails that are sent to the inbox's email address will appear in the inbox. It may take several seconds for any email you send to an inbox's email address to appear in the inbox. To make this endpoint wait for a minimum number of emails use the `minCount` parameter. The server will retry the inbox database until the `minCount` is satisfied or the `retryTimeout` is reached
     * @summary Get emails in an Inbox
     * @param {string} inboxId Id of inbox that emails belongs to
     * @param {number} [limit] Limit the result set, ordered by received date time sort direction
     * @param {number} [minCount] Minimum acceptable email count. Will cause request to hang (and retry) until minCount is satisfied or retryTimeout is reached.
     * @param {number} [retryTimeout] Maximum milliseconds to spend retrying inbox database until minCount emails are returned
     * @param {Date} [since] Exclude emails received before this ISO 8601 date time
     * @param {'ASC' | 'DESC'} [sort] Sort the results by received date and direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    public getEmails(
        inboxId: string,
        limit?: number,
        minCount?: number,
        retryTimeout?: number,
        since?: Date,
        sort?: 'ASC' | 'DESC',
        options?: any
    ) {
        return InboxControllerApiFp(this.configuration).getEmails(
            inboxId,
            limit,
            minCount,
            retryTimeout,
            since,
            sort,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Returns an inbox's properties, including its email address and ID.
     * @summary Get Inbox
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    public getInbox(inboxId: string, options?: any) {
        return InboxControllerApiFp(this.configuration).getInbox(
            inboxId,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Get a paginated list of emails in an inbox. Does not hold connections open.
     * @summary Get inbox emails paginated
     * @param {string} inboxId Id of inbox that emails belongs to
     * @param {number} [page] Optional page index in inbox emails list pagination
     * @param {number} [size] Optional page size in inbox emails list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    public getInboxEmailsPaginated(
        inboxId: string,
        page?: number,
        size?: number,
        sort?: 'ASC' | 'DESC',
        options?: any
    ) {
        return InboxControllerApiFp(this.configuration).getInboxEmailsPaginated(
            inboxId,
            page,
            size,
            sort,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Returns an inbox's sent email receipts. Call individual sent email endpoints for more details. Note for privacy reasons the full body of sent emails is never stored. An MD5 hash hex is available for comparison instead.
     * @summary Get Inbox Sent Emails
     * @param {string} inboxId inboxId
     * @param {number} [page] Optional page index in inbox sent email list pagination
     * @param {number} [size] Optional page size in inbox sent email list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    public getInboxSentEmails(
        inboxId: string,
        page?: number,
        size?: number,
        sort?: 'ASC' | 'DESC',
        options?: any
    ) {
        return InboxControllerApiFp(this.configuration).getInboxSentEmails(
            inboxId,
            page,
            size,
            sort,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Get all inbox tags
     * @summary Get inbox tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    public getInboxTags(options?: any) {
        return InboxControllerApiFp(this.configuration).getInboxTags(options)(
            this.fetch,
            this.basePath
        );
    }

    /**
     * List the inboxes you have created
     * @summary List Inboxes / Email Addresses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    public getInboxes(options?: any) {
        return InboxControllerApiFp(this.configuration).getInboxes(options)(
            this.fetch,
            this.basePath
        );
    }

    /**
     * Send an email from an inbox's email address.  The request body should contain the `SendEmailOptions` that include recipients, attachments, body etc. See `SendEmailOptions` for all available properties. Note the `inboxId` refers to the inbox's id not the inbox's email address. See https://www.mailslurp.com/guides/ for more information on how to send emails. This method does not return a sent email entity due to legacy reasons. To send and get a sent email as returned response use the sister method `sendEmailAndConfirm`.
     * @summary Send Email
     * @param {string} inboxId ID of the inbox you want to send the email from
     * @param {SendEmailOptions} [sendEmailOptions] Options for the email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    public sendEmail(
        inboxId: string,
        sendEmailOptions?: SendEmailOptions,
        options?: any
    ) {
        return InboxControllerApiFp(this.configuration).sendEmail(
            inboxId,
            sendEmailOptions,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Sister method for standard `sendEmail` method with the benefit of returning a `SentEmail` entity confirming the successful sending of the email with link the the sent object created for it.
     * @summary Send email and return sent confirmation
     * @param {string} inboxId ID of the inbox you want to send the email from
     * @param {SendEmailOptions} [sendEmailOptions] Options for the email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    public sendEmailAndConfirm(
        inboxId: string,
        sendEmailOptions?: SendEmailOptions,
        options?: any
    ) {
        return InboxControllerApiFp(this.configuration).sendEmailAndConfirm(
            inboxId,
            sendEmailOptions,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Set and return new favourite state for an inbox
     * @summary Set inbox favourited state
     * @param {string} inboxId inboxId
     * @param {SetInboxFavouritedOptions} setInboxFavouritedOptions setInboxFavouritedOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    public setInboxFavourited(
        inboxId: string,
        setInboxFavouritedOptions: SetInboxFavouritedOptions,
        options?: any
    ) {
        return InboxControllerApiFp(this.configuration).setInboxFavourited(
            inboxId,
            setInboxFavouritedOptions,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Update editable fields on an inbox
     * @summary Update Inbox
     * @param {string} inboxId inboxId
     * @param {UpdateInboxOptions} updateInboxOptions updateInboxOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    public updateInbox(
        inboxId: string,
        updateInboxOptions: UpdateInboxOptions,
        options?: any
    ) {
        return InboxControllerApiFp(this.configuration).updateInbox(
            inboxId,
            updateInboxOptions,
            options
        )(this.fetch, this.basePath);
    }
}

/**
 * MailServerControllerApi - fetch parameter creator
 * @export
 */
export const MailServerControllerApiFetchParamCreator = function(
    configuration?: Configuration
) {
    return {
        /**
         *
         * @summary Get DNS Mail Server records for a domain
         * @param {DescribeDomainOptions} describeOptions describeOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        describeMailServerDomain(
            describeOptions: DescribeDomainOptions,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'describeOptions' is not null or undefined
            if (describeOptions === null || describeOptions === undefined) {
                throw new RequiredError(
                    'describeOptions',
                    'Required parameter describeOptions was null or undefined when calling describeMailServerDomain.'
                );
            }
            const localVarPath = `/mail-server/describe/domain`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'DescribeDomainOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(describeOptions || {})
                : describeOptions || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Verify the existence of an email address at a given mail server.
         * @param {VerifyEmailAddressOptions} verifyOptions verifyOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmailAddress(
            verifyOptions: VerifyEmailAddressOptions,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'verifyOptions' is not null or undefined
            if (verifyOptions === null || verifyOptions === undefined) {
                throw new RequiredError(
                    'verifyOptions',
                    'Required parameter verifyOptions was null or undefined when calling verifyEmailAddress.'
                );
            }
            const localVarPath = `/mail-server/verify/email-address`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'VerifyEmailAddressOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(verifyOptions || {})
                : verifyOptions || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * MailServerControllerApi - functional programming interface
 * @export
 */
export const MailServerControllerApiFp = function(
    configuration?: Configuration
) {
    return {
        /**
         *
         * @summary Get DNS Mail Server records for a domain
         * @param {DescribeDomainOptions} describeOptions describeOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        describeMailServerDomain(
            describeOptions: DescribeDomainOptions,
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<DescribeMailServerDomainResult> {
            const localVarFetchArgs = MailServerControllerApiFetchParamCreator(
                configuration
            ).describeMailServerDomain(describeOptions, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Verify the existence of an email address at a given mail server.
         * @param {VerifyEmailAddressOptions} verifyOptions verifyOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmailAddress(
            verifyOptions: VerifyEmailAddressOptions,
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<EmailVerificationResult> {
            const localVarFetchArgs = MailServerControllerApiFetchParamCreator(
                configuration
            ).verifyEmailAddress(verifyOptions, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    };
};

/**
 * MailServerControllerApi - factory interface
 * @export
 */
export const MailServerControllerApiFactory = function(
    configuration?: Configuration,
    fetch?: FetchAPI,
    basePath?: string
) {
    return {
        /**
         *
         * @summary Get DNS Mail Server records for a domain
         * @param {DescribeDomainOptions} describeOptions describeOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        describeMailServerDomain(
            describeOptions: DescribeDomainOptions,
            options?: any
        ) {
            return MailServerControllerApiFp(
                configuration
            ).describeMailServerDomain(describeOptions, options)(
                fetch,
                basePath
            );
        },
        /**
         *
         * @summary Verify the existence of an email address at a given mail server.
         * @param {VerifyEmailAddressOptions} verifyOptions verifyOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmailAddress(
            verifyOptions: VerifyEmailAddressOptions,
            options?: any
        ) {
            return MailServerControllerApiFp(configuration).verifyEmailAddress(
                verifyOptions,
                options
            )(fetch, basePath);
        },
    };
};

/**
 * MailServerControllerApi - object-oriented interface
 * @export
 * @class MailServerControllerApi
 * @extends {BaseAPI}
 */
export class MailServerControllerApi extends BaseAPI {
    /**
     *
     * @summary Get DNS Mail Server records for a domain
     * @param {DescribeDomainOptions} describeOptions describeOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailServerControllerApi
     */
    public describeMailServerDomain(
        describeOptions: DescribeDomainOptions,
        options?: any
    ) {
        return MailServerControllerApiFp(
            this.configuration
        ).describeMailServerDomain(describeOptions, options)(
            this.fetch,
            this.basePath
        );
    }

    /**
     *
     * @summary Verify the existence of an email address at a given mail server.
     * @param {VerifyEmailAddressOptions} verifyOptions verifyOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailServerControllerApi
     */
    public verifyEmailAddress(
        verifyOptions: VerifyEmailAddressOptions,
        options?: any
    ) {
        return MailServerControllerApiFp(this.configuration).verifyEmailAddress(
            verifyOptions,
            options
        )(this.fetch, this.basePath);
    }
}

/**
 * SentEmailsControllerApi - fetch parameter creator
 * @export
 */
export const SentEmailsControllerApiFetchParamCreator = function(
    configuration?: Configuration
) {
    return {
        /**
         *
         * @summary Get sent email receipt
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSentEmail(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError(
                    'id',
                    'Required parameter id was null or undefined when calling getSentEmail.'
                );
            }
            const localVarPath = `/sent/{id}`.replace(
                `{${'id'}}`,
                encodeURIComponent(String(id))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all sent emails in paginated form
         * @param {string} [inboxId] Optional inboxId to filter sender of sent emails by
         * @param {number} [page] Optional page index in inbox sent email list pagination
         * @param {number} [size] Optional page size in inbox sent email list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSentEmails(
            inboxId?: string,
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options: any = {}
        ): FetchArgs {
            const localVarPath = `/sent`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (inboxId !== undefined) {
                localVarQueryParameter['inboxId'] = inboxId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * SentEmailsControllerApi - functional programming interface
 * @export
 */
export const SentEmailsControllerApiFp = function(
    configuration?: Configuration
) {
    return {
        /**
         *
         * @summary Get sent email receipt
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSentEmail(
            id: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<SentEmailDto> {
            const localVarFetchArgs = SentEmailsControllerApiFetchParamCreator(
                configuration
            ).getSentEmail(id, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all sent emails in paginated form
         * @param {string} [inboxId] Optional inboxId to filter sender of sent emails by
         * @param {number} [page] Optional page index in inbox sent email list pagination
         * @param {number} [size] Optional page size in inbox sent email list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSentEmails(
            inboxId?: string,
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<PageSentEmailProjection> {
            const localVarFetchArgs = SentEmailsControllerApiFetchParamCreator(
                configuration
            ).getSentEmails(inboxId, page, size, sort, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    };
};

/**
 * SentEmailsControllerApi - factory interface
 * @export
 */
export const SentEmailsControllerApiFactory = function(
    configuration?: Configuration,
    fetch?: FetchAPI,
    basePath?: string
) {
    return {
        /**
         *
         * @summary Get sent email receipt
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSentEmail(id: string, options?: any) {
            return SentEmailsControllerApiFp(configuration).getSentEmail(
                id,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Get all sent emails in paginated form
         * @param {string} [inboxId] Optional inboxId to filter sender of sent emails by
         * @param {number} [page] Optional page index in inbox sent email list pagination
         * @param {number} [size] Optional page size in inbox sent email list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSentEmails(
            inboxId?: string,
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ) {
            return SentEmailsControllerApiFp(configuration).getSentEmails(
                inboxId,
                page,
                size,
                sort,
                options
            )(fetch, basePath);
        },
    };
};

/**
 * SentEmailsControllerApi - object-oriented interface
 * @export
 * @class SentEmailsControllerApi
 * @extends {BaseAPI}
 */
export class SentEmailsControllerApi extends BaseAPI {
    /**
     *
     * @summary Get sent email receipt
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SentEmailsControllerApi
     */
    public getSentEmail(id: string, options?: any) {
        return SentEmailsControllerApiFp(this.configuration).getSentEmail(
            id,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get all sent emails in paginated form
     * @param {string} [inboxId] Optional inboxId to filter sender of sent emails by
     * @param {number} [page] Optional page index in inbox sent email list pagination
     * @param {number} [size] Optional page size in inbox sent email list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SentEmailsControllerApi
     */
    public getSentEmails(
        inboxId?: string,
        page?: number,
        size?: number,
        sort?: 'ASC' | 'DESC',
        options?: any
    ) {
        return SentEmailsControllerApiFp(this.configuration).getSentEmails(
            inboxId,
            page,
            size,
            sort,
            options
        )(this.fetch, this.basePath);
    }
}

/**
 * TemplateControllerApi - fetch parameter creator
 * @export
 */
export const TemplateControllerApiFetchParamCreator = function(
    configuration?: Configuration
) {
    return {
        /**
         *
         * @summary Create a Template
         * @param {CreateTemplateOptions} createTemplateOptions createTemplateOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTemplate(
            createTemplateOptions: CreateTemplateOptions,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'createTemplateOptions' is not null or undefined
            if (
                createTemplateOptions === null ||
                createTemplateOptions === undefined
            ) {
                throw new RequiredError(
                    'createTemplateOptions',
                    'Required parameter createTemplateOptions was null or undefined when calling createTemplate.'
                );
            }
            const localVarPath = `/templates`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'CreateTemplateOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(createTemplateOptions || {})
                : createTemplateOptions || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete Template
         * @param {string} templateId TemplateId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTemplate(templateId: string, options: any = {}): FetchArgs {
            // verify required parameter 'templateId' is not null or undefined
            if (templateId === null || templateId === undefined) {
                throw new RequiredError(
                    'templateId',
                    'Required parameter templateId was null or undefined when calling deleteTemplate.'
                );
            }
            const localVarPath = `/templates/{TemplateId}`.replace(
                `{${'TemplateId'}}`,
                encodeURIComponent(String(templateId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'DELETE' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Templates in paginated format
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTemplates(
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options: any = {}
        ): FetchArgs {
            const localVarPath = `/templates/paginated`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Template
         * @param {string} templateId TemplateId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplate(templateId: string, options: any = {}): FetchArgs {
            // verify required parameter 'templateId' is not null or undefined
            if (templateId === null || templateId === undefined) {
                throw new RequiredError(
                    'templateId',
                    'Required parameter templateId was null or undefined when calling getTemplate.'
                );
            }
            const localVarPath = `/templates/{TemplateId}`.replace(
                `{${'TemplateId'}}`,
                encodeURIComponent(String(templateId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplates(options: any = {}): FetchArgs {
            const localVarPath = `/templates`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * TemplateControllerApi - functional programming interface
 * @export
 */
export const TemplateControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a Template
         * @param {CreateTemplateOptions} createTemplateOptions createTemplateOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTemplate(
            createTemplateOptions: CreateTemplateOptions,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<TemplateDto> {
            const localVarFetchArgs = TemplateControllerApiFetchParamCreator(
                configuration
            ).createTemplate(createTemplateOptions, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete Template
         * @param {string} templateId TemplateId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTemplate(
            templateId: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TemplateControllerApiFetchParamCreator(
                configuration
            ).deleteTemplate(templateId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all Templates in paginated format
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTemplates(
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<PageTemplateProjection> {
            const localVarFetchArgs = TemplateControllerApiFetchParamCreator(
                configuration
            ).getAllTemplates(page, size, sort, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get Template
         * @param {string} templateId TemplateId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplate(
            templateId: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<TemplateDto> {
            const localVarFetchArgs = TemplateControllerApiFetchParamCreator(
                configuration
            ).getTemplate(templateId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplates(
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<Array<TemplateProjection>> {
            const localVarFetchArgs = TemplateControllerApiFetchParamCreator(
                configuration
            ).getTemplates(options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    };
};

/**
 * TemplateControllerApi - factory interface
 * @export
 */
export const TemplateControllerApiFactory = function(
    configuration?: Configuration,
    fetch?: FetchAPI,
    basePath?: string
) {
    return {
        /**
         *
         * @summary Create a Template
         * @param {CreateTemplateOptions} createTemplateOptions createTemplateOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTemplate(
            createTemplateOptions: CreateTemplateOptions,
            options?: any
        ) {
            return TemplateControllerApiFp(configuration).createTemplate(
                createTemplateOptions,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Delete Template
         * @param {string} templateId TemplateId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTemplate(templateId: string, options?: any) {
            return TemplateControllerApiFp(configuration).deleteTemplate(
                templateId,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Get all Templates in paginated format
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTemplates(
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ) {
            return TemplateControllerApiFp(configuration).getAllTemplates(
                page,
                size,
                sort,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Get Template
         * @param {string} templateId TemplateId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplate(templateId: string, options?: any) {
            return TemplateControllerApiFp(configuration).getTemplate(
                templateId,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Get all Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplates(options?: any) {
            return TemplateControllerApiFp(configuration).getTemplates(options)(
                fetch,
                basePath
            );
        },
    };
};

/**
 * TemplateControllerApi - object-oriented interface
 * @export
 * @class TemplateControllerApi
 * @extends {BaseAPI}
 */
export class TemplateControllerApi extends BaseAPI {
    /**
     *
     * @summary Create a Template
     * @param {CreateTemplateOptions} createTemplateOptions createTemplateOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateControllerApi
     */
    public createTemplate(
        createTemplateOptions: CreateTemplateOptions,
        options?: any
    ) {
        return TemplateControllerApiFp(this.configuration).createTemplate(
            createTemplateOptions,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Delete Template
     * @param {string} templateId TemplateId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateControllerApi
     */
    public deleteTemplate(templateId: string, options?: any) {
        return TemplateControllerApiFp(this.configuration).deleteTemplate(
            templateId,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get all Templates in paginated format
     * @param {number} [page] Optional page index in inbox list pagination
     * @param {number} [size] Optional page size in inbox list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateControllerApi
     */
    public getAllTemplates(
        page?: number,
        size?: number,
        sort?: 'ASC' | 'DESC',
        options?: any
    ) {
        return TemplateControllerApiFp(this.configuration).getAllTemplates(
            page,
            size,
            sort,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get Template
     * @param {string} templateId TemplateId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateControllerApi
     */
    public getTemplate(templateId: string, options?: any) {
        return TemplateControllerApiFp(this.configuration).getTemplate(
            templateId,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get all Templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateControllerApi
     */
    public getTemplates(options?: any) {
        return TemplateControllerApiFp(this.configuration).getTemplates(
            options
        )(this.fetch, this.basePath);
    }
}

/**
 * WaitForControllerApi - fetch parameter creator
 * @export
 */
export const WaitForControllerApiFetchParamCreator = function(
    configuration?: Configuration
) {
    return {
        /**
         * Generic waitFor method that will wait until an inbox meets given conditions or return immediately if already met
         * @summary Wait for conditions to be met
         * @param {WaitForConditions} [waitForConditions] Conditions to wait for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitFor(
            waitForConditions?: WaitForConditions,
            options: any = {}
        ): FetchArgs {
            const localVarPath = `/waitFor`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'WaitForConditions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(waitForConditions || {})
                : waitForConditions || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If inbox contains count or more emails at time of request then return count worth of emails. If not wait until the count is reached and return those or return an error if timeout is exceeded.
         * @summary Wait for and return count number of emails
         * @param {number} [count] Number of emails to wait for. Must be greater that 1
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {boolean} [unreadOnly] Optional filter for unread only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForEmailCount(
            count?: number,
            inboxId?: string,
            timeout?: number,
            unreadOnly?: boolean,
            options: any = {}
        ): FetchArgs {
            const localVarPath = `/waitForEmailCount`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (inboxId !== undefined) {
                localVarQueryParameter['inboxId'] = inboxId;
            }

            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }

            if (unreadOnly !== undefined) {
                localVarQueryParameter['unreadOnly'] = unreadOnly;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox set `unreadOnly=true` or see the other receive methods such as `waitForNthEmail` or `waitForEmailCount`.
         * @summary Fetch inbox's latest email or if empty wait for an email to arrive
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {boolean} [unreadOnly] Optional filter for unread only.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForLatestEmail(
            inboxId?: string,
            timeout?: number,
            unreadOnly?: boolean,
            options: any = {}
        ): FetchArgs {
            const localVarPath = `/waitForLatestEmail`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (inboxId !== undefined) {
                localVarQueryParameter['inboxId'] = inboxId;
            }

            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }

            if (unreadOnly !== undefined) {
                localVarQueryParameter['unreadOnly'] = unreadOnly;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Perform a search of emails in an inbox with the given patterns. If results match expected count then return or else retry the search until results are found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the `MatchOptions` object for options.
         * @summary Wait or return list of emails that match simple matching patterns
         * @param {MatchOptions} matchOptions matchOptions
         * @param {number} [count] Number of emails to wait for. Must be greater that 1
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {boolean} [unreadOnly] Optional filter for unread only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForMatchingEmail(
            matchOptions: MatchOptions,
            count?: number,
            inboxId?: string,
            timeout?: number,
            unreadOnly?: boolean,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'matchOptions' is not null or undefined
            if (matchOptions === null || matchOptions === undefined) {
                throw new RequiredError(
                    'matchOptions',
                    'Required parameter matchOptions was null or undefined when calling waitForMatchingEmail.'
                );
            }
            const localVarPath = `/waitForMatchingEmails`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (inboxId !== undefined) {
                localVarQueryParameter['inboxId'] = inboxId;
            }

            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }

            if (unreadOnly !== undefined) {
                localVarQueryParameter['unreadOnly'] = unreadOnly;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'MatchOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(matchOptions || {})
                : matchOptions || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If nth email is already present in inbox then return it. If not hold the connection open until timeout expires or the nth email is received and returned.
         * @summary Wait for or fetch the email with a given index in the inbox specified
         * @param {string} [inboxId] Id of the inbox you are fetching emails from
         * @param {number} [index] Zero based index of the email to wait for. If an inbox has 1 email already and you want to wait for the 2nd email pass index&#x3D;1
         * @param {number} [timeout] Max milliseconds to wait for the nth email if not already present
         * @param {boolean} [unreadOnly] Optional filter for unread only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForNthEmail(
            inboxId?: string,
            index?: number,
            timeout?: number,
            unreadOnly?: boolean,
            options: any = {}
        ): FetchArgs {
            const localVarPath = `/waitForNthEmail`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (inboxId !== undefined) {
                localVarQueryParameter['inboxId'] = inboxId;
            }

            if (index !== undefined) {
                localVarQueryParameter['index'] = index;
            }

            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }

            if (unreadOnly !== undefined) {
                localVarQueryParameter['unreadOnly'] = unreadOnly;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * WaitForControllerApi - functional programming interface
 * @export
 */
export const WaitForControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Generic waitFor method that will wait until an inbox meets given conditions or return immediately if already met
         * @summary Wait for conditions to be met
         * @param {WaitForConditions} [waitForConditions] Conditions to wait for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitFor(
            waitForConditions?: WaitForConditions,
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<Array<EmailPreview>> {
            const localVarFetchArgs = WaitForControllerApiFetchParamCreator(
                configuration
            ).waitFor(waitForConditions, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * If inbox contains count or more emails at time of request then return count worth of emails. If not wait until the count is reached and return those or return an error if timeout is exceeded.
         * @summary Wait for and return count number of emails
         * @param {number} [count] Number of emails to wait for. Must be greater that 1
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {boolean} [unreadOnly] Optional filter for unread only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForEmailCount(
            count?: number,
            inboxId?: string,
            timeout?: number,
            unreadOnly?: boolean,
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<Array<EmailPreview>> {
            const localVarFetchArgs = WaitForControllerApiFetchParamCreator(
                configuration
            ).waitForEmailCount(count, inboxId, timeout, unreadOnly, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox set `unreadOnly=true` or see the other receive methods such as `waitForNthEmail` or `waitForEmailCount`.
         * @summary Fetch inbox's latest email or if empty wait for an email to arrive
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {boolean} [unreadOnly] Optional filter for unread only.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForLatestEmail(
            inboxId?: string,
            timeout?: number,
            unreadOnly?: boolean,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Email> {
            const localVarFetchArgs = WaitForControllerApiFetchParamCreator(
                configuration
            ).waitForLatestEmail(inboxId, timeout, unreadOnly, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Perform a search of emails in an inbox with the given patterns. If results match expected count then return or else retry the search until results are found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the `MatchOptions` object for options.
         * @summary Wait or return list of emails that match simple matching patterns
         * @param {MatchOptions} matchOptions matchOptions
         * @param {number} [count] Number of emails to wait for. Must be greater that 1
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {boolean} [unreadOnly] Optional filter for unread only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForMatchingEmail(
            matchOptions: MatchOptions,
            count?: number,
            inboxId?: string,
            timeout?: number,
            unreadOnly?: boolean,
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<Array<EmailPreview>> {
            const localVarFetchArgs = WaitForControllerApiFetchParamCreator(
                configuration
            ).waitForMatchingEmail(
                matchOptions,
                count,
                inboxId,
                timeout,
                unreadOnly,
                options
            );
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * If nth email is already present in inbox then return it. If not hold the connection open until timeout expires or the nth email is received and returned.
         * @summary Wait for or fetch the email with a given index in the inbox specified
         * @param {string} [inboxId] Id of the inbox you are fetching emails from
         * @param {number} [index] Zero based index of the email to wait for. If an inbox has 1 email already and you want to wait for the 2nd email pass index&#x3D;1
         * @param {number} [timeout] Max milliseconds to wait for the nth email if not already present
         * @param {boolean} [unreadOnly] Optional filter for unread only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForNthEmail(
            inboxId?: string,
            index?: number,
            timeout?: number,
            unreadOnly?: boolean,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Email> {
            const localVarFetchArgs = WaitForControllerApiFetchParamCreator(
                configuration
            ).waitForNthEmail(inboxId, index, timeout, unreadOnly, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    };
};

/**
 * WaitForControllerApi - factory interface
 * @export
 */
export const WaitForControllerApiFactory = function(
    configuration?: Configuration,
    fetch?: FetchAPI,
    basePath?: string
) {
    return {
        /**
         * Generic waitFor method that will wait until an inbox meets given conditions or return immediately if already met
         * @summary Wait for conditions to be met
         * @param {WaitForConditions} [waitForConditions] Conditions to wait for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitFor(waitForConditions?: WaitForConditions, options?: any) {
            return WaitForControllerApiFp(configuration).waitFor(
                waitForConditions,
                options
            )(fetch, basePath);
        },
        /**
         * If inbox contains count or more emails at time of request then return count worth of emails. If not wait until the count is reached and return those or return an error if timeout is exceeded.
         * @summary Wait for and return count number of emails
         * @param {number} [count] Number of emails to wait for. Must be greater that 1
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {boolean} [unreadOnly] Optional filter for unread only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForEmailCount(
            count?: number,
            inboxId?: string,
            timeout?: number,
            unreadOnly?: boolean,
            options?: any
        ) {
            return WaitForControllerApiFp(configuration).waitForEmailCount(
                count,
                inboxId,
                timeout,
                unreadOnly,
                options
            )(fetch, basePath);
        },
        /**
         * Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox set `unreadOnly=true` or see the other receive methods such as `waitForNthEmail` or `waitForEmailCount`.
         * @summary Fetch inbox's latest email or if empty wait for an email to arrive
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {boolean} [unreadOnly] Optional filter for unread only.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForLatestEmail(
            inboxId?: string,
            timeout?: number,
            unreadOnly?: boolean,
            options?: any
        ) {
            return WaitForControllerApiFp(configuration).waitForLatestEmail(
                inboxId,
                timeout,
                unreadOnly,
                options
            )(fetch, basePath);
        },
        /**
         * Perform a search of emails in an inbox with the given patterns. If results match expected count then return or else retry the search until results are found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the `MatchOptions` object for options.
         * @summary Wait or return list of emails that match simple matching patterns
         * @param {MatchOptions} matchOptions matchOptions
         * @param {number} [count] Number of emails to wait for. Must be greater that 1
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {boolean} [unreadOnly] Optional filter for unread only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForMatchingEmail(
            matchOptions: MatchOptions,
            count?: number,
            inboxId?: string,
            timeout?: number,
            unreadOnly?: boolean,
            options?: any
        ) {
            return WaitForControllerApiFp(configuration).waitForMatchingEmail(
                matchOptions,
                count,
                inboxId,
                timeout,
                unreadOnly,
                options
            )(fetch, basePath);
        },
        /**
         * If nth email is already present in inbox then return it. If not hold the connection open until timeout expires or the nth email is received and returned.
         * @summary Wait for or fetch the email with a given index in the inbox specified
         * @param {string} [inboxId] Id of the inbox you are fetching emails from
         * @param {number} [index] Zero based index of the email to wait for. If an inbox has 1 email already and you want to wait for the 2nd email pass index&#x3D;1
         * @param {number} [timeout] Max milliseconds to wait for the nth email if not already present
         * @param {boolean} [unreadOnly] Optional filter for unread only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForNthEmail(
            inboxId?: string,
            index?: number,
            timeout?: number,
            unreadOnly?: boolean,
            options?: any
        ) {
            return WaitForControllerApiFp(configuration).waitForNthEmail(
                inboxId,
                index,
                timeout,
                unreadOnly,
                options
            )(fetch, basePath);
        },
    };
};

/**
 * WaitForControllerApi - object-oriented interface
 * @export
 * @class WaitForControllerApi
 * @extends {BaseAPI}
 */
export class WaitForControllerApi extends BaseAPI {
    /**
     * Generic waitFor method that will wait until an inbox meets given conditions or return immediately if already met
     * @summary Wait for conditions to be met
     * @param {WaitForConditions} [waitForConditions] Conditions to wait for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitForControllerApi
     */
    public waitFor(waitForConditions?: WaitForConditions, options?: any) {
        return WaitForControllerApiFp(this.configuration).waitFor(
            waitForConditions,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * If inbox contains count or more emails at time of request then return count worth of emails. If not wait until the count is reached and return those or return an error if timeout is exceeded.
     * @summary Wait for and return count number of emails
     * @param {number} [count] Number of emails to wait for. Must be greater that 1
     * @param {string} [inboxId] Id of the inbox we are fetching emails from
     * @param {number} [timeout] Max milliseconds to wait
     * @param {boolean} [unreadOnly] Optional filter for unread only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitForControllerApi
     */
    public waitForEmailCount(
        count?: number,
        inboxId?: string,
        timeout?: number,
        unreadOnly?: boolean,
        options?: any
    ) {
        return WaitForControllerApiFp(this.configuration).waitForEmailCount(
            count,
            inboxId,
            timeout,
            unreadOnly,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox set `unreadOnly=true` or see the other receive methods such as `waitForNthEmail` or `waitForEmailCount`.
     * @summary Fetch inbox's latest email or if empty wait for an email to arrive
     * @param {string} [inboxId] Id of the inbox we are fetching emails from
     * @param {number} [timeout] Max milliseconds to wait
     * @param {boolean} [unreadOnly] Optional filter for unread only.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitForControllerApi
     */
    public waitForLatestEmail(
        inboxId?: string,
        timeout?: number,
        unreadOnly?: boolean,
        options?: any
    ) {
        return WaitForControllerApiFp(this.configuration).waitForLatestEmail(
            inboxId,
            timeout,
            unreadOnly,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Perform a search of emails in an inbox with the given patterns. If results match expected count then return or else retry the search until results are found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the `MatchOptions` object for options.
     * @summary Wait or return list of emails that match simple matching patterns
     * @param {MatchOptions} matchOptions matchOptions
     * @param {number} [count] Number of emails to wait for. Must be greater that 1
     * @param {string} [inboxId] Id of the inbox we are fetching emails from
     * @param {number} [timeout] Max milliseconds to wait
     * @param {boolean} [unreadOnly] Optional filter for unread only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitForControllerApi
     */
    public waitForMatchingEmail(
        matchOptions: MatchOptions,
        count?: number,
        inboxId?: string,
        timeout?: number,
        unreadOnly?: boolean,
        options?: any
    ) {
        return WaitForControllerApiFp(this.configuration).waitForMatchingEmail(
            matchOptions,
            count,
            inboxId,
            timeout,
            unreadOnly,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * If nth email is already present in inbox then return it. If not hold the connection open until timeout expires or the nth email is received and returned.
     * @summary Wait for or fetch the email with a given index in the inbox specified
     * @param {string} [inboxId] Id of the inbox you are fetching emails from
     * @param {number} [index] Zero based index of the email to wait for. If an inbox has 1 email already and you want to wait for the 2nd email pass index&#x3D;1
     * @param {number} [timeout] Max milliseconds to wait for the nth email if not already present
     * @param {boolean} [unreadOnly] Optional filter for unread only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitForControllerApi
     */
    public waitForNthEmail(
        inboxId?: string,
        index?: number,
        timeout?: number,
        unreadOnly?: boolean,
        options?: any
    ) {
        return WaitForControllerApiFp(this.configuration).waitForNthEmail(
            inboxId,
            index,
            timeout,
            unreadOnly,
            options
        )(this.fetch, this.basePath);
    }
}

/**
 * WebhookControllerApi - fetch parameter creator
 * @export
 */
export const WebhookControllerApiFetchParamCreator = function(
    configuration?: Configuration
) {
    return {
        /**
         * Get notified whenever an inbox receives an email via a WebHook URL. An emailID will be posted to this URL every time an email is received for this inbox. The URL must be publicly reachable by the MailSlurp server. You can provide basicAuth values if you wish to secure this endpoint.
         * @summary Attach a WebHook URL to an inbox
         * @param {string} inboxId inboxId
         * @param {CreateWebhookOptions} webhookOptions webhookOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook(
            inboxId: string,
            webhookOptions: CreateWebhookOptions,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError(
                    'inboxId',
                    'Required parameter inboxId was null or undefined when calling createWebhook.'
                );
            }
            // verify required parameter 'webhookOptions' is not null or undefined
            if (webhookOptions === null || webhookOptions === undefined) {
                throw new RequiredError(
                    'webhookOptions',
                    'Required parameter webhookOptions was null or undefined when calling createWebhook.'
                );
            }
            const localVarPath = `/inboxes/{inboxId}/webhooks`.replace(
                `{${'inboxId'}}`,
                encodeURIComponent(String(inboxId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'CreateWebhookOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(webhookOptions || {})
                : webhookOptions || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete and disable a Webhook for an Inbox
         * @param {string} inboxId inboxId
         * @param {string} webhookId webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(
            inboxId: string,
            webhookId: string,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError(
                    'inboxId',
                    'Required parameter inboxId was null or undefined when calling deleteWebhook.'
                );
            }
            // verify required parameter 'webhookId' is not null or undefined
            if (webhookId === null || webhookId === undefined) {
                throw new RequiredError(
                    'webhookId',
                    'Required parameter webhookId was null or undefined when calling deleteWebhook.'
                );
            }
            const localVarPath = `/inboxes/{inboxId}/webhooks/{webhookId}`
                .replace(`{${'inboxId'}}`, encodeURIComponent(String(inboxId)))
                .replace(
                    `{${'webhookId'}}`,
                    encodeURIComponent(String(webhookId))
                );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'DELETE' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List webhooks in paginated form. Allows for page index, page size, and sort direction.
         * @summary List Webhooks Paginated
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWebhooks(
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options: any = {}
        ): FetchArgs {
            const localVarPath = `/webhooks/paginated`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a webhook for an Inbox
         * @param {string} webhookId webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook(webhookId: string, options: any = {}): FetchArgs {
            // verify required parameter 'webhookId' is not null or undefined
            if (webhookId === null || webhookId === undefined) {
                throw new RequiredError(
                    'webhookId',
                    'Required parameter webhookId was null or undefined when calling getWebhook.'
                );
            }
            const localVarPath = `/webhooks/{webhookId}`.replace(
                `{${'webhookId'}}`,
                encodeURIComponent(String(webhookId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Webhooks for an Inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(inboxId: string, options: any = {}): FetchArgs {
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError(
                    'inboxId',
                    'Required parameter inboxId was null or undefined when calling getWebhooks.'
                );
            }
            const localVarPath = `/inboxes/{inboxId}/webhooks`.replace(
                `{${'inboxId'}}`,
                encodeURIComponent(String(inboxId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Send webhook test data
         * @param {string} webhookId webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTestData(webhookId: string, options: any = {}): FetchArgs {
            // verify required parameter 'webhookId' is not null or undefined
            if (webhookId === null || webhookId === undefined) {
                throw new RequiredError(
                    'webhookId',
                    'Required parameter webhookId was null or undefined when calling sendTestData.'
                );
            }
            const localVarPath = `/webhooks/{webhookId}/test`.replace(
                `{${'webhookId'}}`,
                encodeURIComponent(String(webhookId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * WebhookControllerApi - functional programming interface
 * @export
 */
export const WebhookControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get notified whenever an inbox receives an email via a WebHook URL. An emailID will be posted to this URL every time an email is received for this inbox. The URL must be publicly reachable by the MailSlurp server. You can provide basicAuth values if you wish to secure this endpoint.
         * @summary Attach a WebHook URL to an inbox
         * @param {string} inboxId inboxId
         * @param {CreateWebhookOptions} webhookOptions webhookOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook(
            inboxId: string,
            webhookOptions: CreateWebhookOptions,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<WebhookDto> {
            const localVarFetchArgs = WebhookControllerApiFetchParamCreator(
                configuration
            ).createWebhook(inboxId, webhookOptions, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete and disable a Webhook for an Inbox
         * @param {string} inboxId inboxId
         * @param {string} webhookId webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(
            inboxId: string,
            webhookId: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = WebhookControllerApiFetchParamCreator(
                configuration
            ).deleteWebhook(inboxId, webhookId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List webhooks in paginated form. Allows for page index, page size, and sort direction.
         * @summary List Webhooks Paginated
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWebhooks(
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<PageWebhookProjection> {
            const localVarFetchArgs = WebhookControllerApiFetchParamCreator(
                configuration
            ).getAllWebhooks(page, size, sort, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get a webhook for an Inbox
         * @param {string} webhookId webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook(
            webhookId: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<WebhookDto> {
            const localVarFetchArgs = WebhookControllerApiFetchParamCreator(
                configuration
            ).getWebhook(webhookId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all Webhooks for an Inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(
            inboxId: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<WebhookDto>> {
            const localVarFetchArgs = WebhookControllerApiFetchParamCreator(
                configuration
            ).getWebhooks(inboxId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Send webhook test data
         * @param {string} webhookId webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTestData(
            webhookId: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<WebhookTestResult> {
            const localVarFetchArgs = WebhookControllerApiFetchParamCreator(
                configuration
            ).sendTestData(webhookId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    };
};

/**
 * WebhookControllerApi - factory interface
 * @export
 */
export const WebhookControllerApiFactory = function(
    configuration?: Configuration,
    fetch?: FetchAPI,
    basePath?: string
) {
    return {
        /**
         * Get notified whenever an inbox receives an email via a WebHook URL. An emailID will be posted to this URL every time an email is received for this inbox. The URL must be publicly reachable by the MailSlurp server. You can provide basicAuth values if you wish to secure this endpoint.
         * @summary Attach a WebHook URL to an inbox
         * @param {string} inboxId inboxId
         * @param {CreateWebhookOptions} webhookOptions webhookOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook(
            inboxId: string,
            webhookOptions: CreateWebhookOptions,
            options?: any
        ) {
            return WebhookControllerApiFp(configuration).createWebhook(
                inboxId,
                webhookOptions,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Delete and disable a Webhook for an Inbox
         * @param {string} inboxId inboxId
         * @param {string} webhookId webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(inboxId: string, webhookId: string, options?: any) {
            return WebhookControllerApiFp(configuration).deleteWebhook(
                inboxId,
                webhookId,
                options
            )(fetch, basePath);
        },
        /**
         * List webhooks in paginated form. Allows for page index, page size, and sort direction.
         * @summary List Webhooks Paginated
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWebhooks(
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ) {
            return WebhookControllerApiFp(configuration).getAllWebhooks(
                page,
                size,
                sort,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Get a webhook for an Inbox
         * @param {string} webhookId webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook(webhookId: string, options?: any) {
            return WebhookControllerApiFp(configuration).getWebhook(
                webhookId,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Get all Webhooks for an Inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(inboxId: string, options?: any) {
            return WebhookControllerApiFp(configuration).getWebhooks(
                inboxId,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Send webhook test data
         * @param {string} webhookId webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTestData(webhookId: string, options?: any) {
            return WebhookControllerApiFp(configuration).sendTestData(
                webhookId,
                options
            )(fetch, basePath);
        },
    };
};

/**
 * WebhookControllerApi - object-oriented interface
 * @export
 * @class WebhookControllerApi
 * @extends {BaseAPI}
 */
export class WebhookControllerApi extends BaseAPI {
    /**
     * Get notified whenever an inbox receives an email via a WebHook URL. An emailID will be posted to this URL every time an email is received for this inbox. The URL must be publicly reachable by the MailSlurp server. You can provide basicAuth values if you wish to secure this endpoint.
     * @summary Attach a WebHook URL to an inbox
     * @param {string} inboxId inboxId
     * @param {CreateWebhookOptions} webhookOptions webhookOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookControllerApi
     */
    public createWebhook(
        inboxId: string,
        webhookOptions: CreateWebhookOptions,
        options?: any
    ) {
        return WebhookControllerApiFp(this.configuration).createWebhook(
            inboxId,
            webhookOptions,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Delete and disable a Webhook for an Inbox
     * @param {string} inboxId inboxId
     * @param {string} webhookId webhookId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookControllerApi
     */
    public deleteWebhook(inboxId: string, webhookId: string, options?: any) {
        return WebhookControllerApiFp(this.configuration).deleteWebhook(
            inboxId,
            webhookId,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * List webhooks in paginated form. Allows for page index, page size, and sort direction.
     * @summary List Webhooks Paginated
     * @param {number} [page] Optional page index in inbox list pagination
     * @param {number} [size] Optional page size in inbox list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookControllerApi
     */
    public getAllWebhooks(
        page?: number,
        size?: number,
        sort?: 'ASC' | 'DESC',
        options?: any
    ) {
        return WebhookControllerApiFp(this.configuration).getAllWebhooks(
            page,
            size,
            sort,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get a webhook for an Inbox
     * @param {string} webhookId webhookId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookControllerApi
     */
    public getWebhook(webhookId: string, options?: any) {
        return WebhookControllerApiFp(this.configuration).getWebhook(
            webhookId,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get all Webhooks for an Inbox
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookControllerApi
     */
    public getWebhooks(inboxId: string, options?: any) {
        return WebhookControllerApiFp(this.configuration).getWebhooks(
            inboxId,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Send webhook test data
     * @param {string} webhookId webhookId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookControllerApi
     */
    public sendTestData(webhookId: string, options?: any) {
        return WebhookControllerApiFp(this.configuration).sendTestData(
            webhookId,
            options
        )(this.fetch, this.basePath);
    }
}
