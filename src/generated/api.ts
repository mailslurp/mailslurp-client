/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * MailSlurp API
 * MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://www.mailslurp.com/docs/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * OpenAPI spec version: b07184b5bb0c80e6c422971f09a802ac2b151884
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as url from 'url';
import * as portableFetch from 'portable-fetch';
import { Configuration } from './configuration';

const BASE_PATH = 'https://api.mailslurp.com'.replace(/\/+$/, '');

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ',',
    ssv: ' ',
    tsv: '\t',
    pipes: '|',
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(
        configuration?: Configuration,
        protected basePath: string = BASE_PATH,
        protected fetch: FetchAPI = portableFetch
    ) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: 'RequiredError';
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 *
 * @export
 * @interface AbstractWebhookPayload
 */
export interface AbstractWebhookPayload {
    /**
     *
     * @type {string}
     * @memberof AbstractWebhookPayload
     */
    eventName: AbstractWebhookPayload.EventNameEnum;
    /**
     *
     * @type {string}
     * @memberof AbstractWebhookPayload
     */
    messageId: string;
    /**
     *
     * @type {string}
     * @memberof AbstractWebhookPayload
     */
    webhookId: string;
    /**
     *
     * @type {string}
     * @memberof AbstractWebhookPayload
     */
    webhookName?: string;
}

/**
 * @export
 * @namespace AbstractWebhookPayload
 */
export namespace AbstractWebhookPayload {
    /**
     * @export
     * @enum {string}
     */
    export enum EventNameEnum {
        EMAILRECEIVED = <any>'EMAIL_RECEIVED',
        NEWEMAIL = <any>'NEW_EMAIL',
        NEWCONTACT = <any>'NEW_CONTACT',
        NEWATTACHMENT = <any>'NEW_ATTACHMENT',
    }
}

/**
 *
 * @export
 * @interface Alias
 */
export interface Alias {
    /**
     *
     * @type {Date}
     * @memberof Alias
     */
    createdAt: Date;
    /**
     *
     * @type {string}
     * @memberof Alias
     */
    emailAddress: string;
    /**
     *
     * @type {string}
     * @memberof Alias
     */
    id?: string;
    /**
     *
     * @type {string}
     * @memberof Alias
     */
    inboxId: string;
    /**
     *
     * @type {string}
     * @memberof Alias
     */
    name?: string;
    /**
     *
     * @type {Date}
     * @memberof Alias
     */
    updatedAt: Date;
    /**
     *
     * @type {boolean}
     * @memberof Alias
     */
    useThreads?: boolean;
    /**
     *
     * @type {string}
     * @memberof Alias
     */
    userId: string;
}

/**
 * Email alias representation
 * @export
 * @interface AliasDto
 */
export interface AliasDto {
    /**
     *
     * @type {Date}
     * @memberof AliasDto
     */
    createdAt?: Date;
    /**
     * The alias's email address for receiving email
     * @type {string}
     * @memberof AliasDto
     */
    emailAddress?: string;
    /**
     *
     * @type {string}
     * @memberof AliasDto
     */
    id: string;
    /**
     * Inbox that is associated with the alias
     * @type {string}
     * @memberof AliasDto
     */
    inboxId?: string;
    /**
     * Has the alias been verified. You must verify an alias if the masked email address has not yet been verified by your account
     * @type {boolean}
     * @memberof AliasDto
     */
    isVerified?: boolean;
    /**
     * The underlying email address that is hidden and will received forwarded email
     * @type {string}
     * @memberof AliasDto
     */
    maskedEmailAddress?: string;
    /**
     *
     * @type {string}
     * @memberof AliasDto
     */
    name?: string;
    /**
     *
     * @type {Date}
     * @memberof AliasDto
     */
    updatedAt?: Date;
    /**
     * If alias will generate response threads or not when email are received by it
     * @type {boolean}
     * @memberof AliasDto
     */
    useThreads?: boolean;
    /**
     *
     * @type {string}
     * @memberof AliasDto
     */
    userId: string;
}

/**
 * Representation of a alias
 * @export
 * @interface AliasProjection
 */
export interface AliasProjection {
    /**
     *
     * @type {Date}
     * @memberof AliasProjection
     */
    createdAt: Date;
    /**
     *
     * @type {string}
     * @memberof AliasProjection
     */
    emailAddress: string;
    /**
     *
     * @type {string}
     * @memberof AliasProjection
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof AliasProjection
     */
    inboxId: string;
    /**
     *
     * @type {string}
     * @memberof AliasProjection
     */
    name?: string;
    /**
     *
     * @type {Date}
     * @memberof AliasProjection
     */
    updatedAt: Date;
    /**
     *
     * @type {boolean}
     * @memberof AliasProjection
     */
    useThreads?: boolean;
    /**
     *
     * @type {string}
     * @memberof AliasProjection
     */
    userId: string;
}

/**
 * Meta data associated with an attachment. Attachments are stored as byte blobs so the meta data is stored separately.
 * @export
 * @interface AttachmentMetaData
 */
export interface AttachmentMetaData {
    /**
     * Size of attachment in bytes
     * @type {number}
     * @memberof AttachmentMetaData
     */
    contentLength?: number;
    /**
     * Content type of attachment such as `image/png`
     * @type {string}
     * @memberof AttachmentMetaData
     */
    contentType?: string;
    /**
     * ID of attachment
     * @type {string}
     * @memberof AttachmentMetaData
     */
    id?: string;
    /**
     * Name of attachment if given
     * @type {string}
     * @memberof AttachmentMetaData
     */
    name?: string;
}

/**
 *
 * @export
 * @interface AttachmentProjection
 */
export interface AttachmentProjection {
    /**
     * Attachment ID
     * @type {string}
     * @memberof AttachmentProjection
     */
    attachmentId?: string;
    /**
     * Content length of attachment in bytes
     * @type {number}
     * @memberof AttachmentProjection
     */
    contentLength?: number;
    /**
     * Content type of attachment.
     * @type {string}
     * @memberof AttachmentProjection
     */
    contentType?: string;
    /**
     *
     * @type {Date}
     * @memberof AttachmentProjection
     */
    createdAt: Date;
    /**
     *
     * @type {string}
     * @memberof AttachmentProjection
     */
    name?: string;
    /**
     *
     * @type {Date}
     * @memberof AttachmentProjection
     */
    updatedAt: Date;
    /**
     *
     * @type {string}
     * @memberof AttachmentProjection
     */
    userId: string;
}

/**
 * Basic Authentication options for webhooks. Will be used is present when calling webhook endpoints.
 * @export
 * @interface BasicAuthOptions
 */
export interface BasicAuthOptions {
    /**
     *
     * @type {string}
     * @memberof BasicAuthOptions
     */
    username: string;
    /**
     *
     * @type {string}
     * @memberof BasicAuthOptions
     */
    password: string;
}

/**
 * Options for bulk sending an email from multiple addresses. See regular `sendEmail` methods for more information.
 * @export
 * @interface BulkSendEmailOptions
 */
export interface BulkSendEmailOptions {
    /**
     * Inboxes to send the email from
     * @type {Array<string>}
     * @memberof BulkSendEmailOptions
     */
    inboxIds?: Array<string>;
    /**
     * Options for the email to be sent
     * @type {SendEmailOptions}
     * @memberof BulkSendEmailOptions
     */
    sendEmailOptions?: SendEmailOptions;
}

/**
 *
 * @export
 * @interface ContactDto
 */
export interface ContactDto {
    /**
     *
     * @type {string}
     * @memberof ContactDto
     */
    company?: string;
    /**
     *
     * @type {Date}
     * @memberof ContactDto
     */
    createdAt: Date;
    /**
     *
     * @type {Array<string>}
     * @memberof ContactDto
     */
    emailAddresses: Array<string>;
    /**
     *
     * @type {string}
     * @memberof ContactDto
     */
    firstName?: string;
    /**
     *
     * @type {string}
     * @memberof ContactDto
     */
    groupId?: string;
    /**
     *
     * @type {string}
     * @memberof ContactDto
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof ContactDto
     */
    lastName?: string;
    /**
     *
     * @type {JsonNode}
     * @memberof ContactDto
     */
    metaData?: JsonNode;
    /**
     *
     * @type {boolean}
     * @memberof ContactDto
     */
    optOut?: boolean;
    /**
     *
     * @type {string}
     * @memberof ContactDto
     */
    primaryEmailAddress?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof ContactDto
     */
    tags: Array<string>;
}

/**
 *
 * @export
 * @interface ContactProjection
 */
export interface ContactProjection {
    /**
     *
     * @type {string}
     * @memberof ContactProjection
     */
    company?: string;
    /**
     *
     * @type {Date}
     * @memberof ContactProjection
     */
    createdAt: Date;
    /**
     *
     * @type {Array<string>}
     * @memberof ContactProjection
     */
    emailAddresses?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof ContactProjection
     */
    firstName?: string;
    /**
     *
     * @type {string}
     * @memberof ContactProjection
     */
    groupId?: string;
    /**
     *
     * @type {string}
     * @memberof ContactProjection
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof ContactProjection
     */
    lastName?: string;
    /**
     *
     * @type {boolean}
     * @memberof ContactProjection
     */
    optOut?: boolean;
}

/**
 * Options for matching content using regex patterns based on Java Pattern syntax
 * @export
 * @interface ContentMatchOptions
 */
export interface ContentMatchOptions {
    /**
     * Java style regex pattern. Do not include the typical `/` at start or end of regex in some languages. Given an example `your code is: 12345` the pattern to extract match looks like `code is: (\\d{6})`. This will return an array of matches with the first matching the entire pattern and the subsequent matching the groups: `['code is: 123456', '123456']` See https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html for more information of available patterns.
     * @type {string}
     * @memberof ContentMatchOptions
     */
    pattern?: string;
}

/**
 * Create email alias options. Email aliases can be used to mask real email addresses behind an ID. You can also attach an inbox to an alias so that any email received by the inbox email address if forwarded to the alias email address.
 * @export
 * @interface CreateAliasOptions
 */
export interface CreateAliasOptions {
    /**
     * Email address to be hidden behind alias. Emails sent to the alias email address will be forwarded to this address. If you want to enable replies set useThreads true and the reply-to for the email will allow outbound communication via a thread.
     * @type {string}
     * @memberof CreateAliasOptions
     */
    emailAddress?: string;
    /**
     * Optional inbox ID to attach to alias. Null by default means an a new inbox will be created for the alias. Use a custom inbox to control what email address the alias uses. To use custom email addresses create a domain and an inbox, the use the inbox ID with this call. Emails received by this inbox will be forwarded to the alias email address
     * @type {string}
     * @memberof CreateAliasOptions
     */
    inboxId?: string;
    /**
     * Optional name for alias
     * @type {string}
     * @memberof CreateAliasOptions
     */
    name?: string;
    /**
     * Enable threads options. If true emails will be sent with a unique reply-to thread address. This means you can reply to the forwarded email and it will be sent to the recipients via your alias address. That way a thread conversation is preserved.
     * @type {boolean}
     * @memberof CreateAliasOptions
     */
    useThreads?: boolean;
}

/**
 *
 * @export
 * @interface CreateContactOptions
 */
export interface CreateContactOptions {
    /**
     * Set of email addresses belonging to the contact
     * @type {Array<string>}
     * @memberof CreateContactOptions
     */
    emailAddresses?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof CreateContactOptions
     */
    firstName?: string;
    /**
     * Group IDs that contact belongs to
     * @type {string}
     * @memberof CreateContactOptions
     */
    groupId?: string;
    /**
     * User metadata key value pairs to save for this contact. Can be any values you like.
     * @type {JsonNode}
     * @memberof CreateContactOptions
     */
    metaData?: JsonNode;
    /**
     * Has the user explicitly or implicitly opted out of being contacted? If so MailSlurp will ignore them in all actions.
     * @type {boolean}
     * @memberof CreateContactOptions
     */
    optOut?: boolean;
    /**
     * Tags that can be used to search and group contacts
     * @type {Array<string>}
     * @memberof CreateContactOptions
     */
    tags?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof CreateContactOptions
     */
    lastName?: string;
    /**
     *
     * @type {string}
     * @memberof CreateContactOptions
     */
    company?: string;
}

/**
 * Options for creating a domain to use with MailSlurp. You must have ownership access to this domain in order to verify it. Domains will not function correctly until the domain has been verified. See https://www.mailslurp.com/guides/custom-domains for help. Domains can be either `HTTP` or `SMTP` type. The type of domain determines which inboxes can be used with it. `SMTP` inboxes use a mail server running `mx.mailslurp.com` while `HTTP` inboxes are handled by AWS SES.
 * @export
 * @interface CreateDomainOptions
 */
export interface CreateDomainOptions {
    /**
     * Whether to create a catch all inbox for the domain. Any email sent to an address using your domain that cannot be matched to an existing inbox you created with the domain will be routed to the created catch all inbox. You can access emails using the regular methods on this inbox ID.
     * @type {boolean}
     * @memberof CreateDomainOptions
     */
    createdCatchAllInbox?: boolean;
    /**
     * Optional description of the domain.
     * @type {string}
     * @memberof CreateDomainOptions
     */
    description?: string;
    /**
     * The top level domain you wish to use with MailSlurp. Do not specify subdomain just the top level. So `test.com` covers all subdomains such as `mail.test.com`. Don't include a protocol such as `http://`. Once added you must complete the verification steps by adding the returned records to your domain.
     * @type {string}
     * @memberof CreateDomainOptions
     */
    domain?: string;
    /**
     * Domain type to create. HTTP or SMTP domain. HTTP domain uses MailSlurps SES MX records. SMTP uses a custom SMTP server MX record. SMTP domains can only be used with SMTP inboxes. SMTP inboxes are more reliable for public inbound emails while HTTP inboxes are more suitable for testing.
     * @type {string}
     * @memberof CreateDomainOptions
     */
    domainType?: CreateDomainOptions.DomainTypeEnum;
}

/**
 * @export
 * @namespace CreateDomainOptions
 */
export namespace CreateDomainOptions {
    /**
     * @export
     * @enum {string}
     */
    export enum DomainTypeEnum {
        HTTPINBOX = <any>'HTTP_INBOX',
        SMTPDOMAIN = <any>'SMTP_DOMAIN',
    }
}

/**
 *
 * @export
 * @interface CreateGroupOptions
 */
export interface CreateGroupOptions {
    /**
     *
     * @type {string}
     * @memberof CreateGroupOptions
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof CreateGroupOptions
     */
    description?: string;
}

/**
 * Options for creating an inbox. An inbox has a real email address that can send and receive emails. Inboxes can be permanent or expire at a given time. Inboxes are either `SMTP` or `HTTP` mailboxes. Use `SMTP` for public facing mailboxes and `HTTP` for test email accounts. `SMTP` inboxes are processed by a mail server running at `mx.mailslurp.com` while `HTTP` inboxes are processed by AWS SES. Inboxes can use a custom email address (by verifying your own domain) or a randomly assigned email ending in either `mailslurp.com` or (if `useDomainPool` is enabled) ending in a similar domain such as `mailslurp.xyz` (selected at random).
 * @export
 * @interface CreateInboxDto
 */
export interface CreateInboxDto {
    /**
     * Grant team access to this inbox and the emails that belong to it for team members of your organization.
     * @type {boolean}
     * @memberof CreateInboxDto
     */
    allowTeamAccess?: boolean;
    /**
     * Optional description of the inbox for labelling purposes. Is shown in the dashboard and can be used with
     * @type {string}
     * @memberof CreateInboxDto
     */
    description?: string;
    /**
     * A custom email address to use with the inbox. Defaults to null. When null MailSlurp will assign a random email address to the inbox such as `123@mailslurp.com`. If you use the `useDomainPool` option when the email address is null it will generate an email address with a more varied domain ending such as `123@mailslurp.info` or `123@mailslurp.biz`. When a custom email address is provided the address is split into a domain and the domain is queried against your user. If you have created the domain in the MailSlurp dashboard and verified it you can use any email address that ends with the domain. Note domain types must match the inbox type - so `SMTP` inboxes will only work with `SMTP` type domains. Send an email to this address and the inbox will receive and store it for you. To retrieve the email use the Inbox and Email Controller endpoints with the inbox ID.
     * @type {string}
     * @memberof CreateInboxDto
     */
    emailAddress?: string;
    /**
     * Optional inbox expiration date. If null then this inbox is permanent and the emails in it won't be deleted. If an expiration date is provided or is required by your plan the inbox will be closed when the expiration time is reached. Expired inboxes still contain their emails but can no longer send or receive emails. An ExpiredInboxRecord is created when an inbox and the email address and inbox ID are recorded. The expiresAt property is a timestamp string in ISO DateTime Format yyyy-MM-dd'T'HH:mm:ss.SSSXXX.
     * @type {Date}
     * @memberof CreateInboxDto
     */
    expiresAt?: Date;
    /**
     * Number of milliseconds that inbox should exist for
     * @type {number}
     * @memberof CreateInboxDto
     */
    expiresIn?: number;
    /**
     * Is the inbox a favorite. Marking an inbox as a favorite is typically done in the dashboard for quick access or filtering
     * @type {boolean}
     * @memberof CreateInboxDto
     */
    favourite?: boolean;
    /**
     * HTTP (default) or SMTP inbox type. HTTP inboxes are best for testing while SMTP inboxes are more reliable for public inbound email consumption. When using custom domains the domain type must match the inbox type. HTTP inboxes are processed by AWS SES while SMTP inboxes use a custom mail server running at `mx.mailslurp.com`.
     * @type {string}
     * @memberof CreateInboxDto
     */
    inboxType?: CreateInboxDto.InboxTypeEnum;
    /**
     * Optional name of the inbox. Displayed in the dashboard for easier search and used as the sender name when sending emails.
     * @type {string}
     * @memberof CreateInboxDto
     */
    name?: string;
    /**
     * Tags that inbox has been tagged with. Tags can be added to inboxes to group different inboxes within an account. You can also search for inboxes by tag in the dashboard UI.
     * @type {Array<string>}
     * @memberof CreateInboxDto
     */
    tags?: Array<string>;
    /**
     * Use the MailSlurp domain name pool with this inbox when creating the email address. Defaults to null. If enabled the inbox will be an email address with a domain randomly chosen from a list of the MailSlurp domains. This is useful when the default `@mailslurp.com` email addresses used with inboxes are blocked or considered spam by a provider or receiving service. When domain pool is enabled an email address will be generated ending in `@mailslurp.{world,info,xyz,...}` . This means a TLD is randomly selecting from a list of `.biz`, `.info`, `.xyz` etc to add variance to the generated email addresses. When null or false MailSlurp uses the default behavior of `@mailslurp.com` or custom email address provided by the emailAddress field. Note this feature is only available for `HTTP` inbox types.
     * @type {boolean}
     * @memberof CreateInboxDto
     */
    useDomainPool?: boolean;
}

/**
 * @export
 * @namespace CreateInboxDto
 */
export namespace CreateInboxDto {
    /**
     * @export
     * @enum {string}
     */
    export enum InboxTypeEnum {
        HTTPINBOX = <any>'HTTP_INBOX',
        SMTPINBOX = <any>'SMTP_INBOX',
    }
}

/**
 *
 * @export
 * @interface CreateTemplateOptions
 */
export interface CreateTemplateOptions {
    /**
     *
     * @type {string}
     * @memberof CreateTemplateOptions
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof CreateTemplateOptions
     */
    content: string;
}

/**
 * Options for creating a webhook. Webhooks can be attached to inboxes and MailSlurp will POST a webhook payload to the URL specified whenever the inbox receives an email. Webhooks are great for processing many inbound emails.
 * @export
 * @interface CreateWebhookOptions
 */
export interface CreateWebhookOptions {
    /**
     * Optional basic authentication that MailSlurp should use when calling the URL. For instance if your URL is https://example.com then basic auth will call a URL like https://{username}@{password}:example.com
     * @type {BasicAuthOptions}
     * @memberof CreateWebhookOptions
     */
    basicAuth?: BasicAuthOptions;
    /**
     * Optional webhook event name. Default is `EMAIL_RECEIVED`. Payload differ according to the webhook event name.
     * @type {string}
     * @memberof CreateWebhookOptions
     */
    eventName?: CreateWebhookOptions.EventNameEnum;
    /**
     * Optional name for the webhook
     * @type {string}
     * @memberof CreateWebhookOptions
     */
    name?: string;
    /**
     * Public URL on your server that MailSlurp can post WebhookNotification payload to when an email is received. The payload of the submitted JSON is described by https://api.mailslurp.com/schemas/webhook-payload
     * @type {string}
     * @memberof CreateWebhookOptions
     */
    url?: string;
}

/**
 * @export
 * @namespace CreateWebhookOptions
 */
export namespace CreateWebhookOptions {
    /**
     * @export
     * @enum {string}
     */
    export enum EventNameEnum {
        EMAILRECEIVED = <any>'EMAIL_RECEIVED',
        NEWEMAIL = <any>'NEW_EMAIL',
        NEWCONTACT = <any>'NEW_CONTACT',
        NEWATTACHMENT = <any>'NEW_ATTACHMENT',
    }
}

/**
 * Options for DNS query.
 * @export
 * @interface DNSLookupOptions
 */
export interface DNSLookupOptions {
    /**
     * List of record types you wish to query such as MX, DNS, TXT, NS, A etc.
     * @type {string}
     * @memberof DNSLookupOptions
     */
    hostname?: string;
    /**
     * Optionally control whether to omit the final dot in full DNS name values.
     * @type {boolean}
     * @memberof DNSLookupOptions
     */
    omitFinalDNSDot?: boolean;
    /**
     * List of record types you wish to query such as MX, DNS, TXT, NS, A etc.
     * @type {Array<string>}
     * @memberof DNSLookupOptions
     */
    recordTypes?: Array<DNSLookupOptions.RecordTypesEnum>;
}

/**
 * @export
 * @namespace DNSLookupOptions
 */
export namespace DNSLookupOptions {
    /**
     * @export
     * @enum {string}
     */
    export enum RecordTypesEnum {
        A = <any>'A',
        NS = <any>'NS',
        MD = <any>'MD',
        MF = <any>'MF',
        CNAME = <any>'CNAME',
        SOA = <any>'SOA',
        MB = <any>'MB',
        MG = <any>'MG',
        MR = <any>'MR',
        NULL = <any>'NULL',
        WKS = <any>'WKS',
        PTR = <any>'PTR',
        HINFO = <any>'HINFO',
        MINFO = <any>'MINFO',
        MX = <any>'MX',
        TXT = <any>'TXT',
        RP = <any>'RP',
        AFSDB = <any>'AFSDB',
        X25 = <any>'X25',
        ISDN = <any>'ISDN',
        RT = <any>'RT',
        NSAP = <any>'NSAP',
        NSAPPTR = <any>'NSAP_PTR',
        SIG = <any>'SIG',
        KEY = <any>'KEY',
        PX = <any>'PX',
        GPOS = <any>'GPOS',
        AAAA = <any>'AAAA',
        LOC = <any>'LOC',
        NXT = <any>'NXT',
        EID = <any>'EID',
        NIMLOC = <any>'NIMLOC',
        SRV = <any>'SRV',
        ATMA = <any>'ATMA',
        NAPTR = <any>'NAPTR',
        KX = <any>'KX',
        CERT = <any>'CERT',
        A6 = <any>'A6',
        DNAME = <any>'DNAME',
        SINK = <any>'SINK',
        OPT = <any>'OPT',
        APL = <any>'APL',
        DS = <any>'DS',
        SSHFP = <any>'SSHFP',
        IPSECKEY = <any>'IPSECKEY',
        RRSIG = <any>'RRSIG',
        NSEC = <any>'NSEC',
        DNSKEY = <any>'DNSKEY',
        DHCID = <any>'DHCID',
        NSEC3 = <any>'NSEC3',
        NSEC3PARAM = <any>'NSEC3PARAM',
        TLSA = <any>'TLSA',
        SMIMEA = <any>'SMIMEA',
        HIP = <any>'HIP',
        NINFO = <any>'NINFO',
        RKEY = <any>'RKEY',
        TALINK = <any>'TALINK',
        CDS = <any>'CDS',
        CDNSKEY = <any>'CDNSKEY',
        OPENPGPKEY = <any>'OPENPGPKEY',
        CSYNC = <any>'CSYNC',
        ZONEMD = <any>'ZONEMD',
        SVCB = <any>'SVCB',
        HTTPS = <any>'HTTPS',
        SPF = <any>'SPF',
        UINFO = <any>'UINFO',
        UID = <any>'UID',
        GID = <any>'GID',
        UNSPEC = <any>'UNSPEC',
        NID = <any>'NID',
        L32 = <any>'L32',
        L64 = <any>'L64',
        LP = <any>'LP',
        EUI48 = <any>'EUI48',
        EUI64 = <any>'EUI64',
        TKEY = <any>'TKEY',
        TSIG = <any>'TSIG',
        IXFR = <any>'IXFR',
        AXFR = <any>'AXFR',
        MAILB = <any>'MAILB',
        MAILA = <any>'MAILA',
        ANY = <any>'ANY',
        URI = <any>'URI',
        CAA = <any>'CAA',
        AVC = <any>'AVC',
        DOA = <any>'DOA',
        AMTRELAY = <any>'AMTRELAY',
        TA = <any>'TA',
        DLV = <any>'DLV',
    }
}

/**
 * DNS lookup result. Includes record type, time to live, raw response, and name value for the name server response.
 * @export
 * @interface DNSLookupResult
 */
export interface DNSLookupResult {
    /**
     *
     * @type {string}
     * @memberof DNSLookupResult
     */
    name: string;
    /**
     *
     * @type {Array<string>}
     * @memberof DNSLookupResult
     */
    recordEntries: Array<string>;
    /**
     *
     * @type {string}
     * @memberof DNSLookupResult
     */
    recordType: DNSLookupResult.RecordTypeEnum;
    /**
     *
     * @type {number}
     * @memberof DNSLookupResult
     */
    ttl: number;
}

/**
 * @export
 * @namespace DNSLookupResult
 */
export namespace DNSLookupResult {
    /**
     * @export
     * @enum {string}
     */
    export enum RecordTypeEnum {
        A = <any>'A',
        NS = <any>'NS',
        MD = <any>'MD',
        MF = <any>'MF',
        CNAME = <any>'CNAME',
        SOA = <any>'SOA',
        MB = <any>'MB',
        MG = <any>'MG',
        MR = <any>'MR',
        NULL = <any>'NULL',
        WKS = <any>'WKS',
        PTR = <any>'PTR',
        HINFO = <any>'HINFO',
        MINFO = <any>'MINFO',
        MX = <any>'MX',
        TXT = <any>'TXT',
        RP = <any>'RP',
        AFSDB = <any>'AFSDB',
        X25 = <any>'X25',
        ISDN = <any>'ISDN',
        RT = <any>'RT',
        NSAP = <any>'NSAP',
        NSAPPTR = <any>'NSAP_PTR',
        SIG = <any>'SIG',
        KEY = <any>'KEY',
        PX = <any>'PX',
        GPOS = <any>'GPOS',
        AAAA = <any>'AAAA',
        LOC = <any>'LOC',
        NXT = <any>'NXT',
        EID = <any>'EID',
        NIMLOC = <any>'NIMLOC',
        SRV = <any>'SRV',
        ATMA = <any>'ATMA',
        NAPTR = <any>'NAPTR',
        KX = <any>'KX',
        CERT = <any>'CERT',
        A6 = <any>'A6',
        DNAME = <any>'DNAME',
        SINK = <any>'SINK',
        OPT = <any>'OPT',
        APL = <any>'APL',
        DS = <any>'DS',
        SSHFP = <any>'SSHFP',
        IPSECKEY = <any>'IPSECKEY',
        RRSIG = <any>'RRSIG',
        NSEC = <any>'NSEC',
        DNSKEY = <any>'DNSKEY',
        DHCID = <any>'DHCID',
        NSEC3 = <any>'NSEC3',
        NSEC3PARAM = <any>'NSEC3PARAM',
        TLSA = <any>'TLSA',
        SMIMEA = <any>'SMIMEA',
        HIP = <any>'HIP',
        NINFO = <any>'NINFO',
        RKEY = <any>'RKEY',
        TALINK = <any>'TALINK',
        CDS = <any>'CDS',
        CDNSKEY = <any>'CDNSKEY',
        OPENPGPKEY = <any>'OPENPGPKEY',
        CSYNC = <any>'CSYNC',
        ZONEMD = <any>'ZONEMD',
        SVCB = <any>'SVCB',
        HTTPS = <any>'HTTPS',
        SPF = <any>'SPF',
        UINFO = <any>'UINFO',
        UID = <any>'UID',
        GID = <any>'GID',
        UNSPEC = <any>'UNSPEC',
        NID = <any>'NID',
        L32 = <any>'L32',
        L64 = <any>'L64',
        LP = <any>'LP',
        EUI48 = <any>'EUI48',
        EUI64 = <any>'EUI64',
        TKEY = <any>'TKEY',
        TSIG = <any>'TSIG',
        IXFR = <any>'IXFR',
        AXFR = <any>'AXFR',
        MAILB = <any>'MAILB',
        MAILA = <any>'MAILA',
        ANY = <any>'ANY',
        URI = <any>'URI',
        CAA = <any>'CAA',
        AVC = <any>'AVC',
        DOA = <any>'DOA',
        AMTRELAY = <any>'AMTRELAY',
        TA = <any>'TA',
        DLV = <any>'DLV',
    }
}

/**
 * Results of query on domain name servers
 * @export
 * @interface DNSLookupResults
 */
export interface DNSLookupResults {
    /**
     *
     * @type {Array<DNSLookupResult>}
     * @memberof DNSLookupResults
     */
    results: Array<DNSLookupResult>;
}

/**
 *
 * @export
 * @interface DescribeDomainOptions
 */
export interface DescribeDomainOptions {
    /**
     *
     * @type {string}
     * @memberof DescribeDomainOptions
     */
    domain: string;
}

/**
 * Name Server lookup result
 * @export
 * @interface DescribeMailServerDomainResult
 */
export interface DescribeMailServerDomainResult {
    /**
     *
     * @type {string}
     * @memberof DescribeMailServerDomainResult
     */
    domain: string;
    /**
     *
     * @type {string}
     * @memberof DescribeMailServerDomainResult
     */
    message?: string;
    /**
     *
     * @type {Array<NameServerRecord>}
     * @memberof DescribeMailServerDomainResult
     */
    mxRecords: Array<NameServerRecord>;
}

/**
 * Domain plus verification records and status
 * @export
 * @interface DomainDto
 */
export interface DomainDto {
    /**
     * The optional catch all inbox that will receive emails sent to the domain that cannot be matched.
     * @type {string}
     * @memberof DomainDto
     */
    catchAllInboxId?: string;
    /**
     *
     * @type {Date}
     * @memberof DomainDto
     */
    createdAt: Date;
    /**
     * Unique token DKIM tokens
     * @type {Array<string>}
     * @memberof DomainDto
     */
    dkimTokens?: Array<string>;
    /**
     * Custom domain name
     * @type {string}
     * @memberof DomainDto
     */
    domain?: string;
    /**
     * List of DNS domain name records (C, MX, TXT) etc that you must add to the DNS server associated with your domain provider.
     * @type {Array<DomainNameRecord>}
     * @memberof DomainDto
     */
    domainNameRecords?: Array<DomainNameRecord>;
    /**
     * The type of domain. SMTP or HTTP domains differ in what inboxes can be used with them.
     * @type {string}
     * @memberof DomainDto
     */
    domainType?: DomainDto.DomainTypeEnum;
    /**
     *
     * @type {string}
     * @memberof DomainDto
     */
    id: string;
    /**
     * Whether domain has been verified or not. If the domain is not verified after 72 hours there is most likely an issue with the domains DNS records.
     * @type {boolean}
     * @memberof DomainDto
     */
    isVerified?: boolean;
    /**
     *
     * @type {Date}
     * @memberof DomainDto
     */
    updatedAt: Date;
    /**
     *
     * @type {string}
     * @memberof DomainDto
     */
    userId: string;
    /**
     * Verification tokens
     * @type {string}
     * @memberof DomainDto
     */
    verificationToken?: string;
}

/**
 * @export
 * @namespace DomainDto
 */
export namespace DomainDto {
    /**
     * @export
     * @enum {string}
     */
    export enum DomainTypeEnum {
        HTTPINBOX = <any>'HTTP_INBOX',
        SMTPDOMAIN = <any>'SMTP_DOMAIN',
    }
}

/**
 * DNS Record required for verification of a domain. Record vary depending on domain type.
 * @export
 * @interface DomainNameRecord
 */
export interface DomainNameRecord {
    /**
     *
     * @type {string}
     * @memberof DomainNameRecord
     */
    name: string;
    /**
     *
     * @type {Array<string>}
     * @memberof DomainNameRecord
     */
    recordEntries: Array<string>;
    /**
     *
     * @type {string}
     * @memberof DomainNameRecord
     */
    recordType: DomainNameRecord.RecordTypeEnum;
    /**
     *
     * @type {number}
     * @memberof DomainNameRecord
     */
    ttl: number;
}

/**
 * @export
 * @namespace DomainNameRecord
 */
export namespace DomainNameRecord {
    /**
     * @export
     * @enum {string}
     */
    export enum RecordTypeEnum {
        A = <any>'A',
        NS = <any>'NS',
        MD = <any>'MD',
        MF = <any>'MF',
        CNAME = <any>'CNAME',
        SOA = <any>'SOA',
        MB = <any>'MB',
        MG = <any>'MG',
        MR = <any>'MR',
        NULL = <any>'NULL',
        WKS = <any>'WKS',
        PTR = <any>'PTR',
        HINFO = <any>'HINFO',
        MINFO = <any>'MINFO',
        MX = <any>'MX',
        TXT = <any>'TXT',
        RP = <any>'RP',
        AFSDB = <any>'AFSDB',
        X25 = <any>'X25',
        ISDN = <any>'ISDN',
        RT = <any>'RT',
        NSAP = <any>'NSAP',
        NSAPPTR = <any>'NSAP_PTR',
        SIG = <any>'SIG',
        KEY = <any>'KEY',
        PX = <any>'PX',
        GPOS = <any>'GPOS',
        AAAA = <any>'AAAA',
        LOC = <any>'LOC',
        NXT = <any>'NXT',
        EID = <any>'EID',
        NIMLOC = <any>'NIMLOC',
        SRV = <any>'SRV',
        ATMA = <any>'ATMA',
        NAPTR = <any>'NAPTR',
        KX = <any>'KX',
        CERT = <any>'CERT',
        A6 = <any>'A6',
        DNAME = <any>'DNAME',
        SINK = <any>'SINK',
        OPT = <any>'OPT',
        APL = <any>'APL',
        DS = <any>'DS',
        SSHFP = <any>'SSHFP',
        IPSECKEY = <any>'IPSECKEY',
        RRSIG = <any>'RRSIG',
        NSEC = <any>'NSEC',
        DNSKEY = <any>'DNSKEY',
        DHCID = <any>'DHCID',
        NSEC3 = <any>'NSEC3',
        NSEC3PARAM = <any>'NSEC3PARAM',
        TLSA = <any>'TLSA',
        SMIMEA = <any>'SMIMEA',
        HIP = <any>'HIP',
        NINFO = <any>'NINFO',
        RKEY = <any>'RKEY',
        TALINK = <any>'TALINK',
        CDS = <any>'CDS',
        CDNSKEY = <any>'CDNSKEY',
        OPENPGPKEY = <any>'OPENPGPKEY',
        CSYNC = <any>'CSYNC',
        ZONEMD = <any>'ZONEMD',
        SVCB = <any>'SVCB',
        HTTPS = <any>'HTTPS',
        SPF = <any>'SPF',
        UINFO = <any>'UINFO',
        UID = <any>'UID',
        GID = <any>'GID',
        UNSPEC = <any>'UNSPEC',
        NID = <any>'NID',
        L32 = <any>'L32',
        L64 = <any>'L64',
        LP = <any>'LP',
        EUI48 = <any>'EUI48',
        EUI64 = <any>'EUI64',
        TKEY = <any>'TKEY',
        TSIG = <any>'TSIG',
        IXFR = <any>'IXFR',
        AXFR = <any>'AXFR',
        MAILB = <any>'MAILB',
        MAILA = <any>'MAILA',
        ANY = <any>'ANY',
        URI = <any>'URI',
        CAA = <any>'CAA',
        AVC = <any>'AVC',
        DOA = <any>'DOA',
        AMTRELAY = <any>'AMTRELAY',
        TA = <any>'TA',
        DLV = <any>'DLV',
    }
}

/**
 * Preview object for domain entity
 * @export
 * @interface DomainPreview
 */
export interface DomainPreview {
    /**
     *
     * @type {string}
     * @memberof DomainPreview
     */
    catchAllInboxId?: string;
    /**
     *
     * @type {Date}
     * @memberof DomainPreview
     */
    createdAt: Date;
    /**
     *
     * @type {string}
     * @memberof DomainPreview
     */
    domain: string;
    /**
     *
     * @type {string}
     * @memberof DomainPreview
     */
    id: string;
}

/**
 * Content of attachment
 * @export
 * @interface DownloadAttachmentDto
 */
export interface DownloadAttachmentDto {
    /**
     * Base64 encoded string of attachment bytes. Decode the base64 encoded string to get the raw contents. If the file has a content type such as `text/html` you can read the contents directly by converting it to string using `utf-8` encoding.
     * @type {string}
     * @memberof DownloadAttachmentDto
     */
    base64FileContents?: string;
    /**
     * Content type of attachment. Examples are `image/png`, `application/msword`, `text/csv` etc.
     * @type {string}
     * @memberof DownloadAttachmentDto
     */
    contentType?: string;
    /**
     * Size in bytes of attachment content
     * @type {number}
     * @memberof DownloadAttachmentDto
     */
    sizeBytes?: number;
}

/**
 * Email entity (also known as EmailDto). When an SMTP email message is received by MailSlurp it is parsed. The body and attachments are written to disk and the fields such as to, from, subject etc are stored in a database. The `body` contains the email content. If you want the original SMTP message see the `getRawEmail` endpoints. The attachments can be fetched using the AttachmentController
 * @export
 * @interface Email
 */
export interface Email {
    /**
     * Smart analysis of email content including spam ratings
     * @type {EmailAnalysis}
     * @memberof Email
     */
    analysis?: EmailAnalysis;
    /**
     * List of IDs of attachments found in the email. Use these IDs with the Inbox and Email Controllers to download attachments and attachment meta data such as filesize, name, extension.
     * @type {Array<string>}
     * @memberof Email
     */
    attachments?: Array<string>;
    /**
     * List of `BCC` recipients email was addressed to
     * @type {Array<string>}
     * @memberof Email
     */
    bcc?: Array<string>;
    /**
     * The body of the email message
     * @type {string}
     * @memberof Email
     */
    body?: string;
    /**
     * A hash signature of the email message
     * @type {string}
     * @memberof Email
     */
    bodyMD5Hash?: string;
    /**
     * List of `CC` recipients email was addressed to
     * @type {Array<string>}
     * @memberof Email
     */
    cc?: Array<string>;
    /**
     * Detected character set of the email body such as UTF-8
     * @type {string}
     * @memberof Email
     */
    charset?: string;
    /**
     * When was the email received by MailSlurp
     * @type {Date}
     * @memberof Email
     */
    createdAt?: Date;
    /**
     * Who the email was sent from
     * @type {string}
     * @memberof Email
     */
    from?: string;
    /**
     * Collection of SMTP headers attached to email
     * @type {{ [key: string]: string; }}
     * @memberof Email
     */
    headers?: { [key: string]: string };
    /**
     * ID of the email entity
     * @type {string}
     * @memberof Email
     */
    id?: string;
    /**
     * ID of the inbox that received the email
     * @type {string}
     * @memberof Email
     */
    inboxId?: string;
    /**
     * Is the email body HTML
     * @type {boolean}
     * @memberof Email
     */
    isHTML?: boolean;
    /**
     * Read flag. Has the email ever been viewed in the dashboard or fetched via the API? If so the email is marked as read.
     * @type {boolean}
     * @memberof Email
     */
    read?: boolean;
    /**
     * The `replyTo` field on the received email message
     * @type {string}
     * @memberof Email
     */
    replyTo?: string;
    /**
     * The subject line of the email message
     * @type {string}
     * @memberof Email
     */
    subject?: string;
    /**
     * Can the email be accessed by organization team members
     * @type {boolean}
     * @memberof Email
     */
    teamAccess?: boolean;
    /**
     * List of `To` recipients that email was addressed to
     * @type {Array<string>}
     * @memberof Email
     */
    to?: Array<string>;
    /**
     * When was the email last updated
     * @type {Date}
     * @memberof Email
     */
    updatedAt?: Date;
    /**
     * ID of user that email belongs to
     * @type {string}
     * @memberof Email
     */
    userId?: string;
}

/**
 * Analysis result for email. Each verdict property is a string PASS|FAIL|GRAY or dynamic error message
 * @export
 * @interface EmailAnalysis
 */
export interface EmailAnalysis {
    /**
     * Verdict of DomainKeys Identified Mail analysis
     * @type {string}
     * @memberof EmailAnalysis
     */
    dkimVerdict?: string;
    /**
     * Verdict of Domain-based Message Authentication Reporting and Conformance analysis
     * @type {string}
     * @memberof EmailAnalysis
     */
    dmarcVerdict?: string;
    /**
     * Verdict of spam ranking analysis
     * @type {string}
     * @memberof EmailAnalysis
     */
    spamVerdict?: string;
    /**
     * Verdict of Send Policy Framework record spoofing analysis
     * @type {string}
     * @memberof EmailAnalysis
     */
    spfVerdict?: string;
    /**
     * Verdict of virus scan analysis
     * @type {string}
     * @memberof EmailAnalysis
     */
    virusVerdict?: string;
}

/**
 * Matches for the given pattern
 * @export
 * @interface EmailContentMatchResult
 */
export interface EmailContentMatchResult {
    /**
     *
     * @type {Array<string>}
     * @memberof EmailContentMatchResult
     */
    matches: Array<string>;
    /**
     *
     * @type {string}
     * @memberof EmailContentMatchResult
     */
    pattern: string;
}

/**
 * Preview of an email message. For full message (including body and attachments) call the `getEmail` or other email endpoints with the provided email ID.
 * @export
 * @interface EmailPreview
 */
export interface EmailPreview {
    /**
     * List of IDs of attachments found in the email. Use these IDs with the Inbox and Email Controllers to download attachments and attachment meta data such as filesize, name, extension.
     * @type {Array<string>}
     * @memberof EmailPreview
     */
    attachments?: Array<string>;
    /**
     * List of `BCC` recipients email was addressed to
     * @type {Array<string>}
     * @memberof EmailPreview
     */
    bcc?: Array<string>;
    /**
     * List of `CC` recipients email was addressed to
     * @type {Array<string>}
     * @memberof EmailPreview
     */
    cc?: Array<string>;
    /**
     * When was the email received by MailSlurp
     * @type {Date}
     * @memberof EmailPreview
     */
    createdAt?: Date;
    /**
     * Who the email was sent from
     * @type {string}
     * @memberof EmailPreview
     */
    from?: string;
    /**
     * ID of the email entity
     * @type {string}
     * @memberof EmailPreview
     */
    id?: string;
    /**
     * Read flag. Has the email ever been viewed in the dashboard or fetched via the API? If so the email is marked as read.
     * @type {boolean}
     * @memberof EmailPreview
     */
    read?: boolean;
    /**
     * The subject line of the email message
     * @type {string}
     * @memberof EmailPreview
     */
    subject?: string;
    /**
     * List of `To` recipients that email was addressed to
     * @type {Array<string>}
     * @memberof EmailPreview
     */
    to?: Array<string>;
}

/**
 * A compact representation of a full email. Used in list endpoints to keep response sizes low. Body and attachments are not included. To get all fields of the email use the `getEmail` method with the email projection's ID. See `EmailDto` for documentation on projection properties.
 * @export
 * @interface EmailProjection
 */
export interface EmailProjection {
    /**
     *
     * @type {Array<string>}
     * @memberof EmailProjection
     */
    attachments?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof EmailProjection
     */
    bcc?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof EmailProjection
     */
    bodyMD5Hash?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof EmailProjection
     */
    cc?: Array<string>;
    /**
     *
     * @type {Date}
     * @memberof EmailProjection
     */
    createdAt: Date;
    /**
     *
     * @type {string}
     * @memberof EmailProjection
     */
    from?: string;
    /**
     *
     * @type {string}
     * @memberof EmailProjection
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof EmailProjection
     */
    inboxId: string;
    /**
     *
     * @type {boolean}
     * @memberof EmailProjection
     */
    read?: boolean;
    /**
     *
     * @type {string}
     * @memberof EmailProjection
     */
    subject?: string;
    /**
     *
     * @type {boolean}
     * @memberof EmailProjection
     */
    teamAccess?: boolean;
    /**
     *
     * @type {Array<string>}
     * @memberof EmailProjection
     */
    to: Array<string>;
}

/**
 * Parsed text of an email
 * @export
 * @interface EmailTextLinesResult
 */
export interface EmailTextLinesResult {
    /**
     *
     * @type {string}
     * @memberof EmailTextLinesResult
     */
    body: string;
    /**
     *
     * @type {Array<string>}
     * @memberof EmailTextLinesResult
     */
    lines: Array<string>;
}

/**
 * Email verification result. Valid means email address exists according to response from mail server running at the domian and port given.
 * @export
 * @interface EmailVerificationResult
 */
export interface EmailVerificationResult {
    /**
     *
     * @type {string}
     * @memberof EmailVerificationResult
     */
    domainName: string;
    /**
     *
     * @type {string}
     * @memberof EmailVerificationResult
     */
    emailAddress: string;
    /**
     *
     * @type {string}
     * @memberof EmailVerificationResult
     */
    error?: string;
    /**
     *
     * @type {boolean}
     * @memberof EmailVerificationResult
     */
    isValid: boolean;
    /**
     *
     * @type {number}
     * @memberof EmailVerificationResult
     */
    port: number;
}

/**
 * Expiration defaults for your account
 * @export
 * @interface ExpirationDefaults
 */
export interface ExpirationDefaults {
    /**
     *
     * @type {boolean}
     * @memberof ExpirationDefaults
     */
    canPermanentInbox: boolean;
    /**
     *
     * @type {number}
     * @memberof ExpirationDefaults
     */
    defaultExpirationMillis?: number;
    /**
     *
     * @type {Date}
     * @memberof ExpirationDefaults
     */
    defaultExpiresAt?: Date;
    /**
     *
     * @type {number}
     * @memberof ExpirationDefaults
     */
    maxExpirationMillis?: number;
}

/**
 * Expired inbox
 * @export
 * @interface ExpiredInboxDto
 */
export interface ExpiredInboxDto {
    /**
     *
     * @type {string}
     * @memberof ExpiredInboxDto
     */
    emailAddress: string;
    /**
     *
     * @type {string}
     * @memberof ExpiredInboxDto
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof ExpiredInboxDto
     */
    inboxId: string;
}

/**
 *
 * @export
 * @interface ExpiredInboxRecordProjection
 */
export interface ExpiredInboxRecordProjection {
    /**
     *
     * @type {Date}
     * @memberof ExpiredInboxRecordProjection
     */
    createdAt: Date;
    /**
     *
     * @type {string}
     * @memberof ExpiredInboxRecordProjection
     */
    emailAddress: string;
    /**
     *
     * @type {string}
     * @memberof ExpiredInboxRecordProjection
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof ExpiredInboxRecordProjection
     */
    userId: string;
}

/**
 * Options for forwarding an email
 * @export
 * @interface ForwardEmailOptions
 */
export interface ForwardEmailOptions {
    /**
     * Optional bcc recipients
     * @type {Array<string>}
     * @memberof ForwardEmailOptions
     */
    bcc?: Array<string>;
    /**
     * Optional cc recipients
     * @type {Array<string>}
     * @memberof ForwardEmailOptions
     */
    cc?: Array<string>;
    /**
     * Optional from override
     * @type {string}
     * @memberof ForwardEmailOptions
     */
    from?: string;
    /**
     * Subject for forwarded email
     * @type {string}
     * @memberof ForwardEmailOptions
     */
    subject?: string;
    /**
     * To recipients for forwarded email
     * @type {Array<string>}
     * @memberof ForwardEmailOptions
     */
    to?: Array<string>;
}

/**
 *
 * @export
 * @interface GroupContactsDto
 */
export interface GroupContactsDto {
    /**
     *
     * @type {Array<ContactDto>}
     * @memberof GroupContactsDto
     */
    contacts: Array<ContactDto>;
    /**
     *
     * @type {GroupDto}
     * @memberof GroupContactsDto
     */
    group: GroupDto;
}

/**
 *
 * @export
 * @interface GroupDto
 */
export interface GroupDto {
    /**
     *
     * @type {Date}
     * @memberof GroupDto
     */
    createdAt: Date;
    /**
     *
     * @type {string}
     * @memberof GroupDto
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof GroupDto
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof GroupDto
     */
    name: string;
}

/**
 *
 * @export
 * @interface GroupProjection
 */
export interface GroupProjection {
    /**
     *
     * @type {Date}
     * @memberof GroupProjection
     */
    createdAt: Date;
    /**
     *
     * @type {string}
     * @memberof GroupProjection
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof GroupProjection
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof GroupProjection
     */
    name: string;
}

/**
 * HTML Validation Results
 * @export
 * @interface HTMLValidationResult
 */
export interface HTMLValidationResult {
    /**
     * Optional errors resulting from HTML validation
     * @type {Array<ValidationMessage>}
     * @memberof HTMLValidationResult
     */
    errors?: Array<ValidationMessage>;
    /**
     * Is HTML validation result valid
     * @type {boolean}
     * @memberof HTMLValidationResult
     */
    isValid?: boolean;
    /**
     * Optional warnings resulting from HTML validation
     * @type {Array<ValidationMessage>}
     * @memberof HTMLValidationResult
     */
    warnings?: Array<ValidationMessage>;
}

/**
 * IP Address look up result for a given domain / hostname
 * @export
 * @interface IPAddressResult
 */
export interface IPAddressResult {
    /**
     *
     * @type {string}
     * @memberof IPAddressResult
     */
    address: string;
    /**
     *
     * @type {string}
     * @memberof IPAddressResult
     */
    hostname: string;
}

/**
 * Representation of a MailSlurp inbox. An inbox has an ID and a real email address. Emails can be sent to or from this email address. Inboxes are either `SMTP` or `HTTP` mailboxes. The default, `HTTP` inboxes, use AWS SES to process emails and are best suited as test email accounts. `SMTP` inboxes use a custom mail server at `mx.mailslurp.com` and are best used for public facing email addresses. Use the `EmailController` or the `InboxController` methods to send and receive emails and attachments. Inboxes may have a description, name, and tags for display purposes. You can also favourite an inbox for easier searching. Inboxes can be private or allow team access. Team access enabled inboxes can be seen by other members of an organization.
 * @export
 * @interface Inbox
 */
export interface Inbox {
    /**
     * When the inbox was created. Time stamps are in ISO DateTime Format `yyyy-MM-dd'T'HH:mm:ss.SSSXXX` e.g. `2000-10-31T01:30:00.000-05:00`.
     * @type {Date}
     * @memberof Inbox
     */
    createdAt?: Date;
    /**
     * Description of an inbox for labelling and searching purposes
     * @type {string}
     * @memberof Inbox
     */
    description?: string;
    /**
     * The inbox's email address. Inbox projections and previews may not include the email address. To view the email address fetch the inbox entity directly. Send an email to this address and the inbox will receive and store it for you. Note the email address in MailSlurp match characters exactly and are case sensitive so `+123` additions are considered different addresses. To retrieve the email use the Inbox and Email Controller endpoints with the inbox ID.
     * @type {string}
     * @memberof Inbox
     */
    emailAddress?: string;
    /**
     * Inbox expiration time. When, if ever, the inbox should expire and be deleted. If null then this inbox is permanent and the emails in it won't be deleted. This is the default behavior unless expiration date is set. If an expiration date is set and the time is reached MailSlurp will expire the inbox and move it to an expired inbox entity. You can still access the emails belonging to it but it can no longer send or receive email.
     * @type {string}
     * @memberof Inbox
     */
    expiresAt?: string;
    /**
     * Is the inbox a favorite inbox. Make an inbox a favorite is typically done in the dashboard for quick access or filtering
     * @type {boolean}
     * @memberof Inbox
     */
    favourite?: boolean;
    /**
     * ID of the inbox. The ID is a UUID-V4 format string. Use the inboxId for calls to Inbox and Email Controller endpoints. See the emailAddress property for the email address or the inbox. To get emails in an inbox use the WaitFor and Inbox Controller methods `waitForLatestEmail` and `getEmails` methods respectively. Inboxes can be used with aliases to forward emails automatically.
     * @type {string}
     * @memberof Inbox
     */
    id?: string;
    /**
     * Type of inbox - either HTTP (default) or SMTP. HTTP inboxes are great for testing. SMTP inboxes are processed by a custom SMTP mail server and are better for public facing inboxes that receive emails from Gmail and other large providers. If using a custom domain the domain type must match the inbox type. Use an SMTP domain for SMTP inboxes that includes an MX record pointing to `10 mx.mailslurp.com` for inbound messages.
     * @type {string}
     * @memberof Inbox
     */
    inboxType?: Inbox.InboxTypeEnum;
    /**
     * Name of the inbox and used as the sender name when sending emails .Displayed in the dashboard for easier search
     * @type {string}
     * @memberof Inbox
     */
    name?: string;
    /**
     * Is the inbox readOnly for the caller. Read only means can not be deleted or modified. This flag is present when using team accounts and shared inboxes.
     * @type {boolean}
     * @memberof Inbox
     */
    readOnly?: boolean;
    /**
     * Tags that inbox has been tagged with. Tags can be added to inboxes to group different inboxes within an account. You can also search for inboxes by tag in the dashboard UI.
     * @type {Array<string>}
     * @memberof Inbox
     */
    tags?: Array<string>;
    /**
     * Does inbox permit team access for organization team members. If so team users can use inbox and emails associated with it. See the team access guide at https://www.mailslurp.com/guides/team-email-account-sharing/
     * @type {boolean}
     * @memberof Inbox
     */
    teamAccess?: boolean;
    /**
     * ID of user that inbox belongs to
     * @type {string}
     * @memberof Inbox
     */
    userId?: string;
}

/**
 * @export
 * @namespace Inbox
 */
export namespace Inbox {
    /**
     * @export
     * @enum {string}
     */
    export enum InboxTypeEnum {
        HTTPINBOX = <any>'HTTP_INBOX',
        SMTPINBOX = <any>'SMTP_INBOX',
    }
}

/**
 *
 * @export
 * @interface InboxProjection
 */
export interface InboxProjection {
    /**
     *
     * @type {Date}
     * @memberof InboxProjection
     */
    createdAt: Date;
    /**
     *
     * @type {string}
     * @memberof InboxProjection
     */
    emailAddress?: string;
    /**
     *
     * @type {boolean}
     * @memberof InboxProjection
     */
    favourite: boolean;
    /**
     *
     * @type {string}
     * @memberof InboxProjection
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof InboxProjection
     */
    inboxType?: InboxProjection.InboxTypeEnum;
    /**
     *
     * @type {string}
     * @memberof InboxProjection
     */
    name?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof InboxProjection
     */
    tags?: Array<string>;
    /**
     *
     * @type {boolean}
     * @memberof InboxProjection
     */
    teamAccess: boolean;
}

/**
 * @export
 * @namespace InboxProjection
 */
export namespace InboxProjection {
    /**
     * @export
     * @enum {string}
     */
    export enum InboxTypeEnum {
        HTTPINBOX = <any>'HTTP_INBOX',
        SMTPINBOX = <any>'SMTP_INBOX',
    }
}

/**
 *
 * @export
 * @interface JsonNode
 */
export interface JsonNode {}

/**
 * Options for matching emails in an inbox. Each match option object contains a `field`, `should` and `value` property. Together they form logical conditions such as `SUBJECT` should `CONTAIN` value.
 * @export
 * @interface MatchOption
 */
export interface MatchOption {
    /**
     * The email property to match on. One of SUBJECT, TO, BCC, CC or FROM
     * @type {string}
     * @memberof MatchOption
     */
    field?: MatchOption.FieldEnum;
    /**
     * What criteria to apply. CONTAIN or EQUAL. Note CONTAIN is recommended due to some SMTP servers adding new lines to fields and body content.
     * @type {string}
     * @memberof MatchOption
     */
    should?: MatchOption.ShouldEnum;
    /**
     * The value you wish to compare with the value of the field specified using the `should` value passed. For example `BODY` should `CONTAIN` a value passed.
     * @type {string}
     * @memberof MatchOption
     */
    value?: string;
}

/**
 * @export
 * @namespace MatchOption
 */
export namespace MatchOption {
    /**
     * @export
     * @enum {string}
     */
    export enum FieldEnum {
        SUBJECT = <any>'SUBJECT',
        TO = <any>'TO',
        BCC = <any>'BCC',
        CC = <any>'CC',
        FROM = <any>'FROM',
    }
    /**
     * @export
     * @enum {string}
     */
    export enum ShouldEnum {
        CONTAIN = <any>'CONTAIN',
        EQUAL = <any>'EQUAL',
    }
}

/**
 * Optional filter for matching emails based on fields. For instance filter results to only include emails whose `SUBJECT` value does `CONTAIN` given match value. An example payload would be `{ matches: [{ field: 'SUBJECT', should: 'CONTAIN', value: 'Welcome' }] }`. If you wish to extract regex matches inside the email content see the `getEmailContentMatch` method in the EmailController.
 * @export
 * @interface MatchOptions
 */
export interface MatchOptions {
    /**
     * 1 or more match options. Options are additive so if one does not match the email is excluded from results
     * @type {Array<MatchOption>}
     * @memberof MatchOptions
     */
    matches?: Array<MatchOption>;
}

/**
 *
 * @export
 * @interface MissedEmail
 */
export interface MissedEmail {
    /**
     *
     * @type {number}
     * @memberof MissedEmail
     */
    attachmentCount: number;
    /**
     *
     * @type {Array<string>}
     * @memberof MissedEmail
     */
    bcc: Array<string>;
    /**
     *
     * @type {string}
     * @memberof MissedEmail
     */
    bodyExcerpt?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof MissedEmail
     */
    cc: Array<string>;
    /**
     *
     * @type {Date}
     * @memberof MissedEmail
     */
    createdAt: Date;
    /**
     *
     * @type {string}
     * @memberof MissedEmail
     */
    from?: string;
    /**
     *
     * @type {string}
     * @memberof MissedEmail
     */
    id?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof MissedEmail
     */
    inboxIds: Array<string>;
    /**
     *
     * @type {string}
     * @memberof MissedEmail
     */
    subject?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof MissedEmail
     */
    to: Array<string>;
    /**
     *
     * @type {Date}
     * @memberof MissedEmail
     */
    updatedAt: Date;
    /**
     *
     * @type {string}
     * @memberof MissedEmail
     */
    userId: string;
}

/**
 *
 * @export
 * @interface MissedEmailProjection
 */
export interface MissedEmailProjection {
    /**
     *
     * @type {Date}
     * @memberof MissedEmailProjection
     */
    createdAt: Date;
    /**
     *
     * @type {string}
     * @memberof MissedEmailProjection
     */
    from?: string;
    /**
     *
     * @type {string}
     * @memberof MissedEmailProjection
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof MissedEmailProjection
     */
    subject?: string;
    /**
     *
     * @type {string}
     * @memberof MissedEmailProjection
     */
    userId: string;
}

/**
 * Name Server Record
 * @export
 * @interface NameServerRecord
 */
export interface NameServerRecord {
    /**
     *
     * @type {string}
     * @memberof NameServerRecord
     */
    priority: string;
    /**
     *
     * @type {string}
     * @memberof NameServerRecord
     */
    raw: string;
    /**
     *
     * @type {string}
     * @memberof NameServerRecord
     */
    recordType: string;
    /**
     *
     * @type {string}
     * @memberof NameServerRecord
     */
    value: string;
}

/**
 *
 * @export
 * @interface OrganizationInboxProjection
 */
export interface OrganizationInboxProjection {
    /**
     * When the inbox was created. Time stamps are in ISO DateTime Format `yyyy-MM-dd'T'HH:mm:ss.SSSXXX` e.g. `2000-10-31T01:30:00.000-05:00`.
     * @type {Date}
     * @memberof OrganizationInboxProjection
     */
    createdAt?: Date;
    /**
     * The inbox's email address. Inbox projections and previews may not include the email address. To view the email address fetch the inbox entity directly. Send an email to this address and the inbox will receive and store it for you. Note the email address in MailSlurp match characters exactly and are case sensitive so `+123` additions are considered different addresses. To retrieve the email use the Inbox and Email Controller endpoints with the inbox ID.
     * @type {string}
     * @memberof OrganizationInboxProjection
     */
    emailAddress?: string;
    /**
     * Is the inbox a favorite inbox. Make an inbox a favorite is typically done in the dashboard for quick access or filtering
     * @type {boolean}
     * @memberof OrganizationInboxProjection
     */
    favourite?: boolean;
    /**
     * ID of the inbox. The ID is a UUID-V4 format string. Use the inboxId for calls to Inbox and Email Controller endpoints. See the emailAddress property for the email address or the inbox. To get emails in an inbox use the WaitFor and Inbox Controller methods `waitForLatestEmail` and `getEmails` methods respectively. Inboxes can be used with aliases to forward emails automatically.
     * @type {string}
     * @memberof OrganizationInboxProjection
     */
    id?: string;
    /**
     * Type of inbox - either HTTP (default) or SMTP. HTTP inboxes are great for testing. SMTP inboxes are processed by a custom SMTP mail server and are better for public facing inboxes that receive emails from Gmail and other large providers. If using a custom domain the domain type must match the inbox type. Use an SMTP domain for SMTP inboxes that includes an MX record pointing to `10 mx.mailslurp.com` for inbound messages.
     * @type {string}
     * @memberof OrganizationInboxProjection
     */
    inboxType?: OrganizationInboxProjection.InboxTypeEnum;
    /**
     * Name of the inbox and used as the sender name when sending emails .Displayed in the dashboard for easier search
     * @type {string}
     * @memberof OrganizationInboxProjection
     */
    name?: string;
    /**
     * Is the inbox readOnly for the caller. Read only means can not be deleted or modified. This flag is present when using team accounts and shared inboxes.
     * @type {boolean}
     * @memberof OrganizationInboxProjection
     */
    readOnly?: boolean;
    /**
     * Tags that inbox has been tagged with. Tags can be added to inboxes to group different inboxes within an account. You can also search for inboxes by tag in the dashboard UI.
     * @type {Array<string>}
     * @memberof OrganizationInboxProjection
     */
    tags?: Array<string>;
    /**
     * Does inbox permit team access for organization team members. If so team users can use inbox and emails associated with it. See the team access guide at https://www.mailslurp.com/guides/team-email-account-sharing/
     * @type {boolean}
     * @memberof OrganizationInboxProjection
     */
    teamAccess?: boolean;
}

/**
 * @export
 * @namespace OrganizationInboxProjection
 */
export namespace OrganizationInboxProjection {
    /**
     * @export
     * @enum {string}
     */
    export enum InboxTypeEnum {
        HTTPINBOX = <any>'HTTP_INBOX',
        SMTPINBOX = <any>'SMTP_INBOX',
    }
}

/**
 * Paginated email alias results. Page index starts at zero. Projection results may omit larger entity fields. For fetching a full entity use the projection ID with individual method calls.
 * @export
 * @interface PageAlias
 */
export interface PageAlias {
    /**
     *
     * @type {Array<AliasProjection>}
     * @memberof PageAlias
     */
    content?: Array<AliasProjection>;
    /**
     *
     * @type {boolean}
     * @memberof PageAlias
     */
    empty?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageAlias
     */
    first?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageAlias
     */
    last?: boolean;
    /**
     *
     * @type {number}
     * @memberof PageAlias
     */
    number?: number;
    /**
     *
     * @type {number}
     * @memberof PageAlias
     */
    numberOfElements?: number;
    /**
     *
     * @type {Pageable}
     * @memberof PageAlias
     */
    pageable?: Pageable;
    /**
     *
     * @type {number}
     * @memberof PageAlias
     */
    size?: number;
    /**
     *
     * @type {Sort}
     * @memberof PageAlias
     */
    sort?: Sort;
    /**
     *
     * @type {number}
     * @memberof PageAlias
     */
    totalElements?: number;
    /**
     *
     * @type {number}
     * @memberof PageAlias
     */
    totalPages?: number;
}

/**
 * Paginated attachment entity results. Page index starts at zero. Projection results may omit larger entity fields. For fetching a full entity use the projection ID with individual method calls.
 * @export
 * @interface PageAttachmentEntity
 */
export interface PageAttachmentEntity {
    /**
     *
     * @type {Array<AttachmentProjection>}
     * @memberof PageAttachmentEntity
     */
    content?: Array<AttachmentProjection>;
    /**
     *
     * @type {boolean}
     * @memberof PageAttachmentEntity
     */
    empty?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageAttachmentEntity
     */
    first?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageAttachmentEntity
     */
    last?: boolean;
    /**
     *
     * @type {number}
     * @memberof PageAttachmentEntity
     */
    number?: number;
    /**
     *
     * @type {number}
     * @memberof PageAttachmentEntity
     */
    numberOfElements?: number;
    /**
     *
     * @type {Pageable}
     * @memberof PageAttachmentEntity
     */
    pageable?: Pageable;
    /**
     *
     * @type {number}
     * @memberof PageAttachmentEntity
     */
    size?: number;
    /**
     *
     * @type {Sort}
     * @memberof PageAttachmentEntity
     */
    sort?: Sort;
    /**
     *
     * @type {number}
     * @memberof PageAttachmentEntity
     */
    totalElements?: number;
    /**
     *
     * @type {number}
     * @memberof PageAttachmentEntity
     */
    totalPages?: number;
}

/**
 * Paginated contact results. Page index starts at zero. Projection results may omit larger entity fields. For fetching a full entity use the projection ID with individual method calls.
 * @export
 * @interface PageContactProjection
 */
export interface PageContactProjection {
    /**
     *
     * @type {Array<ContactProjection>}
     * @memberof PageContactProjection
     */
    content?: Array<ContactProjection>;
    /**
     *
     * @type {boolean}
     * @memberof PageContactProjection
     */
    empty?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageContactProjection
     */
    first?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageContactProjection
     */
    last?: boolean;
    /**
     *
     * @type {number}
     * @memberof PageContactProjection
     */
    number?: number;
    /**
     *
     * @type {number}
     * @memberof PageContactProjection
     */
    numberOfElements?: number;
    /**
     *
     * @type {Pageable}
     * @memberof PageContactProjection
     */
    pageable?: Pageable;
    /**
     *
     * @type {number}
     * @memberof PageContactProjection
     */
    size?: number;
    /**
     *
     * @type {Sort}
     * @memberof PageContactProjection
     */
    sort?: Sort;
    /**
     *
     * @type {number}
     * @memberof PageContactProjection
     */
    totalElements?: number;
    /**
     *
     * @type {number}
     * @memberof PageContactProjection
     */
    totalPages?: number;
}

/**
 * Paginated email preview results. EmailProjections and EmailPreviews are essentially the same but have legacy naming issues. Page index starts at zero. Projection results may omit larger entity fields. For fetching a full entity use the projection ID with individual method calls. For emails there are several methods for fetching message bodies and attachments.
 * @export
 * @interface PageEmailPreview
 */
export interface PageEmailPreview {
    /**
     *
     * @type {Array<EmailPreview>}
     * @memberof PageEmailPreview
     */
    content?: Array<EmailPreview>;
    /**
     *
     * @type {boolean}
     * @memberof PageEmailPreview
     */
    empty?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageEmailPreview
     */
    first?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageEmailPreview
     */
    last?: boolean;
    /**
     *
     * @type {number}
     * @memberof PageEmailPreview
     */
    number?: number;
    /**
     *
     * @type {number}
     * @memberof PageEmailPreview
     */
    numberOfElements?: number;
    /**
     *
     * @type {Pageable}
     * @memberof PageEmailPreview
     */
    pageable?: Pageable;
    /**
     *
     * @type {number}
     * @memberof PageEmailPreview
     */
    size?: number;
    /**
     *
     * @type {Sort}
     * @memberof PageEmailPreview
     */
    sort?: Sort;
    /**
     *
     * @type {number}
     * @memberof PageEmailPreview
     */
    totalElements?: number;
    /**
     *
     * @type {number}
     * @memberof PageEmailPreview
     */
    totalPages?: number;
}

/**
 * Paginated email projection results. EmailProjections and EmailPreviews are essentially the same but have legacy naming issues. Page index starts at zero. Projection results may omit larger entity fields. For fetching a full email entity use the projection ID with individual method calls. For emails there are several methods for fetching message bodies and attachments.
 * @export
 * @interface PageEmailProjection
 */
export interface PageEmailProjection {
    /**
     *
     * @type {Array<EmailProjection>}
     * @memberof PageEmailProjection
     */
    content?: Array<EmailProjection>;
    /**
     *
     * @type {boolean}
     * @memberof PageEmailProjection
     */
    empty?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageEmailProjection
     */
    first?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageEmailProjection
     */
    last?: boolean;
    /**
     *
     * @type {number}
     * @memberof PageEmailProjection
     */
    number?: number;
    /**
     *
     * @type {number}
     * @memberof PageEmailProjection
     */
    numberOfElements?: number;
    /**
     *
     * @type {Pageable}
     * @memberof PageEmailProjection
     */
    pageable?: Pageable;
    /**
     *
     * @type {number}
     * @memberof PageEmailProjection
     */
    size?: number;
    /**
     *
     * @type {Sort}
     * @memberof PageEmailProjection
     */
    sort?: Sort;
    /**
     *
     * @type {number}
     * @memberof PageEmailProjection
     */
    totalElements?: number;
    /**
     *
     * @type {number}
     * @memberof PageEmailProjection
     */
    totalPages?: number;
}

/**
 * Paginated expired inbox results. Page index starts at zero. Projection results may omit larger entity fields. For fetching a full entity use the projection ID with individual method calls.
 * @export
 * @interface PageExpiredInboxRecordProjection
 */
export interface PageExpiredInboxRecordProjection {
    /**
     *
     * @type {Array<ExpiredInboxRecordProjection>}
     * @memberof PageExpiredInboxRecordProjection
     */
    content?: Array<ExpiredInboxRecordProjection>;
    /**
     *
     * @type {boolean}
     * @memberof PageExpiredInboxRecordProjection
     */
    empty?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageExpiredInboxRecordProjection
     */
    first?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageExpiredInboxRecordProjection
     */
    last?: boolean;
    /**
     *
     * @type {number}
     * @memberof PageExpiredInboxRecordProjection
     */
    number?: number;
    /**
     *
     * @type {number}
     * @memberof PageExpiredInboxRecordProjection
     */
    numberOfElements?: number;
    /**
     *
     * @type {Pageable}
     * @memberof PageExpiredInboxRecordProjection
     */
    pageable?: Pageable;
    /**
     *
     * @type {number}
     * @memberof PageExpiredInboxRecordProjection
     */
    size?: number;
    /**
     *
     * @type {Sort}
     * @memberof PageExpiredInboxRecordProjection
     */
    sort?: Sort;
    /**
     *
     * @type {number}
     * @memberof PageExpiredInboxRecordProjection
     */
    totalElements?: number;
    /**
     *
     * @type {number}
     * @memberof PageExpiredInboxRecordProjection
     */
    totalPages?: number;
}

/**
 * Paginated missed email results. Page index starts at zero. Projection results may omit larger entity fields. For fetching a full entity use the projection ID with individual method calls.
 * @export
 * @interface PageGroupProjection
 */
export interface PageGroupProjection {
    /**
     *
     * @type {Array<GroupProjection>}
     * @memberof PageGroupProjection
     */
    content?: Array<GroupProjection>;
    /**
     *
     * @type {boolean}
     * @memberof PageGroupProjection
     */
    empty?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageGroupProjection
     */
    first?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageGroupProjection
     */
    last?: boolean;
    /**
     *
     * @type {number}
     * @memberof PageGroupProjection
     */
    number?: number;
    /**
     *
     * @type {number}
     * @memberof PageGroupProjection
     */
    numberOfElements?: number;
    /**
     *
     * @type {Pageable}
     * @memberof PageGroupProjection
     */
    pageable?: Pageable;
    /**
     *
     * @type {number}
     * @memberof PageGroupProjection
     */
    size?: number;
    /**
     *
     * @type {Sort}
     * @memberof PageGroupProjection
     */
    sort?: Sort;
    /**
     *
     * @type {number}
     * @memberof PageGroupProjection
     */
    totalElements?: number;
    /**
     *
     * @type {number}
     * @memberof PageGroupProjection
     */
    totalPages?: number;
}

/**
 * Paginated inbox results. Page index starts at zero. Projection results may omit larger entity fields. For fetching a full entity use the projection ID with individual method calls.
 * @export
 * @interface PageInboxProjection
 */
export interface PageInboxProjection {
    /**
     *
     * @type {Array<InboxProjection>}
     * @memberof PageInboxProjection
     */
    content?: Array<InboxProjection>;
    /**
     *
     * @type {boolean}
     * @memberof PageInboxProjection
     */
    empty?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageInboxProjection
     */
    first?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageInboxProjection
     */
    last?: boolean;
    /**
     *
     * @type {number}
     * @memberof PageInboxProjection
     */
    number?: number;
    /**
     *
     * @type {number}
     * @memberof PageInboxProjection
     */
    numberOfElements?: number;
    /**
     *
     * @type {Pageable}
     * @memberof PageInboxProjection
     */
    pageable?: Pageable;
    /**
     *
     * @type {number}
     * @memberof PageInboxProjection
     */
    size?: number;
    /**
     *
     * @type {Sort}
     * @memberof PageInboxProjection
     */
    sort?: Sort;
    /**
     *
     * @type {number}
     * @memberof PageInboxProjection
     */
    totalElements?: number;
    /**
     *
     * @type {number}
     * @memberof PageInboxProjection
     */
    totalPages?: number;
}

/**
 * Paginated MissedEmail results. Page index starts at zero. Projection results may omit larger entity fields. For fetching a full entity use the projection ID with individual method calls.
 * @export
 * @interface PageMissedEmailProjection
 */
export interface PageMissedEmailProjection {
    /**
     *
     * @type {Array<MissedEmailProjection>}
     * @memberof PageMissedEmailProjection
     */
    content?: Array<MissedEmailProjection>;
    /**
     *
     * @type {boolean}
     * @memberof PageMissedEmailProjection
     */
    empty?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageMissedEmailProjection
     */
    first?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageMissedEmailProjection
     */
    last?: boolean;
    /**
     *
     * @type {number}
     * @memberof PageMissedEmailProjection
     */
    number?: number;
    /**
     *
     * @type {number}
     * @memberof PageMissedEmailProjection
     */
    numberOfElements?: number;
    /**
     *
     * @type {Pageable}
     * @memberof PageMissedEmailProjection
     */
    pageable?: Pageable;
    /**
     *
     * @type {number}
     * @memberof PageMissedEmailProjection
     */
    size?: number;
    /**
     *
     * @type {Sort}
     * @memberof PageMissedEmailProjection
     */
    sort?: Sort;
    /**
     *
     * @type {number}
     * @memberof PageMissedEmailProjection
     */
    totalElements?: number;
    /**
     *
     * @type {number}
     * @memberof PageMissedEmailProjection
     */
    totalPages?: number;
}

/**
 * Paginated organization inbox results. Page index starts at zero. Projection results may omit larger entity fields. For fetching a full entity use the projection ID with individual method calls.
 * @export
 * @interface PageOrganizationInboxProjection
 */
export interface PageOrganizationInboxProjection {
    /**
     *
     * @type {Array<OrganizationInboxProjection>}
     * @memberof PageOrganizationInboxProjection
     */
    content?: Array<OrganizationInboxProjection>;
    /**
     *
     * @type {boolean}
     * @memberof PageOrganizationInboxProjection
     */
    empty?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageOrganizationInboxProjection
     */
    first?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageOrganizationInboxProjection
     */
    last?: boolean;
    /**
     *
     * @type {number}
     * @memberof PageOrganizationInboxProjection
     */
    number?: number;
    /**
     *
     * @type {number}
     * @memberof PageOrganizationInboxProjection
     */
    numberOfElements?: number;
    /**
     *
     * @type {Pageable}
     * @memberof PageOrganizationInboxProjection
     */
    pageable?: Pageable;
    /**
     *
     * @type {number}
     * @memberof PageOrganizationInboxProjection
     */
    size?: number;
    /**
     *
     * @type {Sort}
     * @memberof PageOrganizationInboxProjection
     */
    sort?: Sort;
    /**
     *
     * @type {number}
     * @memberof PageOrganizationInboxProjection
     */
    totalElements?: number;
    /**
     *
     * @type {number}
     * @memberof PageOrganizationInboxProjection
     */
    totalPages?: number;
}

/**
 * Paginated sent email results. Page index starts at zero. Projection results may omit larger entity fields. For fetching a full sent email entity use the projection ID with individual method calls.
 * @export
 * @interface PageSentEmailProjection
 */
export interface PageSentEmailProjection {
    /**
     * Collection of items
     * @type {Array<SentEmailProjection>}
     * @memberof PageSentEmailProjection
     */
    content?: Array<SentEmailProjection>;
    /**
     *
     * @type {boolean}
     * @memberof PageSentEmailProjection
     */
    empty?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageSentEmailProjection
     */
    first?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageSentEmailProjection
     */
    last?: boolean;
    /**
     * Page number starting at 0
     * @type {number}
     * @memberof PageSentEmailProjection
     */
    number?: number;
    /**
     * Number of items returned
     * @type {number}
     * @memberof PageSentEmailProjection
     */
    numberOfElements?: number;
    /**
     *
     * @type {Pageable}
     * @memberof PageSentEmailProjection
     */
    pageable?: Pageable;
    /**
     * Size of page requested
     * @type {number}
     * @memberof PageSentEmailProjection
     */
    size?: number;
    /**
     *
     * @type {Sort}
     * @memberof PageSentEmailProjection
     */
    sort?: Sort;
    /**
     * Total number of items available for querying
     * @type {number}
     * @memberof PageSentEmailProjection
     */
    totalElements?: number;
    /**
     * Total number of pages available
     * @type {number}
     * @memberof PageSentEmailProjection
     */
    totalPages?: number;
}

/**
 * Paginated email template results. Page index starts at zero. Projection results may omit larger entity fields. For fetching a full entity use the projection ID with individual method calls.
 * @export
 * @interface PageTemplateProjection
 */
export interface PageTemplateProjection {
    /**
     *
     * @type {Array<TemplateProjection>}
     * @memberof PageTemplateProjection
     */
    content?: Array<TemplateProjection>;
    /**
     *
     * @type {boolean}
     * @memberof PageTemplateProjection
     */
    empty?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageTemplateProjection
     */
    first?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageTemplateProjection
     */
    last?: boolean;
    /**
     *
     * @type {number}
     * @memberof PageTemplateProjection
     */
    number?: number;
    /**
     *
     * @type {number}
     * @memberof PageTemplateProjection
     */
    numberOfElements?: number;
    /**
     *
     * @type {Pageable}
     * @memberof PageTemplateProjection
     */
    pageable?: Pageable;
    /**
     *
     * @type {number}
     * @memberof PageTemplateProjection
     */
    size?: number;
    /**
     *
     * @type {Sort}
     * @memberof PageTemplateProjection
     */
    sort?: Sort;
    /**
     *
     * @type {number}
     * @memberof PageTemplateProjection
     */
    totalElements?: number;
    /**
     *
     * @type {number}
     * @memberof PageTemplateProjection
     */
    totalPages?: number;
}

/**
 * Paginated email projection results. EmailProjections and EmailPreviews are essentially the same but have legacy naming issues. Page index starts at zero. Projection results may omit larger entity fields. For fetching a full email entity use the projection ID with individual method calls. For emails there are several methods for fetching message bodies and attachments.
 * @export
 * @interface PageThreadProjection
 */
export interface PageThreadProjection {
    /**
     *
     * @type {Array<ThreadProjection>}
     * @memberof PageThreadProjection
     */
    content?: Array<ThreadProjection>;
    /**
     *
     * @type {boolean}
     * @memberof PageThreadProjection
     */
    empty?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageThreadProjection
     */
    first?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageThreadProjection
     */
    last?: boolean;
    /**
     *
     * @type {number}
     * @memberof PageThreadProjection
     */
    number?: number;
    /**
     *
     * @type {number}
     * @memberof PageThreadProjection
     */
    numberOfElements?: number;
    /**
     *
     * @type {Pageable}
     * @memberof PageThreadProjection
     */
    pageable?: Pageable;
    /**
     *
     * @type {number}
     * @memberof PageThreadProjection
     */
    size?: number;
    /**
     *
     * @type {Sort}
     * @memberof PageThreadProjection
     */
    sort?: Sort;
    /**
     *
     * @type {number}
     * @memberof PageThreadProjection
     */
    totalElements?: number;
    /**
     *
     * @type {number}
     * @memberof PageThreadProjection
     */
    totalPages?: number;
}

/**
 * Paginated webhook results. Page index starts at zero. Projection results may omit larger entity fields. For fetching a full entity use the projection ID with individual method calls.
 * @export
 * @interface PageWebhookProjection
 */
export interface PageWebhookProjection {
    /**
     *
     * @type {Array<WebhookProjection>}
     * @memberof PageWebhookProjection
     */
    content?: Array<WebhookProjection>;
    /**
     *
     * @type {boolean}
     * @memberof PageWebhookProjection
     */
    empty?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageWebhookProjection
     */
    first?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof PageWebhookProjection
     */
    last?: boolean;
    /**
     *
     * @type {number}
     * @memberof PageWebhookProjection
     */
    number?: number;
    /**
     *
     * @type {number}
     * @memberof PageWebhookProjection
     */
    numberOfElements?: number;
    /**
     *
     * @type {Pageable}
     * @memberof PageWebhookProjection
     */
    pageable?: Pageable;
    /**
     *
     * @type {number}
     * @memberof PageWebhookProjection
     */
    size?: number;
    /**
     *
     * @type {Sort}
     * @memberof PageWebhookProjection
     */
    sort?: Sort;
    /**
     *
     * @type {number}
     * @memberof PageWebhookProjection
     */
    totalElements?: number;
    /**
     *
     * @type {number}
     * @memberof PageWebhookProjection
     */
    totalPages?: number;
}

/**
 *
 * @export
 * @interface Pageable
 */
export interface Pageable {
    /**
     *
     * @type {number}
     * @memberof Pageable
     */
    offset?: number;
    /**
     *
     * @type {number}
     * @memberof Pageable
     */
    pageNumber?: number;
    /**
     *
     * @type {number}
     * @memberof Pageable
     */
    pageSize?: number;
    /**
     *
     * @type {boolean}
     * @memberof Pageable
     */
    paged?: boolean;
    /**
     *
     * @type {Sort}
     * @memberof Pageable
     */
    sort?: Sort;
    /**
     *
     * @type {boolean}
     * @memberof Pageable
     */
    unpaged?: boolean;
}

/**
 * Content in raw format
 * @export
 * @interface RawEmailJson
 */
export interface RawEmailJson {
    /**
     *
     * @type {string}
     * @memberof RawEmailJson
     */
    content: string;
}

/**
 * Options for replying to an alias email using the alias inbox
 * @export
 * @interface ReplyToAliasEmailOptions
 */
export interface ReplyToAliasEmailOptions {
    /**
     * List of uploaded attachments to send with the reply. Optional.
     * @type {Array<string>}
     * @memberof ReplyToAliasEmailOptions
     */
    attachments?: Array<string>;
    /**
     * Body of the reply email you want to send
     * @type {string}
     * @memberof ReplyToAliasEmailOptions
     */
    body?: string;
    /**
     * The charset that your message should be sent with. Optional. Default is UTF-8
     * @type {string}
     * @memberof ReplyToAliasEmailOptions
     */
    charset?: string;
    /**
     * Is the reply HTML
     * @type {boolean}
     * @memberof ReplyToAliasEmailOptions
     */
    isHTML?: boolean;
    /**
     * When to send the email. Typically immediately
     * @type {string}
     * @memberof ReplyToAliasEmailOptions
     */
    sendStrategy?: ReplyToAliasEmailOptions.SendStrategyEnum;
    /**
     * Template ID to use instead of body. Will use template variable map to fill defined variable slots.
     * @type {string}
     * @memberof ReplyToAliasEmailOptions
     */
    template?: string;
    /**
     * Template variables if using a template
     * @type {any}
     * @memberof ReplyToAliasEmailOptions
     */
    templateVariables?: any;
}

/**
 * @export
 * @namespace ReplyToAliasEmailOptions
 */
export namespace ReplyToAliasEmailOptions {
    /**
     * @export
     * @enum {string}
     */
    export enum SendStrategyEnum {
        SINGLEMESSAGE = <any>'SINGLE_MESSAGE',
    }
}

/**
 * Options for replying to email with API
 * @export
 * @interface ReplyToEmailOptions
 */
export interface ReplyToEmailOptions {
    /**
     * List of uploaded attachments to send with the reply. Optional.
     * @type {Array<string>}
     * @memberof ReplyToEmailOptions
     */
    attachments?: Array<string>;
    /**
     * Body of the reply email you want to send
     * @type {string}
     * @memberof ReplyToEmailOptions
     */
    body?: string;
    /**
     * The charset that your message should be sent with. Optional. Default is UTF-8
     * @type {string}
     * @memberof ReplyToEmailOptions
     */
    charset?: string;
    /**
     * The from header that should be used. Optional
     * @type {string}
     * @memberof ReplyToEmailOptions
     */
    from?: string;
    /**
     * Is the reply HTML
     * @type {boolean}
     * @memberof ReplyToEmailOptions
     */
    isHTML?: boolean;
    /**
     * The replyTo header that should be used. Optional
     * @type {string}
     * @memberof ReplyToEmailOptions
     */
    replyTo?: string;
    /**
     * When to send the email. Typically immediately
     * @type {string}
     * @memberof ReplyToEmailOptions
     */
    sendStrategy?: ReplyToEmailOptions.SendStrategyEnum;
    /**
     * Template ID to use instead of body. Will use template variable map to fill defined variable slots.
     * @type {string}
     * @memberof ReplyToEmailOptions
     */
    template?: string;
    /**
     * Template variables if using a template
     * @type {any}
     * @memberof ReplyToEmailOptions
     */
    templateVariables?: any;
}

/**
 * @export
 * @namespace ReplyToEmailOptions
 */
export namespace ReplyToEmailOptions {
    /**
     * @export
     * @enum {string}
     */
    export enum SendStrategyEnum {
        SINGLEMESSAGE = <any>'SINGLE_MESSAGE',
    }
}

/**
 * Options for sending an email message from an inbox. You must provide one of: `to`, `toGroup`, or `toContacts` to send an email. All other parameters are optional.
 * @export
 * @interface SendEmailOptions
 */
export interface SendEmailOptions {
    /**
     * Optional list of attachment IDs to send with this email. You must first upload each attachment separately in order to obtain attachment IDs. This way you can reuse attachments with different emails once uploaded.
     * @type {Array<string>}
     * @memberof SendEmailOptions
     */
    attachments?: Array<string>;
    /**
     * Optional list of bcc destination email addresses
     * @type {Array<string>}
     * @memberof SendEmailOptions
     */
    bcc?: Array<string>;
    /**
     * Optional contents of email. If body contains HTML then set `isHTML` to true to ensure that email clients render it correctly. You can use moustache template syntax in the email body in conjunction with `toGroup` contact variables or `templateVariables` data. If you need more templating control consider creating a template and using the `template` property instead of the body.
     * @type {string}
     * @memberof SendEmailOptions
     */
    body?: string;
    /**
     * Optional list of cc destination email addresses
     * @type {Array<string>}
     * @memberof SendEmailOptions
     */
    cc?: Array<string>;
    /**
     * Optional charset
     * @type {string}
     * @memberof SendEmailOptions
     */
    charset?: string;
    /**
     * Optional from address. If not set the source inbox address will be used for this field. Beware of potential spam penalties when setting this field to an address not used by the inbox. For custom email addresses use a custom domain.
     * @type {string}
     * @memberof SendEmailOptions
     */
    from?: string;
    /**
     * Optional HTML flag. If true the `content-type` of the email will be `text/html`. Set to true when sending HTML to ensure proper rending on email clients
     * @type {boolean}
     * @memberof SendEmailOptions
     */
    isHTML?: boolean;
    /**
     * Optional replyTo header
     * @type {string}
     * @memberof SendEmailOptions
     */
    replyTo?: string;
    /**
     * Optional strategy to use when sending the email
     * @type {string}
     * @memberof SendEmailOptions
     */
    sendStrategy?: SendEmailOptions.SendStrategyEnum;
    /**
     * Optional email subject line
     * @type {string}
     * @memberof SendEmailOptions
     */
    subject?: string;
    /**
     * Optional template ID to use for body. Will override body if provided. When using a template make sure you pass the corresponding map of `templateVariables`. You can find which variables are needed by fetching the template itself or viewing it in the dashboard.
     * @type {string}
     * @memberof SendEmailOptions
     */
    template?: string;
    /**
     * Optional map of template variables. Will replace moustache syntax variables in subject and body or template with the associated values if found.
     * @type {any}
     * @memberof SendEmailOptions
     */
    templateVariables?: any;
    /**
     * List of destination email addresses. Even single recipients must be in array form. Maximum recipients per email depends on your plan. If you need to send many emails try using contacts or contact groups or use a non standard sendStrategy to ensure that spam filters are not triggered (many recipients in one email can affect your spam rating).
     * @type {Array<string>}
     * @memberof SendEmailOptions
     */
    to?: Array<string>;
    /**
     * Optional list of contact IDs to send email to. Manage your contacts via the API or dashboard. When contacts are used the email is sent to each contact separately so they will not see other recipients.
     * @type {Array<string>}
     * @memberof SendEmailOptions
     */
    toContacts?: Array<string>;
    /**
     * Optional contact group ID to send email to. You can create contacts and contact groups in the API or dashboard and use them for email campaigns. When contact groups are used the email is sent to each contact separately so they will not see other recipients
     * @type {string}
     * @memberof SendEmailOptions
     */
    toGroup?: string;
}

/**
 * @export
 * @namespace SendEmailOptions
 */
export namespace SendEmailOptions {
    /**
     * @export
     * @enum {string}
     */
    export enum SendStrategyEnum {
        SINGLEMESSAGE = <any>'SINGLE_MESSAGE',
    }
}

/**
 * Sent email details
 * @export
 * @interface SentEmailDto
 */
export interface SentEmailDto {
    /**
     * Array of IDs of attachments that were sent with this email
     * @type {Array<string>}
     * @memberof SentEmailDto
     */
    attachments?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof SentEmailDto
     */
    bcc?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof SentEmailDto
     */
    body?: string;
    /**
     * MD5 Hash
     * @type {string}
     * @memberof SentEmailDto
     */
    bodyMD5Hash?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof SentEmailDto
     */
    cc?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof SentEmailDto
     */
    charset?: string;
    /**
     *
     * @type {string}
     * @memberof SentEmailDto
     */
    from?: string;
    /**
     * ID of sent email
     * @type {string}
     * @memberof SentEmailDto
     */
    id?: string;
    /**
     * Inbox ID email was sent from
     * @type {string}
     * @memberof SentEmailDto
     */
    inboxId?: string;
    /**
     *
     * @type {boolean}
     * @memberof SentEmailDto
     */
    isHTML?: boolean;
    /**
     *
     * @type {string}
     * @memberof SentEmailDto
     */
    replyTo?: string;
    /**
     *
     * @type {Date}
     * @memberof SentEmailDto
     */
    sentAt: Date;
    /**
     *
     * @type {string}
     * @memberof SentEmailDto
     */
    subject?: string;
    /**
     * Recipients email was sent to
     * @type {Array<string>}
     * @memberof SentEmailDto
     */
    to?: Array<string>;
    /**
     * User ID
     * @type {string}
     * @memberof SentEmailDto
     */
    userId?: string;
}

/**
 *
 * @export
 * @interface SentEmailProjection
 */
export interface SentEmailProjection {
    /**
     *
     * @type {Array<string>}
     * @memberof SentEmailProjection
     */
    attachments: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof SentEmailProjection
     */
    bcc: Array<string>;
    /**
     *
     * @type {string}
     * @memberof SentEmailProjection
     */
    bodyMD5Hash?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof SentEmailProjection
     */
    cc: Array<string>;
    /**
     *
     * @type {Date}
     * @memberof SentEmailProjection
     */
    createdAt: Date;
    /**
     *
     * @type {string}
     * @memberof SentEmailProjection
     */
    from?: string;
    /**
     *
     * @type {string}
     * @memberof SentEmailProjection
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof SentEmailProjection
     */
    inboxId: string;
    /**
     *
     * @type {string}
     * @memberof SentEmailProjection
     */
    subject?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof SentEmailProjection
     */
    to: Array<string>;
    /**
     *
     * @type {string}
     * @memberof SentEmailProjection
     */
    userId: string;
}

/**
 * Options for setting inbox favourite state
 * @export
 * @interface SetInboxFavouritedOptions
 */
export interface SetInboxFavouritedOptions {
    /**
     * Is the inbox a favorite. Marking an inbox as a favorite is typically done in the dashboard for quick access or filtering
     * @type {boolean}
     * @memberof SetInboxFavouritedOptions
     */
    state?: boolean;
}

/**
 *
 * @export
 * @interface SimpleSendEmailOptions
 */
export interface SimpleSendEmailOptions {
    /**
     * Body of the email message. Supports HTML
     * @type {string}
     * @memberof SimpleSendEmailOptions
     */
    body?: string;
    /**
     * ID of inbox to send from. If null an inbox will be created for sending
     * @type {string}
     * @memberof SimpleSendEmailOptions
     */
    senderId?: string;
    /**
     * Subject line of the email
     * @type {string}
     * @memberof SimpleSendEmailOptions
     */
    subject?: string;
    /**
     * Email address to send to
     * @type {string}
     * @memberof SimpleSendEmailOptions
     */
    to?: string;
}

/**
 *
 * @export
 * @interface Sort
 */
export interface Sort {
    /**
     *
     * @type {boolean}
     * @memberof Sort
     */
    empty?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof Sort
     */
    sorted?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof Sort
     */
    unsorted?: boolean;
}

/**
 *
 * @export
 * @interface TemplateDto
 */
export interface TemplateDto {
    /**
     *
     * @type {string}
     * @memberof TemplateDto
     */
    content: string;
    /**
     *
     * @type {Date}
     * @memberof TemplateDto
     */
    createdAt: Date;
    /**
     *
     * @type {string}
     * @memberof TemplateDto
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof TemplateDto
     */
    name: string;
    /**
     *
     * @type {Array<TemplateVariable>}
     * @memberof TemplateDto
     */
    variables: Array<TemplateVariable>;
}

/**
 *
 * @export
 * @interface TemplateProjection
 */
export interface TemplateProjection {
    /**
     *
     * @type {Date}
     * @memberof TemplateProjection
     */
    createdAt: Date;
    /**
     *
     * @type {string}
     * @memberof TemplateProjection
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof TemplateProjection
     */
    name: string;
    /**
     *
     * @type {Date}
     * @memberof TemplateProjection
     */
    updatedAt: Date;
    /**
     *
     * @type {Array<string>}
     * @memberof TemplateProjection
     */
    variables: Array<string>;
}

/**
 *
 * @export
 * @interface TemplateVariable
 */
export interface TemplateVariable {
    /**
     *
     * @type {string}
     * @memberof TemplateVariable
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof TemplateVariable
     */
    variableType: TemplateVariable.VariableTypeEnum;
}

/**
 * @export
 * @namespace TemplateVariable
 */
export namespace TemplateVariable {
    /**
     * @export
     * @enum {string}
     */
    export enum VariableTypeEnum {
        STRING = <any>'STRING',
    }
}

/**
 * A thread is a message thread created for a message received by an alias
 * @export
 * @interface ThreadProjection
 */
export interface ThreadProjection {
    /**
     *
     * @type {string}
     * @memberof ThreadProjection
     */
    aliasId: string;
    /**
     *
     * @type {Array<string>}
     * @memberof ThreadProjection
     */
    bcc?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ThreadProjection
     */
    cc?: Array<string>;
    /**
     *
     * @type {Date}
     * @memberof ThreadProjection
     */
    createdAt: Date;
    /**
     *
     * @type {string}
     * @memberof ThreadProjection
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof ThreadProjection
     */
    inboxId: string;
    /**
     *
     * @type {string}
     * @memberof ThreadProjection
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof ThreadProjection
     */
    subject?: string;
    /**
     *
     * @type {Array<string>}
     * @memberof ThreadProjection
     */
    to: Array<string>;
    /**
     *
     * @type {Date}
     * @memberof ThreadProjection
     */
    updatedAt: Date;
    /**
     *
     * @type {string}
     * @memberof ThreadProjection
     */
    userId: string;
}

/**
 *
 * @export
 * @interface UnreadCount
 */
export interface UnreadCount {
    /**
     *
     * @type {number}
     * @memberof UnreadCount
     */
    count: number;
}

/**
 * Update an email alias
 * @export
 * @interface UpdateAliasOptions
 */
export interface UpdateAliasOptions {
    /**
     * Optional name for alias
     * @type {string}
     * @memberof UpdateAliasOptions
     */
    name?: string;
}

/**
 * Options for creating a domain to use with MailSlurp. You must have ownership access to this domain in order to verify it. Domains will not functionally currently until the domain has been verified. See https://www.mailslurp.com/guides/custom-domains for help.
 * @export
 * @interface UpdateDomainOptions
 */
export interface UpdateDomainOptions {
    /**
     *
     * @type {string}
     * @memberof UpdateDomainOptions
     */
    catchAllInboxId?: string;
}

/**
 *
 * @export
 * @interface UpdateGroupContacts
 */
export interface UpdateGroupContacts {
    /**
     *
     * @type {Array<string>}
     * @memberof UpdateGroupContacts
     */
    contactIds: Array<string>;
}

/**
 * Options for updating inbox properties
 * @export
 * @interface UpdateInboxOptions
 */
export interface UpdateInboxOptions {
    /**
     * Description of an inbox for labelling and searching purposes
     * @type {string}
     * @memberof UpdateInboxOptions
     */
    description?: string;
    /**
     * Inbox expiration time. When, if ever, the inbox should expire and be deleted. If null then this inbox is permanent and the emails in it won't be deleted. This is the default behavior unless expiration date is set. If an expiration date is set and the time is reached MailSlurp will expire the inbox and move it to an expired inbox entity. You can still access the emails belonging to it but it can no longer send or receive email.
     * @type {Date}
     * @memberof UpdateInboxOptions
     */
    expiresAt?: Date;
    /**
     * Is the inbox a favorite inbox. Make an inbox a favorite is typically done in the dashboard for quick access or filtering
     * @type {boolean}
     * @memberof UpdateInboxOptions
     */
    favourite?: boolean;
    /**
     * Name of the inbox and used as the sender name when sending emails .Displayed in the dashboard for easier search
     * @type {string}
     * @memberof UpdateInboxOptions
     */
    name?: string;
    /**
     * Tags that inbox has been tagged with. Tags can be added to inboxes to group different inboxes within an account. You can also search for inboxes by tag in the dashboard UI.
     * @type {Array<string>}
     * @memberof UpdateInboxOptions
     */
    tags?: Array<string>;
}

/**
 * Options for uploading files for attachments. When sending emails with the API that require attachments first upload each attachment. Then use the returned attachment ID in your `SendEmailOptions` when sending an email. This way you can use attachments multiple times once they have been uploaded.
 * @export
 * @interface UploadAttachmentOptions
 */
export interface UploadAttachmentOptions {
    /**
     * Base64 encoded string of file contents. Typically this means reading the bytes or string content of a file and then converting that to a base64 encoded string.
     * @type {string}
     * @memberof UploadAttachmentOptions
     */
    base64Contents: string;
    /**
     * Optional contentType for file. For instance `application/pdf`
     * @type {string}
     * @memberof UploadAttachmentOptions
     */
    contentType?: string;
    /**
     * Optional filename to save upload with. Will be the name that is shown in email clients
     * @type {string}
     * @memberof UploadAttachmentOptions
     */
    filename?: string;
}

/**
 * Response object for email validation operation
 * @export
 * @interface ValidationDto
 */
export interface ValidationDto {
    /**
     * ID of the email validated
     * @type {string}
     * @memberof ValidationDto
     */
    emailId?: string;
    /**
     * Result of HTML validation
     * @type {HTMLValidationResult}
     * @memberof ValidationDto
     */
    html?: HTMLValidationResult;
}

/**
 *
 * @export
 * @interface ValidationMessage
 */
export interface ValidationMessage {
    /**
     *
     * @type {number}
     * @memberof ValidationMessage
     */
    lineNumber: number;
    /**
     *
     * @type {string}
     * @memberof ValidationMessage
     */
    message?: string;
}

/**
 * Options for verifying that an email address exists at a remote mail server.
 * @export
 * @interface VerifyEmailAddressOptions
 */
export interface VerifyEmailAddressOptions {
    /**
     *
     * @type {string}
     * @memberof VerifyEmailAddressOptions
     */
    mailServerDomain?: string;
    /**
     *
     * @type {string}
     * @memberof VerifyEmailAddressOptions
     */
    emailAddress: string;
    /**
     *
     * @type {string}
     * @memberof VerifyEmailAddressOptions
     */
    senderEmailAddress?: string;
    /**
     *
     * @type {number}
     * @memberof VerifyEmailAddressOptions
     */
    port?: number;
}

/**
 * Conditions that a `waitForXEmails` endpoint operates on. The methods wait until given conditions are met or a timeout is reached. If the conditions are met without needing to wait the results will be returned immediately.
 * @export
 * @interface WaitForConditions
 */
export interface WaitForConditions {
    /**
     * Number of results that should match conditions. Either exactly or at least this amount based on the `countType`. If count condition is not met and the timeout has not been reached the `waitFor` method will retry the operation.
     * @type {number}
     * @memberof WaitForConditions
     */
    count?: number;
    /**
     * How should the found count be compared to the expected count.
     * @type {string}
     * @memberof WaitForConditions
     */
    countType?: WaitForConditions.CountTypeEnum;
    /**
     * ID of inbox to search within and apply conditions to. Essentially filtering the emails found to give a count.
     * @type {string}
     * @memberof WaitForConditions
     */
    inboxId?: string;
    /**
     * Conditions that should be matched for an email to qualify for results. Each condition will be applied in order to each email within an inbox to filter a result list of matching emails you are waiting for.
     * @type {Array<MatchOption>}
     * @memberof WaitForConditions
     */
    matches?: Array<MatchOption>;
    /**
     * Direction to sort matching emails by created time
     * @type {string}
     * @memberof WaitForConditions
     */
    sortDirection?: WaitForConditions.SortDirectionEnum;
    /**
     * Max time in milliseconds to retry the `waitFor` operation until conditions are met.
     * @type {number}
     * @memberof WaitForConditions
     */
    timeout?: number;
    /**
     * Apply conditions only to **unread** emails. All emails begin with `read=false`. An email is marked `read=true` when an `EmailDto` representation of it has been returned to the user at least once. For example you have called `getEmail` or `waitForLatestEmail` etc., or you have viewed the email in the dashboard.
     * @type {boolean}
     * @memberof WaitForConditions
     */
    unreadOnly?: boolean;
}

/**
 * @export
 * @namespace WaitForConditions
 */
export namespace WaitForConditions {
    /**
     * @export
     * @enum {string}
     */
    export enum CountTypeEnum {
        EXACTLY = <any>'EXACTLY',
        ATLEAST = <any>'ATLEAST',
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SortDirectionEnum {
        ASC = <any>'ASC',
        DESC = <any>'DESC',
    }
}

/**
 * Representation of a webhook for an inbox. The URL specified will be using by MailSlurp whenever an email is received by the attached inbox. A webhook entity should have a URL that points to your server. Your server should accept HTTP/S POST requests and return a success 200. MailSlurp will retry your webhooks if they fail. See https://api.mailslurp.com/schemas/webhook-payload for the payload schema.
 * @export
 * @interface WebhookDto
 */
export interface WebhookDto {
    /**
     * Does webhook expect basic authentication? If true it means you created this webhook with a username and password. MailSlurp will use these in the URL to authenticate itself.
     * @type {boolean}
     * @memberof WebhookDto
     */
    basicAuth?: boolean;
    /**
     * When the webhook was created
     * @type {Date}
     * @memberof WebhookDto
     */
    createdAt?: Date;
    /**
     *
     * @type {string}
     * @memberof WebhookDto
     */
    eventName?: WebhookDto.EventNameEnum;
    /**
     * ID of the Webhook
     * @type {string}
     * @memberof WebhookDto
     */
    id?: string;
    /**
     * The inbox that the Webhook will be triggered by
     * @type {string}
     * @memberof WebhookDto
     */
    inboxId?: string;
    /**
     * HTTP method that your server endpoint must listen for
     * @type {string}
     * @memberof WebhookDto
     */
    method?: WebhookDto.MethodEnum;
    /**
     * Name of the webhook
     * @type {string}
     * @memberof WebhookDto
     */
    name?: string;
    /**
     * JSON Schema for the payload that will be sent to your URL via the HTTP method described.
     * @type {string}
     * @memberof WebhookDto
     */
    payloadJsonSchema?: string;
    /**
     *
     * @type {Date}
     * @memberof WebhookDto
     */
    updatedAt: Date;
    /**
     * URL of your server that the webhook will be sent to. The schema of the JSON that is sent is described by the payloadJsonSchema.
     * @type {string}
     * @memberof WebhookDto
     */
    url?: string;
}

/**
 * @export
 * @namespace WebhookDto
 */
export namespace WebhookDto {
    /**
     * @export
     * @enum {string}
     */
    export enum EventNameEnum {
        EMAILRECEIVED = <any>'EMAIL_RECEIVED',
        NEWEMAIL = <any>'NEW_EMAIL',
        NEWCONTACT = <any>'NEW_CONTACT',
        NEWATTACHMENT = <any>'NEW_ATTACHMENT',
    }
    /**
     * @export
     * @enum {string}
     */
    export enum MethodEnum {
        GET = <any>'GET',
        HEAD = <any>'HEAD',
        POST = <any>'POST',
        PUT = <any>'PUT',
        PATCH = <any>'PATCH',
        DELETE = <any>'DELETE',
        OPTIONS = <any>'OPTIONS',
        TRACE = <any>'TRACE',
    }
}

/**
 * Representation of a webhook
 * @export
 * @interface WebhookProjection
 */
export interface WebhookProjection {
    /**
     *
     * @type {Date}
     * @memberof WebhookProjection
     */
    createdAt: Date;
    /**
     *
     * @type {string}
     * @memberof WebhookProjection
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof WebhookProjection
     */
    inboxId: string;
    /**
     *
     * @type {string}
     * @memberof WebhookProjection
     */
    name?: string;
    /**
     *
     * @type {Date}
     * @memberof WebhookProjection
     */
    updatedAt: Date;
    /**
     *
     * @type {string}
     * @memberof WebhookProjection
     */
    url: string;
}

/**
 *
 * @export
 * @interface WebhookTestRequest
 */
export interface WebhookTestRequest {
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof WebhookTestRequest
     */
    headers: { [key: string]: string };
    /**
     *
     * @type {string}
     * @memberof WebhookTestRequest
     */
    method: WebhookTestRequest.MethodEnum;
    /**
     *
     * @type {string}
     * @memberof WebhookTestRequest
     */
    payload?: string;
    /**
     *
     * @type {string}
     * @memberof WebhookTestRequest
     */
    url: string;
}

/**
 * @export
 * @namespace WebhookTestRequest
 */
export namespace WebhookTestRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum MethodEnum {
        GET = <any>'GET',
        HEAD = <any>'HEAD',
        POST = <any>'POST',
        PUT = <any>'PUT',
        PATCH = <any>'PATCH',
        DELETE = <any>'DELETE',
        OPTIONS = <any>'OPTIONS',
        TRACE = <any>'TRACE',
    }
}

/**
 *
 * @export
 * @interface WebhookTestResponse
 */
export interface WebhookTestResponse {
    /**
     *
     * @type {string}
     * @memberof WebhookTestResponse
     */
    message?: string;
    /**
     *
     * @type {number}
     * @memberof WebhookTestResponse
     */
    statusCode?: number;
}

/**
 * Results of testing a webhook
 * @export
 * @interface WebhookTestResult
 */
export interface WebhookTestResult {
    /**
     *
     * @type {string}
     * @memberof WebhookTestResult
     */
    message?: string;
    /**
     *
     * @type {WebhookTestRequest}
     * @memberof WebhookTestResult
     */
    request: WebhookTestRequest;
    /**
     *
     * @type {WebhookTestResponse}
     * @memberof WebhookTestResult
     */
    response: WebhookTestResponse;
}

/**
 * AliasControllerApi - fetch parameter creator
 * @export
 */
export const AliasControllerApiFetchParamCreator = function(
    configuration?: Configuration
) {
    return {
        /**
         * Email aliases use a MailSlurp randomly generated email address (or a custom domain inbox that you provide) to mask or proxy a real email address. Emails sent to the alias address will be forwarded to the hidden email address it was created for. If you want to send a reply use the threadId attached
         * @summary Create an email alias. Must be verified by clicking link inside verification email that will be sent to the address. Once verified the alias will be active.
         * @param {CreateAliasOptions} createAliasOptions createAliasOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlias(
            createAliasOptions: CreateAliasOptions,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'createAliasOptions' is not null or undefined
            if (
                createAliasOptions === null ||
                createAliasOptions === undefined
            ) {
                throw new RequiredError(
                    'createAliasOptions',
                    'Required parameter createAliasOptions was null or undefined when calling createAlias.'
                );
            }
            const localVarPath = `/aliases`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'CreateAliasOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(createAliasOptions || {})
                : createAliasOptions || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete an email alias
         * @param {string} aliasId aliasId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlias(aliasId: string, options: any = {}): FetchArgs {
            // verify required parameter 'aliasId' is not null or undefined
            if (aliasId === null || aliasId === undefined) {
                throw new RequiredError(
                    'aliasId',
                    'Required parameter aliasId was null or undefined when calling deleteAlias.'
                );
            }
            const localVarPath = `/aliases/{aliasId}`.replace(
                `{${'aliasId'}}`,
                encodeURIComponent(String(aliasId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'DELETE' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an email alias by ID
         * @summary Get an email alias
         * @param {string} aliasId aliasId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlias(aliasId: string, options: any = {}): FetchArgs {
            // verify required parameter 'aliasId' is not null or undefined
            if (aliasId === null || aliasId === undefined) {
                throw new RequiredError(
                    'aliasId',
                    'Required parameter aliasId was null or undefined when calling getAlias.'
                );
            }
            const localVarPath = `/aliases/{aliasId}`.replace(
                `{${'aliasId'}}`,
                encodeURIComponent(String(aliasId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get paginated emails for an alias by ID
         * @summary Get emails for an alias
         * @param {string} aliasId aliasId
         * @param {number} [page] Optional page index alias email list pagination
         * @param {number} [size] Optional page size alias email list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAliasEmails(
            aliasId: string,
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'aliasId' is not null or undefined
            if (aliasId === null || aliasId === undefined) {
                throw new RequiredError(
                    'aliasId',
                    'Required parameter aliasId was null or undefined when calling getAliasEmails.'
                );
            }
            const localVarPath = `/aliases/{aliasId}/emails`.replace(
                `{${'aliasId'}}`,
                encodeURIComponent(String(aliasId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns threads created for an email alias in paginated form
         * @summary Get threads created for an alias
         * @param {string} aliasId aliasId
         * @param {number} [page] Optional page index in thread list pagination
         * @param {number} [size] Optional page size in thread list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAliasThreads(
            aliasId: string,
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'aliasId' is not null or undefined
            if (aliasId === null || aliasId === undefined) {
                throw new RequiredError(
                    'aliasId',
                    'Required parameter aliasId was null or undefined when calling getAliasThreads.'
                );
            }
            const localVarPath = `/aliases/{aliasId}/threads`.replace(
                `{${'aliasId'}}`,
                encodeURIComponent(String(aliasId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all email aliases in paginated form
         * @summary Get all email aliases you have created
         * @param {number} [page] Optional page index in alias list pagination
         * @param {number} [size] Optional page size in alias list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAliases(
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options: any = {}
        ): FetchArgs {
            const localVarPath = `/aliases`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send the reply to the email sender or reply-to and include same subject cc bcc etc. Reply to an email and the contents will be sent with the existing subject to the emails `to`, `cc`, and `bcc`.
         * @summary Reply to an email
         * @param {string} aliasId ID of the alias that email belongs to
         * @param {string} emailId ID of the email that should be replied to
         * @param {ReplyToAliasEmailOptions} replyToAliasEmailOptions replyToAliasEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replyToAliasEmail(
            aliasId: string,
            emailId: string,
            replyToAliasEmailOptions: ReplyToAliasEmailOptions,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'aliasId' is not null or undefined
            if (aliasId === null || aliasId === undefined) {
                throw new RequiredError(
                    'aliasId',
                    'Required parameter aliasId was null or undefined when calling replyToAliasEmail.'
                );
            }
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError(
                    'emailId',
                    'Required parameter emailId was null or undefined when calling replyToAliasEmail.'
                );
            }
            // verify required parameter 'replyToAliasEmailOptions' is not null or undefined
            if (
                replyToAliasEmailOptions === null ||
                replyToAliasEmailOptions === undefined
            ) {
                throw new RequiredError(
                    'replyToAliasEmailOptions',
                    'Required parameter replyToAliasEmailOptions was null or undefined when calling replyToAliasEmail.'
                );
            }
            const localVarPath = `/aliases/{aliasId}/emails/{emailId}`
                .replace(`{${'aliasId'}}`, encodeURIComponent(String(aliasId)))
                .replace(`{${'emailId'}}`, encodeURIComponent(String(emailId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'PUT' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'ReplyToAliasEmailOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(replyToAliasEmailOptions || {})
                : replyToAliasEmailOptions || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send an email from an alias. Replies to the email will be forwarded to the alias masked email address
         * @summary Send an email from an alias inbox
         * @param {string} aliasId aliasId
         * @param {SendEmailOptions} [sendEmailOptions] Options for the email to be sent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendAliasEmail(
            aliasId: string,
            sendEmailOptions?: SendEmailOptions,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'aliasId' is not null or undefined
            if (aliasId === null || aliasId === undefined) {
                throw new RequiredError(
                    'aliasId',
                    'Required parameter aliasId was null or undefined when calling sendAliasEmail.'
                );
            }
            const localVarPath = `/aliases/{aliasId}/emails`.replace(
                `{${'aliasId'}}`,
                encodeURIComponent(String(aliasId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'SendEmailOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(sendEmailOptions || {})
                : sendEmailOptions || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update an email alias
         * @param {string} aliasId aliasId
         * @param {UpdateAliasOptions} updateAliasOptions updateAliasOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlias(
            aliasId: string,
            updateAliasOptions: UpdateAliasOptions,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'aliasId' is not null or undefined
            if (aliasId === null || aliasId === undefined) {
                throw new RequiredError(
                    'aliasId',
                    'Required parameter aliasId was null or undefined when calling updateAlias.'
                );
            }
            // verify required parameter 'updateAliasOptions' is not null or undefined
            if (
                updateAliasOptions === null ||
                updateAliasOptions === undefined
            ) {
                throw new RequiredError(
                    'updateAliasOptions',
                    'Required parameter updateAliasOptions was null or undefined when calling updateAlias.'
                );
            }
            const localVarPath = `/aliases/{aliasId}`.replace(
                `{${'aliasId'}}`,
                encodeURIComponent(String(aliasId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'PUT' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'UpdateAliasOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(updateAliasOptions || {})
                : updateAliasOptions || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * AliasControllerApi - functional programming interface
 * @export
 */
export const AliasControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Email aliases use a MailSlurp randomly generated email address (or a custom domain inbox that you provide) to mask or proxy a real email address. Emails sent to the alias address will be forwarded to the hidden email address it was created for. If you want to send a reply use the threadId attached
         * @summary Create an email alias. Must be verified by clicking link inside verification email that will be sent to the address. Once verified the alias will be active.
         * @param {CreateAliasOptions} createAliasOptions createAliasOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlias(
            createAliasOptions: CreateAliasOptions,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<AliasDto> {
            const localVarFetchArgs = AliasControllerApiFetchParamCreator(
                configuration
            ).createAlias(createAliasOptions, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete an email alias
         * @param {string} aliasId aliasId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlias(
            aliasId: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AliasControllerApiFetchParamCreator(
                configuration
            ).deleteAlias(aliasId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get an email alias by ID
         * @summary Get an email alias
         * @param {string} aliasId aliasId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlias(
            aliasId: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<AliasDto> {
            const localVarFetchArgs = AliasControllerApiFetchParamCreator(
                configuration
            ).getAlias(aliasId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get paginated emails for an alias by ID
         * @summary Get emails for an alias
         * @param {string} aliasId aliasId
         * @param {number} [page] Optional page index alias email list pagination
         * @param {number} [size] Optional page size alias email list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAliasEmails(
            aliasId: string,
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<PageEmailProjection> {
            const localVarFetchArgs = AliasControllerApiFetchParamCreator(
                configuration
            ).getAliasEmails(aliasId, page, size, sort, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns threads created for an email alias in paginated form
         * @summary Get threads created for an alias
         * @param {string} aliasId aliasId
         * @param {number} [page] Optional page index in thread list pagination
         * @param {number} [size] Optional page size in thread list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAliasThreads(
            aliasId: string,
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<PageThreadProjection> {
            const localVarFetchArgs = AliasControllerApiFetchParamCreator(
                configuration
            ).getAliasThreads(aliasId, page, size, sort, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all email aliases in paginated form
         * @summary Get all email aliases you have created
         * @param {number} [page] Optional page index in alias list pagination
         * @param {number} [size] Optional page size in alias list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAliases(
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<PageAlias> {
            const localVarFetchArgs = AliasControllerApiFetchParamCreator(
                configuration
            ).getAliases(page, size, sort, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Send the reply to the email sender or reply-to and include same subject cc bcc etc. Reply to an email and the contents will be sent with the existing subject to the emails `to`, `cc`, and `bcc`.
         * @summary Reply to an email
         * @param {string} aliasId ID of the alias that email belongs to
         * @param {string} emailId ID of the email that should be replied to
         * @param {ReplyToAliasEmailOptions} replyToAliasEmailOptions replyToAliasEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replyToAliasEmail(
            aliasId: string,
            emailId: string,
            replyToAliasEmailOptions: ReplyToAliasEmailOptions,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<SentEmailDto> {
            const localVarFetchArgs = AliasControllerApiFetchParamCreator(
                configuration
            ).replyToAliasEmail(
                aliasId,
                emailId,
                replyToAliasEmailOptions,
                options
            );
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Send an email from an alias. Replies to the email will be forwarded to the alias masked email address
         * @summary Send an email from an alias inbox
         * @param {string} aliasId aliasId
         * @param {SendEmailOptions} [sendEmailOptions] Options for the email to be sent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendAliasEmail(
            aliasId: string,
            sendEmailOptions?: SendEmailOptions,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<SentEmailDto> {
            const localVarFetchArgs = AliasControllerApiFetchParamCreator(
                configuration
            ).sendAliasEmail(aliasId, sendEmailOptions, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Update an email alias
         * @param {string} aliasId aliasId
         * @param {UpdateAliasOptions} updateAliasOptions updateAliasOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlias(
            aliasId: string,
            updateAliasOptions: UpdateAliasOptions,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AliasControllerApiFetchParamCreator(
                configuration
            ).updateAlias(aliasId, updateAliasOptions, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    };
};

/**
 * AliasControllerApi - factory interface
 * @export
 */
export const AliasControllerApiFactory = function(
    configuration?: Configuration,
    fetch?: FetchAPI,
    basePath?: string
) {
    return {
        /**
         * Email aliases use a MailSlurp randomly generated email address (or a custom domain inbox that you provide) to mask or proxy a real email address. Emails sent to the alias address will be forwarded to the hidden email address it was created for. If you want to send a reply use the threadId attached
         * @summary Create an email alias. Must be verified by clicking link inside verification email that will be sent to the address. Once verified the alias will be active.
         * @param {CreateAliasOptions} createAliasOptions createAliasOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlias(createAliasOptions: CreateAliasOptions, options?: any) {
            return AliasControllerApiFp(configuration).createAlias(
                createAliasOptions,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Delete an email alias
         * @param {string} aliasId aliasId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlias(aliasId: string, options?: any) {
            return AliasControllerApiFp(configuration).deleteAlias(
                aliasId,
                options
            )(fetch, basePath);
        },
        /**
         * Get an email alias by ID
         * @summary Get an email alias
         * @param {string} aliasId aliasId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlias(aliasId: string, options?: any) {
            return AliasControllerApiFp(configuration).getAlias(
                aliasId,
                options
            )(fetch, basePath);
        },
        /**
         * Get paginated emails for an alias by ID
         * @summary Get emails for an alias
         * @param {string} aliasId aliasId
         * @param {number} [page] Optional page index alias email list pagination
         * @param {number} [size] Optional page size alias email list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAliasEmails(
            aliasId: string,
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ) {
            return AliasControllerApiFp(configuration).getAliasEmails(
                aliasId,
                page,
                size,
                sort,
                options
            )(fetch, basePath);
        },
        /**
         * Returns threads created for an email alias in paginated form
         * @summary Get threads created for an alias
         * @param {string} aliasId aliasId
         * @param {number} [page] Optional page index in thread list pagination
         * @param {number} [size] Optional page size in thread list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAliasThreads(
            aliasId: string,
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ) {
            return AliasControllerApiFp(configuration).getAliasThreads(
                aliasId,
                page,
                size,
                sort,
                options
            )(fetch, basePath);
        },
        /**
         * Get all email aliases in paginated form
         * @summary Get all email aliases you have created
         * @param {number} [page] Optional page index in alias list pagination
         * @param {number} [size] Optional page size in alias list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAliases(
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ) {
            return AliasControllerApiFp(configuration).getAliases(
                page,
                size,
                sort,
                options
            )(fetch, basePath);
        },
        /**
         * Send the reply to the email sender or reply-to and include same subject cc bcc etc. Reply to an email and the contents will be sent with the existing subject to the emails `to`, `cc`, and `bcc`.
         * @summary Reply to an email
         * @param {string} aliasId ID of the alias that email belongs to
         * @param {string} emailId ID of the email that should be replied to
         * @param {ReplyToAliasEmailOptions} replyToAliasEmailOptions replyToAliasEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replyToAliasEmail(
            aliasId: string,
            emailId: string,
            replyToAliasEmailOptions: ReplyToAliasEmailOptions,
            options?: any
        ) {
            return AliasControllerApiFp(configuration).replyToAliasEmail(
                aliasId,
                emailId,
                replyToAliasEmailOptions,
                options
            )(fetch, basePath);
        },
        /**
         * Send an email from an alias. Replies to the email will be forwarded to the alias masked email address
         * @summary Send an email from an alias inbox
         * @param {string} aliasId aliasId
         * @param {SendEmailOptions} [sendEmailOptions] Options for the email to be sent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendAliasEmail(
            aliasId: string,
            sendEmailOptions?: SendEmailOptions,
            options?: any
        ) {
            return AliasControllerApiFp(configuration).sendAliasEmail(
                aliasId,
                sendEmailOptions,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Update an email alias
         * @param {string} aliasId aliasId
         * @param {UpdateAliasOptions} updateAliasOptions updateAliasOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlias(
            aliasId: string,
            updateAliasOptions: UpdateAliasOptions,
            options?: any
        ) {
            return AliasControllerApiFp(configuration).updateAlias(
                aliasId,
                updateAliasOptions,
                options
            )(fetch, basePath);
        },
    };
};

/**
 * AliasControllerApi - object-oriented interface
 * @export
 * @class AliasControllerApi
 * @extends {BaseAPI}
 */
export class AliasControllerApi extends BaseAPI {
    /**
     * Email aliases use a MailSlurp randomly generated email address (or a custom domain inbox that you provide) to mask or proxy a real email address. Emails sent to the alias address will be forwarded to the hidden email address it was created for. If you want to send a reply use the threadId attached
     * @summary Create an email alias. Must be verified by clicking link inside verification email that will be sent to the address. Once verified the alias will be active.
     * @param {CreateAliasOptions} createAliasOptions createAliasOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasControllerApi
     */
    public createAlias(createAliasOptions: CreateAliasOptions, options?: any) {
        return AliasControllerApiFp(this.configuration).createAlias(
            createAliasOptions,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Delete an email alias
     * @param {string} aliasId aliasId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasControllerApi
     */
    public deleteAlias(aliasId: string, options?: any) {
        return AliasControllerApiFp(this.configuration).deleteAlias(
            aliasId,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Get an email alias by ID
     * @summary Get an email alias
     * @param {string} aliasId aliasId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasControllerApi
     */
    public getAlias(aliasId: string, options?: any) {
        return AliasControllerApiFp(this.configuration).getAlias(
            aliasId,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Get paginated emails for an alias by ID
     * @summary Get emails for an alias
     * @param {string} aliasId aliasId
     * @param {number} [page] Optional page index alias email list pagination
     * @param {number} [size] Optional page size alias email list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasControllerApi
     */
    public getAliasEmails(
        aliasId: string,
        page?: number,
        size?: number,
        sort?: 'ASC' | 'DESC',
        options?: any
    ) {
        return AliasControllerApiFp(this.configuration).getAliasEmails(
            aliasId,
            page,
            size,
            sort,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Returns threads created for an email alias in paginated form
     * @summary Get threads created for an alias
     * @param {string} aliasId aliasId
     * @param {number} [page] Optional page index in thread list pagination
     * @param {number} [size] Optional page size in thread list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasControllerApi
     */
    public getAliasThreads(
        aliasId: string,
        page?: number,
        size?: number,
        sort?: 'ASC' | 'DESC',
        options?: any
    ) {
        return AliasControllerApiFp(this.configuration).getAliasThreads(
            aliasId,
            page,
            size,
            sort,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Get all email aliases in paginated form
     * @summary Get all email aliases you have created
     * @param {number} [page] Optional page index in alias list pagination
     * @param {number} [size] Optional page size in alias list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasControllerApi
     */
    public getAliases(
        page?: number,
        size?: number,
        sort?: 'ASC' | 'DESC',
        options?: any
    ) {
        return AliasControllerApiFp(this.configuration).getAliases(
            page,
            size,
            sort,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Send the reply to the email sender or reply-to and include same subject cc bcc etc. Reply to an email and the contents will be sent with the existing subject to the emails `to`, `cc`, and `bcc`.
     * @summary Reply to an email
     * @param {string} aliasId ID of the alias that email belongs to
     * @param {string} emailId ID of the email that should be replied to
     * @param {ReplyToAliasEmailOptions} replyToAliasEmailOptions replyToAliasEmailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasControllerApi
     */
    public replyToAliasEmail(
        aliasId: string,
        emailId: string,
        replyToAliasEmailOptions: ReplyToAliasEmailOptions,
        options?: any
    ) {
        return AliasControllerApiFp(this.configuration).replyToAliasEmail(
            aliasId,
            emailId,
            replyToAliasEmailOptions,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Send an email from an alias. Replies to the email will be forwarded to the alias masked email address
     * @summary Send an email from an alias inbox
     * @param {string} aliasId aliasId
     * @param {SendEmailOptions} [sendEmailOptions] Options for the email to be sent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasControllerApi
     */
    public sendAliasEmail(
        aliasId: string,
        sendEmailOptions?: SendEmailOptions,
        options?: any
    ) {
        return AliasControllerApiFp(this.configuration).sendAliasEmail(
            aliasId,
            sendEmailOptions,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Update an email alias
     * @param {string} aliasId aliasId
     * @param {UpdateAliasOptions} updateAliasOptions updateAliasOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AliasControllerApi
     */
    public updateAlias(
        aliasId: string,
        updateAliasOptions: UpdateAliasOptions,
        options?: any
    ) {
        return AliasControllerApiFp(this.configuration).updateAlias(
            aliasId,
            updateAliasOptions,
            options
        )(this.fetch, this.basePath);
    }
}

/**
 * AttachmentControllerApi - fetch parameter creator
 * @export
 */
export const AttachmentControllerApiFetchParamCreator = function(
    configuration?: Configuration
) {
    return {
        /**
         * Email attachments are essentially files with meta data. Files are byte arrays and the meta data is a content type and a filename. These properties allow email clients to display the filename and icon etc. When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment ID and use it with subsequent email sending. For legacy reasons the ID is returned as the first element in an array. Only a single ID is ever returned. To send the attachments pass a list of attachment IDs with `SendEmailOptions` when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
         * @summary Delete an attachment
         * @param {string} attachmentId ID of attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttachment(attachmentId: string, options: any = {}): FetchArgs {
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError(
                    'attachmentId',
                    'Required parameter attachmentId was null or undefined when calling deleteAttachment.'
                );
            }
            const localVarPath = `/attachments/{attachmentId}`.replace(
                `{${'attachmentId'}}`,
                encodeURIComponent(String(attachmentId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'DELETE' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified attachment for a given email as a base 64 encoded string. The response type is application/json. This method is similar to the `downloadAttachment` method but allows some clients to get around issues with binary responses.
         * @summary Get email attachment as base64 encoded string as alternative to binary responses. To read the content decode the Base64 encoded contents.
         * @param {string} attachmentId ID of attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachmentAsBase64Encoded(
            attachmentId: string,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError(
                    'attachmentId',
                    'Required parameter attachmentId was null or undefined when calling downloadAttachmentAsBase64Encoded.'
                );
            }
            const localVarPath = `/attachments/{attachmentId}/base64`.replace(
                `{${'attachmentId'}}`,
                encodeURIComponent(String(attachmentId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified attachment for a given email as a stream / array of bytes. You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
         * @summary Download attachments. Get email attachment bytes. If you have trouble with byte responses try the `downloadAttachmentBase64` response endpoints.
         * @param {string} attachmentId ID of attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachmentAsBytes(
            attachmentId: string,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError(
                    'attachmentId',
                    'Required parameter attachmentId was null or undefined when calling downloadAttachmentAsBytes.'
                );
            }
            const localVarPath = `/attachments/{attachmentId}/bytes`.replace(
                `{${'attachmentId'}}`,
                encodeURIComponent(String(attachmentId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the metadata for an attachment. It is saved separately to the content of the attachment. Contains properties `name` and `content-type` and `content-length` in bytes for a given attachment.
         * @summary Get email attachment metadata information
         * @param {string} attachmentId ID of attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachmentInfo(attachmentId: string, options: any = {}): FetchArgs {
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError(
                    'attachmentId',
                    'Required parameter attachmentId was null or undefined when calling getAttachmentInfo.'
                );
            }
            const localVarPath = `/attachments/{attachmentId}/metadata`.replace(
                `{${'attachmentId'}}`,
                encodeURIComponent(String(attachmentId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all attachments in paginated response. Each entity contains meta data for the attachment such as `name` and `content-type`. Use the `attachmentId` and the download endpoints to get the file contents.
         * @summary Get email attachments
         * @param {string} [fileNameFilter] Optional file name and content type search filter
         * @param {number} [page] Optional page index event list pagination
         * @param {number} [size] Optional page size event list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachments(
            fileNameFilter?: string,
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options: any = {}
        ): FetchArgs {
            const localVarPath = `/attachments`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (fileNameFilter !== undefined) {
                localVarQueryParameter['fileNameFilter'] = fileNameFilter;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Email attachments are essentially files with meta data. Files are byte arrays and the meta data is a content type and a filename. These properties allow email clients to display the filename and icon etc. When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment ID and use it with subsequent email sending. For legacy reasons the ID is returned as the first element in an array. Only a single ID is ever returned. To send the attachments pass a list of attachment IDs with `SendEmailOptions` when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
         * @summary Upload an attachment for sending using base64 file encoding. Returns an array whose first element is the ID of the uploaded attachment.
         * @param {UploadAttachmentOptions} uploadOptions uploadOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAttachment(
            uploadOptions: UploadAttachmentOptions,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'uploadOptions' is not null or undefined
            if (uploadOptions === null || uploadOptions === undefined) {
                throw new RequiredError(
                    'uploadOptions',
                    'Required parameter uploadOptions was null or undefined when calling uploadAttachment.'
                );
            }
            const localVarPath = `/attachments`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'UploadAttachmentOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(uploadOptions || {})
                : uploadOptions || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Email attachments are essentially files with meta data. Files are byte arrays and the meta data is a content type and a filename. These properties allow email clients to display the filename and icon etc. When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment ID and use it with subsequent email sending. For legacy reasons the ID is returned as the first element in an array. Only a single ID is ever returned. To send the attachments pass a list of attachment IDs with `SendEmailOptions` when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
         * @summary Upload an attachment for sending using file byte stream input octet stream. Returns an array whose first element is the ID of the uploaded attachment.
         * @param {string} [string] Optional contentType for file. For instance &#x60;application/pdf&#x60;
         * @param {string} [byteArray] Byte array request body
         * @param {string} [filename] Optional filename to save upload with
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAttachmentBytes(
            string?: string,
            byteArray?: string,
            filename?: string,
            options: any = {}
        ): FetchArgs {
            const localVarPath = `/attachments/bytes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (string !== undefined) {
                localVarQueryParameter['String'] = string;
            }

            if (filename !== undefined) {
                localVarQueryParameter['filename'] = filename;
            }

            localVarHeaderParameter['Content-Type'] =
                'application/octet-stream';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'string' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(byteArray || {})
                : byteArray || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Email attachments are essentially files with meta data. Files are byte arrays and the meta data is a content type and a filename. These properties allow email clients to display the filename and icon etc. When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment ID and use it with subsequent email sending. For legacy reasons the ID is returned as the first element in an array. Only a single ID is ever returned. To send the attachments pass a list of attachment IDs with `SendEmailOptions` when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
         * @summary Upload an attachment for sending using a Multipart Form request. Returns an array whose first element is the ID of the uploaded attachment.
         * @param {any} file file
         * @param {string} [contentType] Optional content type of attachment
         * @param {string} [contentTypeHeader] Optional content type header of attachment
         * @param {string} [filename] Optional name of file
         * @param {string} [xFilename] Optional content type header of attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMultipartForm(
            file: any,
            contentType?: string,
            contentTypeHeader?: string,
            filename?: string,
            xFilename?: string,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError(
                    'file',
                    'Required parameter file was null or undefined when calling uploadMultipartForm.'
                );
            }
            const localVarPath = `/attachments/multipart`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (contentType !== undefined) {
                localVarQueryParameter['contentType'] = contentType;
            }

            if (filename !== undefined) {
                localVarQueryParameter['filename'] = filename;
            }

            if (xFilename !== undefined) {
                localVarQueryParameter['x-filename'] = xFilename;
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] =
                'application/x-www-form-urlencoded';

            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            localVarRequestOptions.body = localVarFormParams.toString();
            const needsSerialization =
                <any>'string' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(contentTypeHeader || {})
                : contentTypeHeader || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * AttachmentControllerApi - functional programming interface
 * @export
 */
export const AttachmentControllerApiFp = function(
    configuration?: Configuration
) {
    return {
        /**
         * Email attachments are essentially files with meta data. Files are byte arrays and the meta data is a content type and a filename. These properties allow email clients to display the filename and icon etc. When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment ID and use it with subsequent email sending. For legacy reasons the ID is returned as the first element in an array. Only a single ID is ever returned. To send the attachments pass a list of attachment IDs with `SendEmailOptions` when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
         * @summary Delete an attachment
         * @param {string} attachmentId ID of attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttachment(
            attachmentId: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AttachmentControllerApiFetchParamCreator(
                configuration
            ).deleteAttachment(attachmentId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the specified attachment for a given email as a base 64 encoded string. The response type is application/json. This method is similar to the `downloadAttachment` method but allows some clients to get around issues with binary responses.
         * @summary Get email attachment as base64 encoded string as alternative to binary responses. To read the content decode the Base64 encoded contents.
         * @param {string} attachmentId ID of attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachmentAsBase64Encoded(
            attachmentId: string,
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<DownloadAttachmentDto> {
            const localVarFetchArgs = AttachmentControllerApiFetchParamCreator(
                configuration
            ).downloadAttachmentAsBase64Encoded(attachmentId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the specified attachment for a given email as a stream / array of bytes. You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
         * @summary Download attachments. Get email attachment bytes. If you have trouble with byte responses try the `downloadAttachmentBase64` response endpoints.
         * @param {string} attachmentId ID of attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachmentAsBytes(
            attachmentId: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = AttachmentControllerApiFetchParamCreator(
                configuration
            ).downloadAttachmentAsBytes(attachmentId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the metadata for an attachment. It is saved separately to the content of the attachment. Contains properties `name` and `content-type` and `content-length` in bytes for a given attachment.
         * @summary Get email attachment metadata information
         * @param {string} attachmentId ID of attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachmentInfo(
            attachmentId: string,
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<AttachmentMetaData> {
            const localVarFetchArgs = AttachmentControllerApiFetchParamCreator(
                configuration
            ).getAttachmentInfo(attachmentId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all attachments in paginated response. Each entity contains meta data for the attachment such as `name` and `content-type`. Use the `attachmentId` and the download endpoints to get the file contents.
         * @summary Get email attachments
         * @param {string} [fileNameFilter] Optional file name and content type search filter
         * @param {number} [page] Optional page index event list pagination
         * @param {number} [size] Optional page size event list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachments(
            fileNameFilter?: string,
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<PageAttachmentEntity> {
            const localVarFetchArgs = AttachmentControllerApiFetchParamCreator(
                configuration
            ).getAttachments(fileNameFilter, page, size, sort, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Email attachments are essentially files with meta data. Files are byte arrays and the meta data is a content type and a filename. These properties allow email clients to display the filename and icon etc. When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment ID and use it with subsequent email sending. For legacy reasons the ID is returned as the first element in an array. Only a single ID is ever returned. To send the attachments pass a list of attachment IDs with `SendEmailOptions` when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
         * @summary Upload an attachment for sending using base64 file encoding. Returns an array whose first element is the ID of the uploaded attachment.
         * @param {UploadAttachmentOptions} uploadOptions uploadOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAttachment(
            uploadOptions: UploadAttachmentOptions,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = AttachmentControllerApiFetchParamCreator(
                configuration
            ).uploadAttachment(uploadOptions, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Email attachments are essentially files with meta data. Files are byte arrays and the meta data is a content type and a filename. These properties allow email clients to display the filename and icon etc. When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment ID and use it with subsequent email sending. For legacy reasons the ID is returned as the first element in an array. Only a single ID is ever returned. To send the attachments pass a list of attachment IDs with `SendEmailOptions` when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
         * @summary Upload an attachment for sending using file byte stream input octet stream. Returns an array whose first element is the ID of the uploaded attachment.
         * @param {string} [string] Optional contentType for file. For instance &#x60;application/pdf&#x60;
         * @param {string} [byteArray] Byte array request body
         * @param {string} [filename] Optional filename to save upload with
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAttachmentBytes(
            string?: string,
            byteArray?: string,
            filename?: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = AttachmentControllerApiFetchParamCreator(
                configuration
            ).uploadAttachmentBytes(string, byteArray, filename, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Email attachments are essentially files with meta data. Files are byte arrays and the meta data is a content type and a filename. These properties allow email clients to display the filename and icon etc. When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment ID and use it with subsequent email sending. For legacy reasons the ID is returned as the first element in an array. Only a single ID is ever returned. To send the attachments pass a list of attachment IDs with `SendEmailOptions` when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
         * @summary Upload an attachment for sending using a Multipart Form request. Returns an array whose first element is the ID of the uploaded attachment.
         * @param {any} file file
         * @param {string} [contentType] Optional content type of attachment
         * @param {string} [contentTypeHeader] Optional content type header of attachment
         * @param {string} [filename] Optional name of file
         * @param {string} [xFilename] Optional content type header of attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMultipartForm(
            file: any,
            contentType?: string,
            contentTypeHeader?: string,
            filename?: string,
            xFilename?: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = AttachmentControllerApiFetchParamCreator(
                configuration
            ).uploadMultipartForm(
                file,
                contentType,
                contentTypeHeader,
                filename,
                xFilename,
                options
            );
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    };
};

/**
 * AttachmentControllerApi - factory interface
 * @export
 */
export const AttachmentControllerApiFactory = function(
    configuration?: Configuration,
    fetch?: FetchAPI,
    basePath?: string
) {
    return {
        /**
         * Email attachments are essentially files with meta data. Files are byte arrays and the meta data is a content type and a filename. These properties allow email clients to display the filename and icon etc. When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment ID and use it with subsequent email sending. For legacy reasons the ID is returned as the first element in an array. Only a single ID is ever returned. To send the attachments pass a list of attachment IDs with `SendEmailOptions` when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
         * @summary Delete an attachment
         * @param {string} attachmentId ID of attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttachment(attachmentId: string, options?: any) {
            return AttachmentControllerApiFp(configuration).deleteAttachment(
                attachmentId,
                options
            )(fetch, basePath);
        },
        /**
         * Returns the specified attachment for a given email as a base 64 encoded string. The response type is application/json. This method is similar to the `downloadAttachment` method but allows some clients to get around issues with binary responses.
         * @summary Get email attachment as base64 encoded string as alternative to binary responses. To read the content decode the Base64 encoded contents.
         * @param {string} attachmentId ID of attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachmentAsBase64Encoded(attachmentId: string, options?: any) {
            return AttachmentControllerApiFp(
                configuration
            ).downloadAttachmentAsBase64Encoded(attachmentId, options)(
                fetch,
                basePath
            );
        },
        /**
         * Returns the specified attachment for a given email as a stream / array of bytes. You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
         * @summary Download attachments. Get email attachment bytes. If you have trouble with byte responses try the `downloadAttachmentBase64` response endpoints.
         * @param {string} attachmentId ID of attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachmentAsBytes(attachmentId: string, options?: any) {
            return AttachmentControllerApiFp(
                configuration
            ).downloadAttachmentAsBytes(attachmentId, options)(fetch, basePath);
        },
        /**
         * Returns the metadata for an attachment. It is saved separately to the content of the attachment. Contains properties `name` and `content-type` and `content-length` in bytes for a given attachment.
         * @summary Get email attachment metadata information
         * @param {string} attachmentId ID of attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachmentInfo(attachmentId: string, options?: any) {
            return AttachmentControllerApiFp(configuration).getAttachmentInfo(
                attachmentId,
                options
            )(fetch, basePath);
        },
        /**
         * Get all attachments in paginated response. Each entity contains meta data for the attachment such as `name` and `content-type`. Use the `attachmentId` and the download endpoints to get the file contents.
         * @summary Get email attachments
         * @param {string} [fileNameFilter] Optional file name and content type search filter
         * @param {number} [page] Optional page index event list pagination
         * @param {number} [size] Optional page size event list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachments(
            fileNameFilter?: string,
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ) {
            return AttachmentControllerApiFp(configuration).getAttachments(
                fileNameFilter,
                page,
                size,
                sort,
                options
            )(fetch, basePath);
        },
        /**
         * Email attachments are essentially files with meta data. Files are byte arrays and the meta data is a content type and a filename. These properties allow email clients to display the filename and icon etc. When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment ID and use it with subsequent email sending. For legacy reasons the ID is returned as the first element in an array. Only a single ID is ever returned. To send the attachments pass a list of attachment IDs with `SendEmailOptions` when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
         * @summary Upload an attachment for sending using base64 file encoding. Returns an array whose first element is the ID of the uploaded attachment.
         * @param {UploadAttachmentOptions} uploadOptions uploadOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAttachment(
            uploadOptions: UploadAttachmentOptions,
            options?: any
        ) {
            return AttachmentControllerApiFp(configuration).uploadAttachment(
                uploadOptions,
                options
            )(fetch, basePath);
        },
        /**
         * Email attachments are essentially files with meta data. Files are byte arrays and the meta data is a content type and a filename. These properties allow email clients to display the filename and icon etc. When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment ID and use it with subsequent email sending. For legacy reasons the ID is returned as the first element in an array. Only a single ID is ever returned. To send the attachments pass a list of attachment IDs with `SendEmailOptions` when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
         * @summary Upload an attachment for sending using file byte stream input octet stream. Returns an array whose first element is the ID of the uploaded attachment.
         * @param {string} [string] Optional contentType for file. For instance &#x60;application/pdf&#x60;
         * @param {string} [byteArray] Byte array request body
         * @param {string} [filename] Optional filename to save upload with
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAttachmentBytes(
            string?: string,
            byteArray?: string,
            filename?: string,
            options?: any
        ) {
            return AttachmentControllerApiFp(
                configuration
            ).uploadAttachmentBytes(string, byteArray, filename, options)(
                fetch,
                basePath
            );
        },
        /**
         * Email attachments are essentially files with meta data. Files are byte arrays and the meta data is a content type and a filename. These properties allow email clients to display the filename and icon etc. When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment ID and use it with subsequent email sending. For legacy reasons the ID is returned as the first element in an array. Only a single ID is ever returned. To send the attachments pass a list of attachment IDs with `SendEmailOptions` when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
         * @summary Upload an attachment for sending using a Multipart Form request. Returns an array whose first element is the ID of the uploaded attachment.
         * @param {any} file file
         * @param {string} [contentType] Optional content type of attachment
         * @param {string} [contentTypeHeader] Optional content type header of attachment
         * @param {string} [filename] Optional name of file
         * @param {string} [xFilename] Optional content type header of attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMultipartForm(
            file: any,
            contentType?: string,
            contentTypeHeader?: string,
            filename?: string,
            xFilename?: string,
            options?: any
        ) {
            return AttachmentControllerApiFp(configuration).uploadMultipartForm(
                file,
                contentType,
                contentTypeHeader,
                filename,
                xFilename,
                options
            )(fetch, basePath);
        },
    };
};

/**
 * AttachmentControllerApi - object-oriented interface
 * @export
 * @class AttachmentControllerApi
 * @extends {BaseAPI}
 */
export class AttachmentControllerApi extends BaseAPI {
    /**
     * Email attachments are essentially files with meta data. Files are byte arrays and the meta data is a content type and a filename. These properties allow email clients to display the filename and icon etc. When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment ID and use it with subsequent email sending. For legacy reasons the ID is returned as the first element in an array. Only a single ID is ever returned. To send the attachments pass a list of attachment IDs with `SendEmailOptions` when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
     * @summary Delete an attachment
     * @param {string} attachmentId ID of attachment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentControllerApi
     */
    public deleteAttachment(attachmentId: string, options?: any) {
        return AttachmentControllerApiFp(this.configuration).deleteAttachment(
            attachmentId,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Returns the specified attachment for a given email as a base 64 encoded string. The response type is application/json. This method is similar to the `downloadAttachment` method but allows some clients to get around issues with binary responses.
     * @summary Get email attachment as base64 encoded string as alternative to binary responses. To read the content decode the Base64 encoded contents.
     * @param {string} attachmentId ID of attachment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentControllerApi
     */
    public downloadAttachmentAsBase64Encoded(
        attachmentId: string,
        options?: any
    ) {
        return AttachmentControllerApiFp(
            this.configuration
        ).downloadAttachmentAsBase64Encoded(attachmentId, options)(
            this.fetch,
            this.basePath
        );
    }

    /**
     * Returns the specified attachment for a given email as a stream / array of bytes. You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
     * @summary Download attachments. Get email attachment bytes. If you have trouble with byte responses try the `downloadAttachmentBase64` response endpoints.
     * @param {string} attachmentId ID of attachment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentControllerApi
     */
    public downloadAttachmentAsBytes(attachmentId: string, options?: any) {
        return AttachmentControllerApiFp(
            this.configuration
        ).downloadAttachmentAsBytes(attachmentId, options)(
            this.fetch,
            this.basePath
        );
    }

    /**
     * Returns the metadata for an attachment. It is saved separately to the content of the attachment. Contains properties `name` and `content-type` and `content-length` in bytes for a given attachment.
     * @summary Get email attachment metadata information
     * @param {string} attachmentId ID of attachment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentControllerApi
     */
    public getAttachmentInfo(attachmentId: string, options?: any) {
        return AttachmentControllerApiFp(this.configuration).getAttachmentInfo(
            attachmentId,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Get all attachments in paginated response. Each entity contains meta data for the attachment such as `name` and `content-type`. Use the `attachmentId` and the download endpoints to get the file contents.
     * @summary Get email attachments
     * @param {string} [fileNameFilter] Optional file name and content type search filter
     * @param {number} [page] Optional page index event list pagination
     * @param {number} [size] Optional page size event list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentControllerApi
     */
    public getAttachments(
        fileNameFilter?: string,
        page?: number,
        size?: number,
        sort?: 'ASC' | 'DESC',
        options?: any
    ) {
        return AttachmentControllerApiFp(this.configuration).getAttachments(
            fileNameFilter,
            page,
            size,
            sort,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Email attachments are essentially files with meta data. Files are byte arrays and the meta data is a content type and a filename. These properties allow email clients to display the filename and icon etc. When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment ID and use it with subsequent email sending. For legacy reasons the ID is returned as the first element in an array. Only a single ID is ever returned. To send the attachments pass a list of attachment IDs with `SendEmailOptions` when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
     * @summary Upload an attachment for sending using base64 file encoding. Returns an array whose first element is the ID of the uploaded attachment.
     * @param {UploadAttachmentOptions} uploadOptions uploadOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentControllerApi
     */
    public uploadAttachment(
        uploadOptions: UploadAttachmentOptions,
        options?: any
    ) {
        return AttachmentControllerApiFp(this.configuration).uploadAttachment(
            uploadOptions,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Email attachments are essentially files with meta data. Files are byte arrays and the meta data is a content type and a filename. These properties allow email clients to display the filename and icon etc. When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment ID and use it with subsequent email sending. For legacy reasons the ID is returned as the first element in an array. Only a single ID is ever returned. To send the attachments pass a list of attachment IDs with `SendEmailOptions` when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
     * @summary Upload an attachment for sending using file byte stream input octet stream. Returns an array whose first element is the ID of the uploaded attachment.
     * @param {string} [string] Optional contentType for file. For instance &#x60;application/pdf&#x60;
     * @param {string} [byteArray] Byte array request body
     * @param {string} [filename] Optional filename to save upload with
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentControllerApi
     */
    public uploadAttachmentBytes(
        string?: string,
        byteArray?: string,
        filename?: string,
        options?: any
    ) {
        return AttachmentControllerApiFp(
            this.configuration
        ).uploadAttachmentBytes(string, byteArray, filename, options)(
            this.fetch,
            this.basePath
        );
    }

    /**
     * Email attachments are essentially files with meta data. Files are byte arrays and the meta data is a content type and a filename. These properties allow email clients to display the filename and icon etc. When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment ID and use it with subsequent email sending. For legacy reasons the ID is returned as the first element in an array. Only a single ID is ever returned. To send the attachments pass a list of attachment IDs with `SendEmailOptions` when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
     * @summary Upload an attachment for sending using a Multipart Form request. Returns an array whose first element is the ID of the uploaded attachment.
     * @param {any} file file
     * @param {string} [contentType] Optional content type of attachment
     * @param {string} [contentTypeHeader] Optional content type header of attachment
     * @param {string} [filename] Optional name of file
     * @param {string} [xFilename] Optional content type header of attachment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentControllerApi
     */
    public uploadMultipartForm(
        file: any,
        contentType?: string,
        contentTypeHeader?: string,
        filename?: string,
        xFilename?: string,
        options?: any
    ) {
        return AttachmentControllerApiFp(
            this.configuration
        ).uploadMultipartForm(
            file,
            contentType,
            contentTypeHeader,
            filename,
            xFilename,
            options
        )(this.fetch, this.basePath);
    }
}

/**
 * BulkActionsControllerApi - fetch parameter creator
 * @export
 */
export const BulkActionsControllerApiFetchParamCreator = function(
    configuration?: Configuration
) {
    return {
        /**
         *
         * @summary Bulk create Inboxes (email addresses)
         * @param {number} count Number of inboxes to be created in bulk
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkCreateInboxes(count: number, options: any = {}): FetchArgs {
            // verify required parameter 'count' is not null or undefined
            if (count === null || count === undefined) {
                throw new RequiredError(
                    'count',
                    'Required parameter count was null or undefined when calling bulkCreateInboxes.'
                );
            }
            const localVarPath = `/bulk/inboxes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Bulk Delete Inboxes
         * @param {Array<string>} ids ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkDeleteInboxes(ids: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'ids' is not null or undefined
            if (ids === null || ids === undefined) {
                throw new RequiredError(
                    'ids',
                    'Required parameter ids was null or undefined when calling bulkDeleteInboxes.'
                );
            }
            const localVarPath = `/bulk/inboxes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'DELETE' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'Array&lt;string&gt;' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(ids || {})
                : ids || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Bulk Send Emails
         * @param {BulkSendEmailOptions} bulkSendEmailOptions bulkSendEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkSendEmails(
            bulkSendEmailOptions: BulkSendEmailOptions,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'bulkSendEmailOptions' is not null or undefined
            if (
                bulkSendEmailOptions === null ||
                bulkSendEmailOptions === undefined
            ) {
                throw new RequiredError(
                    'bulkSendEmailOptions',
                    'Required parameter bulkSendEmailOptions was null or undefined when calling bulkSendEmails.'
                );
            }
            const localVarPath = `/bulk/send`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'BulkSendEmailOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(bulkSendEmailOptions || {})
                : bulkSendEmailOptions || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * BulkActionsControllerApi - functional programming interface
 * @export
 */
export const BulkActionsControllerApiFp = function(
    configuration?: Configuration
) {
    return {
        /**
         *
         * @summary Bulk create Inboxes (email addresses)
         * @param {number} count Number of inboxes to be created in bulk
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkCreateInboxes(
            count: number,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Inbox>> {
            const localVarFetchArgs = BulkActionsControllerApiFetchParamCreator(
                configuration
            ).bulkCreateInboxes(count, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Bulk Delete Inboxes
         * @param {Array<string>} ids ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkDeleteInboxes(
            ids: Array<string>,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BulkActionsControllerApiFetchParamCreator(
                configuration
            ).bulkDeleteInboxes(ids, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Bulk Send Emails
         * @param {BulkSendEmailOptions} bulkSendEmailOptions bulkSendEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkSendEmails(
            bulkSendEmailOptions: BulkSendEmailOptions,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = BulkActionsControllerApiFetchParamCreator(
                configuration
            ).bulkSendEmails(bulkSendEmailOptions, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    };
};

/**
 * BulkActionsControllerApi - factory interface
 * @export
 */
export const BulkActionsControllerApiFactory = function(
    configuration?: Configuration,
    fetch?: FetchAPI,
    basePath?: string
) {
    return {
        /**
         *
         * @summary Bulk create Inboxes (email addresses)
         * @param {number} count Number of inboxes to be created in bulk
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkCreateInboxes(count: number, options?: any) {
            return BulkActionsControllerApiFp(configuration).bulkCreateInboxes(
                count,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Bulk Delete Inboxes
         * @param {Array<string>} ids ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkDeleteInboxes(ids: Array<string>, options?: any) {
            return BulkActionsControllerApiFp(configuration).bulkDeleteInboxes(
                ids,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Bulk Send Emails
         * @param {BulkSendEmailOptions} bulkSendEmailOptions bulkSendEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkSendEmails(
            bulkSendEmailOptions: BulkSendEmailOptions,
            options?: any
        ) {
            return BulkActionsControllerApiFp(configuration).bulkSendEmails(
                bulkSendEmailOptions,
                options
            )(fetch, basePath);
        },
    };
};

/**
 * BulkActionsControllerApi - object-oriented interface
 * @export
 * @class BulkActionsControllerApi
 * @extends {BaseAPI}
 */
export class BulkActionsControllerApi extends BaseAPI {
    /**
     *
     * @summary Bulk create Inboxes (email addresses)
     * @param {number} count Number of inboxes to be created in bulk
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BulkActionsControllerApi
     */
    public bulkCreateInboxes(count: number, options?: any) {
        return BulkActionsControllerApiFp(this.configuration).bulkCreateInboxes(
            count,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Bulk Delete Inboxes
     * @param {Array<string>} ids ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BulkActionsControllerApi
     */
    public bulkDeleteInboxes(ids: Array<string>, options?: any) {
        return BulkActionsControllerApiFp(this.configuration).bulkDeleteInboxes(
            ids,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Bulk Send Emails
     * @param {BulkSendEmailOptions} bulkSendEmailOptions bulkSendEmailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BulkActionsControllerApi
     */
    public bulkSendEmails(
        bulkSendEmailOptions: BulkSendEmailOptions,
        options?: any
    ) {
        return BulkActionsControllerApiFp(this.configuration).bulkSendEmails(
            bulkSendEmailOptions,
            options
        )(this.fetch, this.basePath);
    }
}

/**
 * CommonActionsControllerApi - fetch parameter creator
 * @export
 */
export const CommonActionsControllerApiFetchParamCreator = function(
    configuration?: Configuration
) {
    return {
        /**
         * Returns an Inbox with an `id` and an `emailAddress`
         * @summary Create new random inbox
         * @param {boolean} [allowTeamAccess] allowTeamAccess
         * @param {Date} [expiresAt] expiresAt
         * @param {number} [expiresIn] expiresIn
         * @param {boolean} [useDomainPool] useDomainPool
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewEmailAddress(
            allowTeamAccess?: boolean,
            expiresAt?: Date,
            expiresIn?: number,
            useDomainPool?: boolean,
            options: any = {}
        ): FetchArgs {
            const localVarPath = `/createInbox`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (allowTeamAccess !== undefined) {
                localVarQueryParameter['allowTeamAccess'] = allowTeamAccess;
            }

            if (expiresAt !== undefined) {
                localVarQueryParameter[
                    'expiresAt'
                ] = (expiresAt as any).toISOString();
            }

            if (expiresIn !== undefined) {
                localVarQueryParameter['expiresIn'] = expiresIn;
            }

            if (useDomainPool !== undefined) {
                localVarQueryParameter['useDomainPool'] = useDomainPool;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an Inbox with an `id` and an `emailAddress`
         * @summary Create new random inbox
         * @param {boolean} [allowTeamAccess] allowTeamAccess
         * @param {Date} [expiresAt] expiresAt
         * @param {number} [expiresIn] expiresIn
         * @param {boolean} [useDomainPool] useDomainPool
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewEmailAddress1(
            allowTeamAccess?: boolean,
            expiresAt?: Date,
            expiresIn?: number,
            useDomainPool?: boolean,
            options: any = {}
        ): FetchArgs {
            const localVarPath = `/newEmailAddress`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (allowTeamAccess !== undefined) {
                localVarQueryParameter['allowTeamAccess'] = allowTeamAccess;
            }

            if (expiresAt !== undefined) {
                localVarQueryParameter[
                    'expiresAt'
                ] = (expiresAt as any).toISOString();
            }

            if (expiresIn !== undefined) {
                localVarQueryParameter['expiresIn'] = expiresIn;
            }

            if (useDomainPool !== undefined) {
                localVarQueryParameter['useDomainPool'] = useDomainPool;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes all emails
         * @summary Delete all emails in an inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emptyInbox(inboxId: string, options: any = {}): FetchArgs {
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError(
                    'inboxId',
                    'Required parameter inboxId was null or undefined when calling emptyInbox.'
                );
            }
            const localVarPath = `/emptyInbox`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'DELETE' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (inboxId !== undefined) {
                localVarQueryParameter['inboxId'] = inboxId;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If no senderId or inboxId provided a random email address will be used to send from.
         * @summary Send an email
         * @param {SimpleSendEmailOptions} emailOptions emailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailSimple(
            emailOptions: SimpleSendEmailOptions,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'emailOptions' is not null or undefined
            if (emailOptions === null || emailOptions === undefined) {
                throw new RequiredError(
                    'emailOptions',
                    'Required parameter emailOptions was null or undefined when calling sendEmailSimple.'
                );
            }
            const localVarPath = `/sendEmail`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'SimpleSendEmailOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(emailOptions || {})
                : emailOptions || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * CommonActionsControllerApi - functional programming interface
 * @export
 */
export const CommonActionsControllerApiFp = function(
    configuration?: Configuration
) {
    return {
        /**
         * Returns an Inbox with an `id` and an `emailAddress`
         * @summary Create new random inbox
         * @param {boolean} [allowTeamAccess] allowTeamAccess
         * @param {Date} [expiresAt] expiresAt
         * @param {number} [expiresIn] expiresIn
         * @param {boolean} [useDomainPool] useDomainPool
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewEmailAddress(
            allowTeamAccess?: boolean,
            expiresAt?: Date,
            expiresIn?: number,
            useDomainPool?: boolean,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Inbox> {
            const localVarFetchArgs = CommonActionsControllerApiFetchParamCreator(
                configuration
            ).createNewEmailAddress(
                allowTeamAccess,
                expiresAt,
                expiresIn,
                useDomainPool,
                options
            );
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns an Inbox with an `id` and an `emailAddress`
         * @summary Create new random inbox
         * @param {boolean} [allowTeamAccess] allowTeamAccess
         * @param {Date} [expiresAt] expiresAt
         * @param {number} [expiresIn] expiresIn
         * @param {boolean} [useDomainPool] useDomainPool
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewEmailAddress1(
            allowTeamAccess?: boolean,
            expiresAt?: Date,
            expiresIn?: number,
            useDomainPool?: boolean,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Inbox> {
            const localVarFetchArgs = CommonActionsControllerApiFetchParamCreator(
                configuration
            ).createNewEmailAddress1(
                allowTeamAccess,
                expiresAt,
                expiresIn,
                useDomainPool,
                options
            );
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes all emails
         * @summary Delete all emails in an inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emptyInbox(
            inboxId: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CommonActionsControllerApiFetchParamCreator(
                configuration
            ).emptyInbox(inboxId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * If no senderId or inboxId provided a random email address will be used to send from.
         * @summary Send an email
         * @param {SimpleSendEmailOptions} emailOptions emailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailSimple(
            emailOptions: SimpleSendEmailOptions,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CommonActionsControllerApiFetchParamCreator(
                configuration
            ).sendEmailSimple(emailOptions, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    };
};

/**
 * CommonActionsControllerApi - factory interface
 * @export
 */
export const CommonActionsControllerApiFactory = function(
    configuration?: Configuration,
    fetch?: FetchAPI,
    basePath?: string
) {
    return {
        /**
         * Returns an Inbox with an `id` and an `emailAddress`
         * @summary Create new random inbox
         * @param {boolean} [allowTeamAccess] allowTeamAccess
         * @param {Date} [expiresAt] expiresAt
         * @param {number} [expiresIn] expiresIn
         * @param {boolean} [useDomainPool] useDomainPool
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewEmailAddress(
            allowTeamAccess?: boolean,
            expiresAt?: Date,
            expiresIn?: number,
            useDomainPool?: boolean,
            options?: any
        ) {
            return CommonActionsControllerApiFp(
                configuration
            ).createNewEmailAddress(
                allowTeamAccess,
                expiresAt,
                expiresIn,
                useDomainPool,
                options
            )(fetch, basePath);
        },
        /**
         * Returns an Inbox with an `id` and an `emailAddress`
         * @summary Create new random inbox
         * @param {boolean} [allowTeamAccess] allowTeamAccess
         * @param {Date} [expiresAt] expiresAt
         * @param {number} [expiresIn] expiresIn
         * @param {boolean} [useDomainPool] useDomainPool
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewEmailAddress1(
            allowTeamAccess?: boolean,
            expiresAt?: Date,
            expiresIn?: number,
            useDomainPool?: boolean,
            options?: any
        ) {
            return CommonActionsControllerApiFp(
                configuration
            ).createNewEmailAddress1(
                allowTeamAccess,
                expiresAt,
                expiresIn,
                useDomainPool,
                options
            )(fetch, basePath);
        },
        /**
         * Deletes all emails
         * @summary Delete all emails in an inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emptyInbox(inboxId: string, options?: any) {
            return CommonActionsControllerApiFp(configuration).emptyInbox(
                inboxId,
                options
            )(fetch, basePath);
        },
        /**
         * If no senderId or inboxId provided a random email address will be used to send from.
         * @summary Send an email
         * @param {SimpleSendEmailOptions} emailOptions emailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailSimple(emailOptions: SimpleSendEmailOptions, options?: any) {
            return CommonActionsControllerApiFp(configuration).sendEmailSimple(
                emailOptions,
                options
            )(fetch, basePath);
        },
    };
};

/**
 * CommonActionsControllerApi - object-oriented interface
 * @export
 * @class CommonActionsControllerApi
 * @extends {BaseAPI}
 */
export class CommonActionsControllerApi extends BaseAPI {
    /**
     * Returns an Inbox with an `id` and an `emailAddress`
     * @summary Create new random inbox
     * @param {boolean} [allowTeamAccess] allowTeamAccess
     * @param {Date} [expiresAt] expiresAt
     * @param {number} [expiresIn] expiresIn
     * @param {boolean} [useDomainPool] useDomainPool
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonActionsControllerApi
     */
    public createNewEmailAddress(
        allowTeamAccess?: boolean,
        expiresAt?: Date,
        expiresIn?: number,
        useDomainPool?: boolean,
        options?: any
    ) {
        return CommonActionsControllerApiFp(
            this.configuration
        ).createNewEmailAddress(
            allowTeamAccess,
            expiresAt,
            expiresIn,
            useDomainPool,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Returns an Inbox with an `id` and an `emailAddress`
     * @summary Create new random inbox
     * @param {boolean} [allowTeamAccess] allowTeamAccess
     * @param {Date} [expiresAt] expiresAt
     * @param {number} [expiresIn] expiresIn
     * @param {boolean} [useDomainPool] useDomainPool
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonActionsControllerApi
     */
    public createNewEmailAddress1(
        allowTeamAccess?: boolean,
        expiresAt?: Date,
        expiresIn?: number,
        useDomainPool?: boolean,
        options?: any
    ) {
        return CommonActionsControllerApiFp(
            this.configuration
        ).createNewEmailAddress1(
            allowTeamAccess,
            expiresAt,
            expiresIn,
            useDomainPool,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Deletes all emails
     * @summary Delete all emails in an inbox
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonActionsControllerApi
     */
    public emptyInbox(inboxId: string, options?: any) {
        return CommonActionsControllerApiFp(this.configuration).emptyInbox(
            inboxId,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * If no senderId or inboxId provided a random email address will be used to send from.
     * @summary Send an email
     * @param {SimpleSendEmailOptions} emailOptions emailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommonActionsControllerApi
     */
    public sendEmailSimple(
        emailOptions: SimpleSendEmailOptions,
        options?: any
    ) {
        return CommonActionsControllerApiFp(this.configuration).sendEmailSimple(
            emailOptions,
            options
        )(this.fetch, this.basePath);
    }
}

/**
 * ContactControllerApi - fetch parameter creator
 * @export
 */
export const ContactControllerApiFetchParamCreator = function(
    configuration?: Configuration
) {
    return {
        /**
         *
         * @summary Create a contact
         * @param {CreateContactOptions} createContactOptions createContactOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContact(
            createContactOptions: CreateContactOptions,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'createContactOptions' is not null or undefined
            if (
                createContactOptions === null ||
                createContactOptions === undefined
            ) {
                throw new RequiredError(
                    'createContactOptions',
                    'Required parameter createContactOptions was null or undefined when calling createContact.'
                );
            }
            const localVarPath = `/contacts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'CreateContactOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(createContactOptions || {})
                : createContactOptions || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete contact
         * @param {string} contactId contactId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContact(contactId: string, options: any = {}): FetchArgs {
            // verify required parameter 'contactId' is not null or undefined
            if (contactId === null || contactId === undefined) {
                throw new RequiredError(
                    'contactId',
                    'Required parameter contactId was null or undefined when calling deleteContact.'
                );
            }
            const localVarPath = `/contacts/{contactId}`.replace(
                `{${'contactId'}}`,
                encodeURIComponent(String(contactId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'DELETE' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all contacts
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllContacts(
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options: any = {}
        ): FetchArgs {
            const localVarPath = `/contacts/paginated`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get contact
         * @param {string} contactId contactId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContact(contactId: string, options: any = {}): FetchArgs {
            // verify required parameter 'contactId' is not null or undefined
            if (contactId === null || contactId === undefined) {
                throw new RequiredError(
                    'contactId',
                    'Required parameter contactId was null or undefined when calling getContact.'
                );
            }
            const localVarPath = `/contacts/{contactId}`.replace(
                `{${'contactId'}}`,
                encodeURIComponent(String(contactId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get contact vCard vcf file
         * @param {string} contactId contactId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactVCard(contactId: string, options: any = {}): FetchArgs {
            // verify required parameter 'contactId' is not null or undefined
            if (contactId === null || contactId === undefined) {
                throw new RequiredError(
                    'contactId',
                    'Required parameter contactId was null or undefined when calling getContactVCard.'
                );
            }
            const localVarPath = `/contacts/{contactId}/download`.replace(
                `{${'contactId'}}`,
                encodeURIComponent(String(contactId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all contacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContacts(options: any = {}): FetchArgs {
            const localVarPath = `/contacts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * ContactControllerApi - functional programming interface
 * @export
 */
export const ContactControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a contact
         * @param {CreateContactOptions} createContactOptions createContactOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContact(
            createContactOptions: CreateContactOptions,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<ContactDto> {
            const localVarFetchArgs = ContactControllerApiFetchParamCreator(
                configuration
            ).createContact(createContactOptions, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete contact
         * @param {string} contactId contactId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContact(
            contactId: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ContactControllerApiFetchParamCreator(
                configuration
            ).deleteContact(contactId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all contacts
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllContacts(
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<PageContactProjection> {
            const localVarFetchArgs = ContactControllerApiFetchParamCreator(
                configuration
            ).getAllContacts(page, size, sort, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get contact
         * @param {string} contactId contactId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContact(
            contactId: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<ContactDto> {
            const localVarFetchArgs = ContactControllerApiFetchParamCreator(
                configuration
            ).getContact(contactId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get contact vCard vcf file
         * @param {string} contactId contactId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactVCard(
            contactId: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = ContactControllerApiFetchParamCreator(
                configuration
            ).getContactVCard(contactId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all contacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContacts(
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<Array<ContactProjection>> {
            const localVarFetchArgs = ContactControllerApiFetchParamCreator(
                configuration
            ).getContacts(options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    };
};

/**
 * ContactControllerApi - factory interface
 * @export
 */
export const ContactControllerApiFactory = function(
    configuration?: Configuration,
    fetch?: FetchAPI,
    basePath?: string
) {
    return {
        /**
         *
         * @summary Create a contact
         * @param {CreateContactOptions} createContactOptions createContactOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContact(
            createContactOptions: CreateContactOptions,
            options?: any
        ) {
            return ContactControllerApiFp(configuration).createContact(
                createContactOptions,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Delete contact
         * @param {string} contactId contactId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContact(contactId: string, options?: any) {
            return ContactControllerApiFp(configuration).deleteContact(
                contactId,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Get all contacts
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllContacts(
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ) {
            return ContactControllerApiFp(configuration).getAllContacts(
                page,
                size,
                sort,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Get contact
         * @param {string} contactId contactId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContact(contactId: string, options?: any) {
            return ContactControllerApiFp(configuration).getContact(
                contactId,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Get contact vCard vcf file
         * @param {string} contactId contactId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactVCard(contactId: string, options?: any) {
            return ContactControllerApiFp(configuration).getContactVCard(
                contactId,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Get all contacts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContacts(options?: any) {
            return ContactControllerApiFp(configuration).getContacts(options)(
                fetch,
                basePath
            );
        },
    };
};

/**
 * ContactControllerApi - object-oriented interface
 * @export
 * @class ContactControllerApi
 * @extends {BaseAPI}
 */
export class ContactControllerApi extends BaseAPI {
    /**
     *
     * @summary Create a contact
     * @param {CreateContactOptions} createContactOptions createContactOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactControllerApi
     */
    public createContact(
        createContactOptions: CreateContactOptions,
        options?: any
    ) {
        return ContactControllerApiFp(this.configuration).createContact(
            createContactOptions,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Delete contact
     * @param {string} contactId contactId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactControllerApi
     */
    public deleteContact(contactId: string, options?: any) {
        return ContactControllerApiFp(this.configuration).deleteContact(
            contactId,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get all contacts
     * @param {number} [page] Optional page index in inbox list pagination
     * @param {number} [size] Optional page size in inbox list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactControllerApi
     */
    public getAllContacts(
        page?: number,
        size?: number,
        sort?: 'ASC' | 'DESC',
        options?: any
    ) {
        return ContactControllerApiFp(this.configuration).getAllContacts(
            page,
            size,
            sort,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get contact
     * @param {string} contactId contactId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactControllerApi
     */
    public getContact(contactId: string, options?: any) {
        return ContactControllerApiFp(this.configuration).getContact(
            contactId,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get contact vCard vcf file
     * @param {string} contactId contactId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactControllerApi
     */
    public getContactVCard(contactId: string, options?: any) {
        return ContactControllerApiFp(this.configuration).getContactVCard(
            contactId,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get all contacts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactControllerApi
     */
    public getContacts(options?: any) {
        return ContactControllerApiFp(this.configuration).getContacts(options)(
            this.fetch,
            this.basePath
        );
    }
}

/**
 * DomainControllerApi - fetch parameter creator
 * @export
 */
export const DomainControllerApiFetchParamCreator = function(
    configuration?: Configuration
) {
    return {
        /**
         * Add a catch all inbox to a domain so that any emails sent to it that cannot be matched will be sent to the catch all inbox generated
         * @summary Add catch all wild card inbox to domain
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDomainWildcardCatchAll(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError(
                    'id',
                    'Required parameter id was null or undefined when calling addDomainWildcardCatchAll.'
                );
            }
            const localVarPath = `/domains/{id}/wildcard`.replace(
                `{${'id'}}`,
                encodeURIComponent(String(id))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Link a domain that you own with MailSlurp so you can create email addresses using it. Endpoint returns DNS records used for validation. You must add these verification records to your host provider's DNS setup to verify the domain.
         * @summary Create Domain
         * @param {CreateDomainOptions} domainOptions domainOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDomain(
            domainOptions: CreateDomainOptions,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'domainOptions' is not null or undefined
            if (domainOptions === null || domainOptions === undefined) {
                throw new RequiredError(
                    'domainOptions',
                    'Required parameter domainOptions was null or undefined when calling createDomain.'
                );
            }
            const localVarPath = `/domains`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'CreateDomainOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(domainOptions || {})
                : domainOptions || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a domain. This will disable any existing inboxes that use this domain.
         * @summary Delete a domain
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDomain(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError(
                    'id',
                    'Required parameter id was null or undefined when calling deleteDomain.'
                );
            }
            const localVarPath = `/domains/{id}`.replace(
                `{${'id'}}`,
                encodeURIComponent(String(id))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'DELETE' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns domain verification status and tokens for a given domain
         * @summary Get a domain
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomain(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError(
                    'id',
                    'Required parameter id was null or undefined when calling getDomain.'
                );
            }
            const localVarPath = `/domains/{id}`.replace(
                `{${'id'}}`,
                encodeURIComponent(String(id))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all custom domains you have created
         * @summary Get domains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomains(options: any = {}): FetchArgs {
            const localVarPath = `/domains`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update values on a domain. Note you cannot change the domain name as it is immutable. Recreate the domain if you need to alter this.
         * @summary Update a domain
         * @param {string} id id
         * @param {UpdateDomainOptions} updateDomainDto updateDomainDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomain(
            id: string,
            updateDomainDto: UpdateDomainOptions,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError(
                    'id',
                    'Required parameter id was null or undefined when calling updateDomain.'
                );
            }
            // verify required parameter 'updateDomainDto' is not null or undefined
            if (updateDomainDto === null || updateDomainDto === undefined) {
                throw new RequiredError(
                    'updateDomainDto',
                    'Required parameter updateDomainDto was null or undefined when calling updateDomain.'
                );
            }
            const localVarPath = `/domains/{id}`.replace(
                `{${'id'}}`,
                encodeURIComponent(String(id))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'PUT' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'UpdateDomainOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(updateDomainDto || {})
                : updateDomainDto || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * DomainControllerApi - functional programming interface
 * @export
 */
export const DomainControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Add a catch all inbox to a domain so that any emails sent to it that cannot be matched will be sent to the catch all inbox generated
         * @summary Add catch all wild card inbox to domain
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDomainWildcardCatchAll(
            id: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<DomainDto> {
            const localVarFetchArgs = DomainControllerApiFetchParamCreator(
                configuration
            ).addDomainWildcardCatchAll(id, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Link a domain that you own with MailSlurp so you can create email addresses using it. Endpoint returns DNS records used for validation. You must add these verification records to your host provider's DNS setup to verify the domain.
         * @summary Create Domain
         * @param {CreateDomainOptions} domainOptions domainOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDomain(
            domainOptions: CreateDomainOptions,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<DomainDto> {
            const localVarFetchArgs = DomainControllerApiFetchParamCreator(
                configuration
            ).createDomain(domainOptions, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a domain. This will disable any existing inboxes that use this domain.
         * @summary Delete a domain
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDomain(
            id: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = DomainControllerApiFetchParamCreator(
                configuration
            ).deleteDomain(id, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns domain verification status and tokens for a given domain
         * @summary Get a domain
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomain(
            id: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<DomainDto> {
            const localVarFetchArgs = DomainControllerApiFetchParamCreator(
                configuration
            ).getDomain(id, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List all custom domains you have created
         * @summary Get domains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomains(
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<Array<DomainPreview>> {
            const localVarFetchArgs = DomainControllerApiFetchParamCreator(
                configuration
            ).getDomains(options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update values on a domain. Note you cannot change the domain name as it is immutable. Recreate the domain if you need to alter this.
         * @summary Update a domain
         * @param {string} id id
         * @param {UpdateDomainOptions} updateDomainDto updateDomainDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomain(
            id: string,
            updateDomainDto: UpdateDomainOptions,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<DomainDto> {
            const localVarFetchArgs = DomainControllerApiFetchParamCreator(
                configuration
            ).updateDomain(id, updateDomainDto, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    };
};

/**
 * DomainControllerApi - factory interface
 * @export
 */
export const DomainControllerApiFactory = function(
    configuration?: Configuration,
    fetch?: FetchAPI,
    basePath?: string
) {
    return {
        /**
         * Add a catch all inbox to a domain so that any emails sent to it that cannot be matched will be sent to the catch all inbox generated
         * @summary Add catch all wild card inbox to domain
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDomainWildcardCatchAll(id: string, options?: any) {
            return DomainControllerApiFp(
                configuration
            ).addDomainWildcardCatchAll(id, options)(fetch, basePath);
        },
        /**
         * Link a domain that you own with MailSlurp so you can create email addresses using it. Endpoint returns DNS records used for validation. You must add these verification records to your host provider's DNS setup to verify the domain.
         * @summary Create Domain
         * @param {CreateDomainOptions} domainOptions domainOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDomain(domainOptions: CreateDomainOptions, options?: any) {
            return DomainControllerApiFp(configuration).createDomain(
                domainOptions,
                options
            )(fetch, basePath);
        },
        /**
         * Delete a domain. This will disable any existing inboxes that use this domain.
         * @summary Delete a domain
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDomain(id: string, options?: any) {
            return DomainControllerApiFp(configuration).deleteDomain(
                id,
                options
            )(fetch, basePath);
        },
        /**
         * Returns domain verification status and tokens for a given domain
         * @summary Get a domain
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomain(id: string, options?: any) {
            return DomainControllerApiFp(configuration).getDomain(id, options)(
                fetch,
                basePath
            );
        },
        /**
         * List all custom domains you have created
         * @summary Get domains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDomains(options?: any) {
            return DomainControllerApiFp(configuration).getDomains(options)(
                fetch,
                basePath
            );
        },
        /**
         * Update values on a domain. Note you cannot change the domain name as it is immutable. Recreate the domain if you need to alter this.
         * @summary Update a domain
         * @param {string} id id
         * @param {UpdateDomainOptions} updateDomainDto updateDomainDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDomain(
            id: string,
            updateDomainDto: UpdateDomainOptions,
            options?: any
        ) {
            return DomainControllerApiFp(configuration).updateDomain(
                id,
                updateDomainDto,
                options
            )(fetch, basePath);
        },
    };
};

/**
 * DomainControllerApi - object-oriented interface
 * @export
 * @class DomainControllerApi
 * @extends {BaseAPI}
 */
export class DomainControllerApi extends BaseAPI {
    /**
     * Add a catch all inbox to a domain so that any emails sent to it that cannot be matched will be sent to the catch all inbox generated
     * @summary Add catch all wild card inbox to domain
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainControllerApi
     */
    public addDomainWildcardCatchAll(id: string, options?: any) {
        return DomainControllerApiFp(
            this.configuration
        ).addDomainWildcardCatchAll(id, options)(this.fetch, this.basePath);
    }

    /**
     * Link a domain that you own with MailSlurp so you can create email addresses using it. Endpoint returns DNS records used for validation. You must add these verification records to your host provider's DNS setup to verify the domain.
     * @summary Create Domain
     * @param {CreateDomainOptions} domainOptions domainOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainControllerApi
     */
    public createDomain(domainOptions: CreateDomainOptions, options?: any) {
        return DomainControllerApiFp(this.configuration).createDomain(
            domainOptions,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Delete a domain. This will disable any existing inboxes that use this domain.
     * @summary Delete a domain
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainControllerApi
     */
    public deleteDomain(id: string, options?: any) {
        return DomainControllerApiFp(this.configuration).deleteDomain(
            id,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Returns domain verification status and tokens for a given domain
     * @summary Get a domain
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainControllerApi
     */
    public getDomain(id: string, options?: any) {
        return DomainControllerApiFp(this.configuration).getDomain(id, options)(
            this.fetch,
            this.basePath
        );
    }

    /**
     * List all custom domains you have created
     * @summary Get domains
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainControllerApi
     */
    public getDomains(options?: any) {
        return DomainControllerApiFp(this.configuration).getDomains(options)(
            this.fetch,
            this.basePath
        );
    }

    /**
     * Update values on a domain. Note you cannot change the domain name as it is immutable. Recreate the domain if you need to alter this.
     * @summary Update a domain
     * @param {string} id id
     * @param {UpdateDomainOptions} updateDomainDto updateDomainDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainControllerApi
     */
    public updateDomain(
        id: string,
        updateDomainDto: UpdateDomainOptions,
        options?: any
    ) {
        return DomainControllerApiFp(this.configuration).updateDomain(
            id,
            updateDomainDto,
            options
        )(this.fetch, this.basePath);
    }
}

/**
 * EmailControllerApi - fetch parameter creator
 * @export
 */
export const EmailControllerApiFetchParamCreator = function(
    configuration?: Configuration
) {
    return {
        /**
         * Deletes all emails in your account. Be careful as emails cannot be recovered
         * @summary Delete all emails in all inboxes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllEmails(options: any = {}): FetchArgs {
            const localVarPath = `/emails`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'DELETE' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an email and removes it from the inbox. Deleted emails cannot be recovered.
         * @summary Delete an email
         * @param {string} emailId ID of email to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmail(emailId: string, options: any = {}): FetchArgs {
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError(
                    'emailId',
                    'Required parameter emailId was null or undefined when calling deleteEmail.'
                );
            }
            const localVarPath = `/emails/{emailId}`.replace(
                `{${'emailId'}}`,
                encodeURIComponent(String(emailId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'DELETE' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified attachment for a given email as a stream / array of bytes. You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
         * @summary Get email attachment bytes. Returned as `octet-stream` with content type header. If you have trouble with byte responses try the `downloadAttachmentBase64` response endpoints and convert the base 64 encoded content to a file or string.
         * @param {string} attachmentId ID of attachment
         * @param {string} emailId ID of email
         * @param {string} [apiKey] Can pass apiKey in url for this request if you wish to download the file in a browser. Content type will be set to original content type of the attachment file. This is so that browsers can download the file correctly.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachment(
            attachmentId: string,
            emailId: string,
            apiKey?: string,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError(
                    'attachmentId',
                    'Required parameter attachmentId was null or undefined when calling downloadAttachment.'
                );
            }
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError(
                    'emailId',
                    'Required parameter emailId was null or undefined when calling downloadAttachment.'
                );
            }
            const localVarPath = `/emails/{emailId}/attachments/{attachmentId}`
                .replace(
                    `{${'attachmentId'}}`,
                    encodeURIComponent(String(attachmentId))
                )
                .replace(`{${'emailId'}}`, encodeURIComponent(String(emailId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (apiKey !== undefined) {
                localVarQueryParameter['apiKey'] = apiKey;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified attachment for a given email as a base 64 encoded string. The response type is application/json. This method is similar to the `downloadAttachment` method but allows some clients to get around issues with binary responses.
         * @summary Get email attachment as base64 encoded string as an alternative to binary responses. Decode the `base64FileContents` as a `utf-8` encoded string or array of bytes depending on the `contentType`.
         * @param {string} attachmentId ID of attachment
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachmentBase64(
            attachmentId: string,
            emailId: string,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError(
                    'attachmentId',
                    'Required parameter attachmentId was null or undefined when calling downloadAttachmentBase64.'
                );
            }
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError(
                    'emailId',
                    'Required parameter emailId was null or undefined when calling downloadAttachmentBase64.'
                );
            }
            const localVarPath = `/emails/{emailId}/attachments/{attachmentId}/base64`
                .replace(
                    `{${'attachmentId'}}`,
                    encodeURIComponent(String(attachmentId))
                )
                .replace(`{${'emailId'}}`, encodeURIComponent(String(emailId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified email body for a given email as a string
         * @summary Get email body as string. Returned as `plain/text` with content type header.
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadBody(emailId: string, options: any = {}): FetchArgs {
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError(
                    'emailId',
                    'Required parameter emailId was null or undefined when calling downloadBody.'
                );
            }
            const localVarPath = `/emails/{emailId}/body`.replace(
                `{${'emailId'}}`,
                encodeURIComponent(String(emailId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified email body for a given email as a stream / array of bytes.
         * @summary Get email body in bytes. Returned as `octet-stream` with content type header.
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadBodyBytes(emailId: string, options: any = {}): FetchArgs {
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError(
                    'emailId',
                    'Required parameter emailId was null or undefined when calling downloadBodyBytes.'
                );
            }
            const localVarPath = `/emails/{emailId}/body-bytes`.replace(
                `{${'emailId'}}`,
                encodeURIComponent(String(emailId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Forward an existing email to new recipients. The sender of the email will be the inbox that received the email you are forwarding. You can override the sender with the `from` option. Note you must have access to the from address in MailSlurp to use the override. For more control consider fetching the email and sending it a new using the send email endpoints.
         * @summary Forward email to recipients
         * @param {string} emailId ID of email
         * @param {ForwardEmailOptions} forwardEmailOptions forwardEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forwardEmail(
            emailId: string,
            forwardEmailOptions: ForwardEmailOptions,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError(
                    'emailId',
                    'Required parameter emailId was null or undefined when calling forwardEmail.'
                );
            }
            // verify required parameter 'forwardEmailOptions' is not null or undefined
            if (
                forwardEmailOptions === null ||
                forwardEmailOptions === undefined
            ) {
                throw new RequiredError(
                    'forwardEmailOptions',
                    'Required parameter forwardEmailOptions was null or undefined when calling forwardEmail.'
                );
            }
            const localVarPath = `/emails/{emailId}/forward`.replace(
                `{${'emailId'}}`,
                encodeURIComponent(String(emailId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'ForwardEmailOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(forwardEmailOptions || {})
                : forwardEmailOptions || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the metadata such as name and content-type for a given attachment and email.
         * @summary Get email attachment metadata. This is the `contentType` and `contentLength` of an attachment. To get the individual attachments  use the `downloadAttachment` methods.
         * @param {string} attachmentId ID of attachment
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachmentMetaData(
            attachmentId: string,
            emailId: string,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError(
                    'attachmentId',
                    'Required parameter attachmentId was null or undefined when calling getAttachmentMetaData.'
                );
            }
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError(
                    'emailId',
                    'Required parameter emailId was null or undefined when calling getAttachmentMetaData.'
                );
            }
            const localVarPath = `/emails/{emailId}/attachments/{attachmentId}/metadata`
                .replace(
                    `{${'attachmentId'}}`,
                    encodeURIComponent(String(attachmentId))
                )
                .replace(`{${'emailId'}}`, encodeURIComponent(String(emailId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of attachment metadata such as name and content-type for a given email if present.
         * @summary Get all email attachment metadata. Metadata includes name and size of attachments.
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachments1(emailId: string, options: any = {}): FetchArgs {
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError(
                    'emailId',
                    'Required parameter emailId was null or undefined when calling getAttachments1.'
                );
            }
            const localVarPath = `/emails/{emailId}/attachments`.replace(
                `{${'emailId'}}`,
                encodeURIComponent(String(emailId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawEmail endpoints
         * @summary Get email content including headers and body. Expects email to exist by ID. For emails that may not have arrived yet use the WaitForController.
         * @param {string} emailId emailId
         * @param {boolean} [decode] Decode email body quoted-printable encoding to plain text. SMTP servers often encode text using quoted-printable format (for instance &#x60;&#x3D;D7&#x60;). This can be a pain for testing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmail(
            emailId: string,
            decode?: boolean,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError(
                    'emailId',
                    'Required parameter emailId was null or undefined when calling getEmail.'
                );
            }
            const localVarPath = `/emails/{emailId}`.replace(
                `{${'emailId'}}`,
                encodeURIComponent(String(emailId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (decode !== undefined) {
                localVarQueryParameter['decode'] = decode;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return the matches for a given Java style regex pattern. Do not include the typical `/` at start or end of regex in some languages. Given an example `your code is: 12345` the pattern to extract match looks like `code is: (\\d{6})`. This will return an array of matches with the first matching the entire pattern and the subsequent matching the groups: `['code is: 123456', '123456']` See https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html for more information of available patterns.
         * @summary Get email content regex pattern match results. Runs regex against email body and returns match groups.
         * @param {ContentMatchOptions} contentMatchOptions contentMatchOptions
         * @param {string} emailId ID of email to match against
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailContentMatch(
            contentMatchOptions: ContentMatchOptions,
            emailId: string,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'contentMatchOptions' is not null or undefined
            if (
                contentMatchOptions === null ||
                contentMatchOptions === undefined
            ) {
                throw new RequiredError(
                    'contentMatchOptions',
                    'Required parameter contentMatchOptions was null or undefined when calling getEmailContentMatch.'
                );
            }
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError(
                    'emailId',
                    'Required parameter emailId was null or undefined when calling getEmailContentMatch.'
                );
            }
            const localVarPath = `/emails/{emailId}/contentMatch`.replace(
                `{${'emailId'}}`,
                encodeURIComponent(String(emailId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'ContentMatchOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(contentMatchOptions || {})
                : contentMatchOptions || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve email content as HTML response for viewing in browsers. Decodes quoted-printable entities and converts charset to UTF-8. Pass your API KEY as a request parameter when viewing in a browser: `?apiKey=xxx`
         * @summary Get email content as HTML. For displaying emails in browser context.
         * @param {string} emailId emailId
         * @param {boolean} [decode] decode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailHTML(
            emailId: string,
            decode?: boolean,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError(
                    'emailId',
                    'Required parameter emailId was null or undefined when calling getEmailHTML.'
                );
            }
            const localVarPath = `/emails/{emailId}/html`.replace(
                `{${'emailId'}}`,
                encodeURIComponent(String(emailId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (decode !== undefined) {
                localVarQueryParameter['decode'] = decode;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Parse an email body and return the content as an array of text. HTML parsing uses JSoup which supports JQuery/CSS style selectors
         * @summary Parse and return text from an email, stripping HTML and decoding encoded characters
         * @param {string} emailId ID of email to perform HTML query on
         * @param {string} [htmlSelector] HTML selector to search for. Uses JQuery/JSoup/CSS style selector like &#39;.my-div&#39; to match content. See https://jsoup.org/apidocs/org/jsoup/select/Selector.html for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailHTMLQuery(
            emailId: string,
            htmlSelector?: string,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError(
                    'emailId',
                    'Required parameter emailId was null or undefined when calling getEmailHTMLQuery.'
                );
            }
            const localVarPath = `/emails/{emailId}/htmlQuery`.replace(
                `{${'emailId'}}`,
                encodeURIComponent(String(emailId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (htmlSelector !== undefined) {
                localVarQueryParameter['htmlSelector'] = htmlSelector;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Parse an email body and return the content as an array of strings. HTML parsing uses JSoup and UNIX line separators.
         * @summary Parse and return text from an email, stripping HTML and decoding encoded characters
         * @param {string} emailId ID of email to fetch text for
         * @param {boolean} [decodeHtmlEntities] Decode HTML entities
         * @param {string} [lineSeparator] Line separator character
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailTextLines(
            emailId: string,
            decodeHtmlEntities?: boolean,
            lineSeparator?: string,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError(
                    'emailId',
                    'Required parameter emailId was null or undefined when calling getEmailTextLines.'
                );
            }
            const localVarPath = `/emails/{emailId}/textLines`.replace(
                `{${'emailId'}}`,
                encodeURIComponent(String(emailId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (decodeHtmlEntities !== undefined) {
                localVarQueryParameter[
                    'decodeHtmlEntities'
                ] = decodeHtmlEntities;
            }

            if (lineSeparator !== undefined) {
                localVarQueryParameter['lineSeparator'] = lineSeparator;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
         * @summary Get all emails in all inboxes in paginated form. Email API list all.
         * @param {Array<string>} [inboxId] Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account.
         * @param {number} [page] Optional page index in email list pagination
         * @param {number} [size] Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {boolean} [unreadOnly] Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailsPaginated(
            inboxId?: Array<string>,
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            unreadOnly?: boolean,
            options: any = {}
        ): FetchArgs {
            const localVarPath = `/emails`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (inboxId) {
                localVarQueryParameter['inboxId'] = inboxId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (unreadOnly !== undefined) {
                localVarQueryParameter['unreadOnly'] = unreadOnly;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the newest email in all inboxes or in a passed set of inbox IDs
         * @summary Get latest email in all inboxes. Most recently received.
         * @param {Array<string>} [inboxIds] Optional set of inboxes to filter by. Only get the latest email from these inbox IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestEmail(inboxIds?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/emails/latest`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (inboxIds) {
                localVarQueryParameter['inboxIds'] = inboxIds;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the newest email in all inboxes or in a passed set of inbox IDs
         * @summary Get latest email in an inbox. Use `WaitForController` to get emails that may not have arrived yet.
         * @param {string} [inboxId] ID of the inbox you want to get the latest email from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestEmailInInbox(inboxId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/emails/latestIn`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (inboxId !== undefined) {
                localVarQueryParameter['inboxId'] = inboxId;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * By default returns all emails across all team inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
         * @summary Get all organization emails. List team or shared test email accounts
         * @param {Array<string>} [inboxId] Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account.
         * @param {number} [page] Optional page index in email list pagination
         * @param {number} [size] Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {boolean} [unreadOnly] Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationEmailsPaginated(
            inboxId?: Array<string>,
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            unreadOnly?: boolean,
            options: any = {}
        ): FetchArgs {
            const localVarPath = `/emails/organization`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (inboxId) {
                localVarQueryParameter['inboxId'] = inboxId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (unreadOnly !== undefined) {
                localVarQueryParameter['unreadOnly'] = unreadOnly;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a raw, unparsed, and unprocessed email. If your client has issues processing the response it is likely due to the response content-type which is text/plain. If you need a JSON response content-type use the getRawEmailJson endpoint
         * @summary Get raw email string. Returns unparsed raw SMTP message with headers and body.
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawEmailContents(emailId: string, options: any = {}): FetchArgs {
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError(
                    'emailId',
                    'Required parameter emailId was null or undefined when calling getRawEmailContents.'
                );
            }
            const localVarPath = `/emails/{emailId}/raw`.replace(
                `{${'emailId'}}`,
                encodeURIComponent(String(emailId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a raw, unparsed, and unprocessed email wrapped in a JSON response object for easier handling when compared with the getRawEmail text/plain response
         * @summary Get raw email in JSON. Unparsed SMTP message in JSON wrapper format.
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawEmailJson(emailId: string, options: any = {}): FetchArgs {
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError(
                    'emailId',
                    'Required parameter emailId was null or undefined when calling getRawEmailJson.'
                );
            }
            const localVarPath = `/emails/{emailId}/raw/json`.replace(
                `{${'emailId'}}`,
                encodeURIComponent(String(emailId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get number of emails unread. Unread means has not been viewed in dashboard or returned in an email API response
         * @summary Get unread email count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnreadEmailCount(options: any = {}): FetchArgs {
            const localVarPath = `/emails/unreadCount`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send the reply to the email sender or reply-to and include same subject cc bcc etc. Reply to an email and the contents will be sent with the existing subject to the emails `to`, `cc`, and `bcc`.
         * @summary Reply to an email
         * @param {string} emailId ID of the email that should be replied to
         * @param {ReplyToEmailOptions} replyToEmailOptions replyToEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replyToEmail(
            emailId: string,
            replyToEmailOptions: ReplyToEmailOptions,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError(
                    'emailId',
                    'Required parameter emailId was null or undefined when calling replyToEmail.'
                );
            }
            // verify required parameter 'replyToEmailOptions' is not null or undefined
            if (
                replyToEmailOptions === null ||
                replyToEmailOptions === undefined
            ) {
                throw new RequiredError(
                    'replyToEmailOptions',
                    'Required parameter replyToEmailOptions was null or undefined when calling replyToEmail.'
                );
            }
            const localVarPath = `/emails/{emailId}`.replace(
                `{${'emailId'}}`,
                encodeURIComponent(String(emailId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'PUT' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'ReplyToEmailOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(replyToEmailOptions || {})
                : replyToEmailOptions || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate the HTML content of email if HTML is found. Considered valid if no HTML is present.
         * @summary Validate email HTML contents
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateEmail(emailId: string, options: any = {}): FetchArgs {
            // verify required parameter 'emailId' is not null or undefined
            if (emailId === null || emailId === undefined) {
                throw new RequiredError(
                    'emailId',
                    'Required parameter emailId was null or undefined when calling validateEmail.'
                );
            }
            const localVarPath = `/emails/{emailId}/validate`.replace(
                `{${'emailId'}}`,
                encodeURIComponent(String(emailId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * EmailControllerApi - functional programming interface
 * @export
 */
export const EmailControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Deletes all emails in your account. Be careful as emails cannot be recovered
         * @summary Delete all emails in all inboxes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllEmails(
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EmailControllerApiFetchParamCreator(
                configuration
            ).deleteAllEmails(options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes an email and removes it from the inbox. Deleted emails cannot be recovered.
         * @summary Delete an email
         * @param {string} emailId ID of email to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmail(
            emailId: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EmailControllerApiFetchParamCreator(
                configuration
            ).deleteEmail(emailId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the specified attachment for a given email as a stream / array of bytes. You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
         * @summary Get email attachment bytes. Returned as `octet-stream` with content type header. If you have trouble with byte responses try the `downloadAttachmentBase64` response endpoints and convert the base 64 encoded content to a file or string.
         * @param {string} attachmentId ID of attachment
         * @param {string} emailId ID of email
         * @param {string} [apiKey] Can pass apiKey in url for this request if you wish to download the file in a browser. Content type will be set to original content type of the attachment file. This is so that browsers can download the file correctly.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachment(
            attachmentId: string,
            emailId: string,
            apiKey?: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = EmailControllerApiFetchParamCreator(
                configuration
            ).downloadAttachment(attachmentId, emailId, apiKey, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the specified attachment for a given email as a base 64 encoded string. The response type is application/json. This method is similar to the `downloadAttachment` method but allows some clients to get around issues with binary responses.
         * @summary Get email attachment as base64 encoded string as an alternative to binary responses. Decode the `base64FileContents` as a `utf-8` encoded string or array of bytes depending on the `contentType`.
         * @param {string} attachmentId ID of attachment
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachmentBase64(
            attachmentId: string,
            emailId: string,
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<DownloadAttachmentDto> {
            const localVarFetchArgs = EmailControllerApiFetchParamCreator(
                configuration
            ).downloadAttachmentBase64(attachmentId, emailId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the specified email body for a given email as a string
         * @summary Get email body as string. Returned as `plain/text` with content type header.
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadBody(
            emailId: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = EmailControllerApiFetchParamCreator(
                configuration
            ).downloadBody(emailId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the specified email body for a given email as a stream / array of bytes.
         * @summary Get email body in bytes. Returned as `octet-stream` with content type header.
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadBodyBytes(
            emailId: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = EmailControllerApiFetchParamCreator(
                configuration
            ).downloadBodyBytes(emailId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Forward an existing email to new recipients. The sender of the email will be the inbox that received the email you are forwarding. You can override the sender with the `from` option. Note you must have access to the from address in MailSlurp to use the override. For more control consider fetching the email and sending it a new using the send email endpoints.
         * @summary Forward email to recipients
         * @param {string} emailId ID of email
         * @param {ForwardEmailOptions} forwardEmailOptions forwardEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forwardEmail(
            emailId: string,
            forwardEmailOptions: ForwardEmailOptions,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EmailControllerApiFetchParamCreator(
                configuration
            ).forwardEmail(emailId, forwardEmailOptions, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns the metadata such as name and content-type for a given attachment and email.
         * @summary Get email attachment metadata. This is the `contentType` and `contentLength` of an attachment. To get the individual attachments  use the `downloadAttachment` methods.
         * @param {string} attachmentId ID of attachment
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachmentMetaData(
            attachmentId: string,
            emailId: string,
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<AttachmentMetaData> {
            const localVarFetchArgs = EmailControllerApiFetchParamCreator(
                configuration
            ).getAttachmentMetaData(attachmentId, emailId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns an array of attachment metadata such as name and content-type for a given email if present.
         * @summary Get all email attachment metadata. Metadata includes name and size of attachments.
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachments1(
            emailId: string,
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<Array<AttachmentMetaData>> {
            const localVarFetchArgs = EmailControllerApiFetchParamCreator(
                configuration
            ).getAttachments1(emailId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawEmail endpoints
         * @summary Get email content including headers and body. Expects email to exist by ID. For emails that may not have arrived yet use the WaitForController.
         * @param {string} emailId emailId
         * @param {boolean} [decode] Decode email body quoted-printable encoding to plain text. SMTP servers often encode text using quoted-printable format (for instance &#x60;&#x3D;D7&#x60;). This can be a pain for testing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmail(
            emailId: string,
            decode?: boolean,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Email> {
            const localVarFetchArgs = EmailControllerApiFetchParamCreator(
                configuration
            ).getEmail(emailId, decode, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Return the matches for a given Java style regex pattern. Do not include the typical `/` at start or end of regex in some languages. Given an example `your code is: 12345` the pattern to extract match looks like `code is: (\\d{6})`. This will return an array of matches with the first matching the entire pattern and the subsequent matching the groups: `['code is: 123456', '123456']` See https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html for more information of available patterns.
         * @summary Get email content regex pattern match results. Runs regex against email body and returns match groups.
         * @param {ContentMatchOptions} contentMatchOptions contentMatchOptions
         * @param {string} emailId ID of email to match against
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailContentMatch(
            contentMatchOptions: ContentMatchOptions,
            emailId: string,
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<EmailContentMatchResult> {
            const localVarFetchArgs = EmailControllerApiFetchParamCreator(
                configuration
            ).getEmailContentMatch(contentMatchOptions, emailId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve email content as HTML response for viewing in browsers. Decodes quoted-printable entities and converts charset to UTF-8. Pass your API KEY as a request parameter when viewing in a browser: `?apiKey=xxx`
         * @summary Get email content as HTML. For displaying emails in browser context.
         * @param {string} emailId emailId
         * @param {boolean} [decode] decode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailHTML(
            emailId: string,
            decode?: boolean,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = EmailControllerApiFetchParamCreator(
                configuration
            ).getEmailHTML(emailId, decode, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Parse an email body and return the content as an array of text. HTML parsing uses JSoup which supports JQuery/CSS style selectors
         * @summary Parse and return text from an email, stripping HTML and decoding encoded characters
         * @param {string} emailId ID of email to perform HTML query on
         * @param {string} [htmlSelector] HTML selector to search for. Uses JQuery/JSoup/CSS style selector like &#39;.my-div&#39; to match content. See https://jsoup.org/apidocs/org/jsoup/select/Selector.html for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailHTMLQuery(
            emailId: string,
            htmlSelector?: string,
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<EmailTextLinesResult> {
            const localVarFetchArgs = EmailControllerApiFetchParamCreator(
                configuration
            ).getEmailHTMLQuery(emailId, htmlSelector, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Parse an email body and return the content as an array of strings. HTML parsing uses JSoup and UNIX line separators.
         * @summary Parse and return text from an email, stripping HTML and decoding encoded characters
         * @param {string} emailId ID of email to fetch text for
         * @param {boolean} [decodeHtmlEntities] Decode HTML entities
         * @param {string} [lineSeparator] Line separator character
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailTextLines(
            emailId: string,
            decodeHtmlEntities?: boolean,
            lineSeparator?: string,
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<EmailTextLinesResult> {
            const localVarFetchArgs = EmailControllerApiFetchParamCreator(
                configuration
            ).getEmailTextLines(
                emailId,
                decodeHtmlEntities,
                lineSeparator,
                options
            );
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
         * @summary Get all emails in all inboxes in paginated form. Email API list all.
         * @param {Array<string>} [inboxId] Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account.
         * @param {number} [page] Optional page index in email list pagination
         * @param {number} [size] Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {boolean} [unreadOnly] Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailsPaginated(
            inboxId?: Array<string>,
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            unreadOnly?: boolean,
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<PageEmailProjection> {
            const localVarFetchArgs = EmailControllerApiFetchParamCreator(
                configuration
            ).getEmailsPaginated(
                inboxId,
                page,
                size,
                sort,
                unreadOnly,
                options
            );
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get the newest email in all inboxes or in a passed set of inbox IDs
         * @summary Get latest email in all inboxes. Most recently received.
         * @param {Array<string>} [inboxIds] Optional set of inboxes to filter by. Only get the latest email from these inbox IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestEmail(
            inboxIds?: Array<string>,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Email> {
            const localVarFetchArgs = EmailControllerApiFetchParamCreator(
                configuration
            ).getLatestEmail(inboxIds, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get the newest email in all inboxes or in a passed set of inbox IDs
         * @summary Get latest email in an inbox. Use `WaitForController` to get emails that may not have arrived yet.
         * @param {string} [inboxId] ID of the inbox you want to get the latest email from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestEmailInInbox(
            inboxId?: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Email> {
            const localVarFetchArgs = EmailControllerApiFetchParamCreator(
                configuration
            ).getLatestEmailInInbox(inboxId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * By default returns all emails across all team inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
         * @summary Get all organization emails. List team or shared test email accounts
         * @param {Array<string>} [inboxId] Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account.
         * @param {number} [page] Optional page index in email list pagination
         * @param {number} [size] Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {boolean} [unreadOnly] Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationEmailsPaginated(
            inboxId?: Array<string>,
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            unreadOnly?: boolean,
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<PageEmailProjection> {
            const localVarFetchArgs = EmailControllerApiFetchParamCreator(
                configuration
            ).getOrganizationEmailsPaginated(
                inboxId,
                page,
                size,
                sort,
                unreadOnly,
                options
            );
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a raw, unparsed, and unprocessed email. If your client has issues processing the response it is likely due to the response content-type which is text/plain. If you need a JSON response content-type use the getRawEmailJson endpoint
         * @summary Get raw email string. Returns unparsed raw SMTP message with headers and body.
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawEmailContents(
            emailId: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = EmailControllerApiFetchParamCreator(
                configuration
            ).getRawEmailContents(emailId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a raw, unparsed, and unprocessed email wrapped in a JSON response object for easier handling when compared with the getRawEmail text/plain response
         * @summary Get raw email in JSON. Unparsed SMTP message in JSON wrapper format.
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawEmailJson(
            emailId: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<RawEmailJson> {
            const localVarFetchArgs = EmailControllerApiFetchParamCreator(
                configuration
            ).getRawEmailJson(emailId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get number of emails unread. Unread means has not been viewed in dashboard or returned in an email API response
         * @summary Get unread email count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnreadEmailCount(
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<UnreadCount> {
            const localVarFetchArgs = EmailControllerApiFetchParamCreator(
                configuration
            ).getUnreadEmailCount(options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Send the reply to the email sender or reply-to and include same subject cc bcc etc. Reply to an email and the contents will be sent with the existing subject to the emails `to`, `cc`, and `bcc`.
         * @summary Reply to an email
         * @param {string} emailId ID of the email that should be replied to
         * @param {ReplyToEmailOptions} replyToEmailOptions replyToEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replyToEmail(
            emailId: string,
            replyToEmailOptions: ReplyToEmailOptions,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<SentEmailDto> {
            const localVarFetchArgs = EmailControllerApiFetchParamCreator(
                configuration
            ).replyToEmail(emailId, replyToEmailOptions, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Validate the HTML content of email if HTML is found. Considered valid if no HTML is present.
         * @summary Validate email HTML contents
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateEmail(
            emailId: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<ValidationDto> {
            const localVarFetchArgs = EmailControllerApiFetchParamCreator(
                configuration
            ).validateEmail(emailId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    };
};

/**
 * EmailControllerApi - factory interface
 * @export
 */
export const EmailControllerApiFactory = function(
    configuration?: Configuration,
    fetch?: FetchAPI,
    basePath?: string
) {
    return {
        /**
         * Deletes all emails in your account. Be careful as emails cannot be recovered
         * @summary Delete all emails in all inboxes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllEmails(options?: any) {
            return EmailControllerApiFp(configuration).deleteAllEmails(options)(
                fetch,
                basePath
            );
        },
        /**
         * Deletes an email and removes it from the inbox. Deleted emails cannot be recovered.
         * @summary Delete an email
         * @param {string} emailId ID of email to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmail(emailId: string, options?: any) {
            return EmailControllerApiFp(configuration).deleteEmail(
                emailId,
                options
            )(fetch, basePath);
        },
        /**
         * Returns the specified attachment for a given email as a stream / array of bytes. You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
         * @summary Get email attachment bytes. Returned as `octet-stream` with content type header. If you have trouble with byte responses try the `downloadAttachmentBase64` response endpoints and convert the base 64 encoded content to a file or string.
         * @param {string} attachmentId ID of attachment
         * @param {string} emailId ID of email
         * @param {string} [apiKey] Can pass apiKey in url for this request if you wish to download the file in a browser. Content type will be set to original content type of the attachment file. This is so that browsers can download the file correctly.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachment(
            attachmentId: string,
            emailId: string,
            apiKey?: string,
            options?: any
        ) {
            return EmailControllerApiFp(configuration).downloadAttachment(
                attachmentId,
                emailId,
                apiKey,
                options
            )(fetch, basePath);
        },
        /**
         * Returns the specified attachment for a given email as a base 64 encoded string. The response type is application/json. This method is similar to the `downloadAttachment` method but allows some clients to get around issues with binary responses.
         * @summary Get email attachment as base64 encoded string as an alternative to binary responses. Decode the `base64FileContents` as a `utf-8` encoded string or array of bytes depending on the `contentType`.
         * @param {string} attachmentId ID of attachment
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAttachmentBase64(
            attachmentId: string,
            emailId: string,
            options?: any
        ) {
            return EmailControllerApiFp(configuration).downloadAttachmentBase64(
                attachmentId,
                emailId,
                options
            )(fetch, basePath);
        },
        /**
         * Returns the specified email body for a given email as a string
         * @summary Get email body as string. Returned as `plain/text` with content type header.
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadBody(emailId: string, options?: any) {
            return EmailControllerApiFp(configuration).downloadBody(
                emailId,
                options
            )(fetch, basePath);
        },
        /**
         * Returns the specified email body for a given email as a stream / array of bytes.
         * @summary Get email body in bytes. Returned as `octet-stream` with content type header.
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadBodyBytes(emailId: string, options?: any) {
            return EmailControllerApiFp(configuration).downloadBodyBytes(
                emailId,
                options
            )(fetch, basePath);
        },
        /**
         * Forward an existing email to new recipients. The sender of the email will be the inbox that received the email you are forwarding. You can override the sender with the `from` option. Note you must have access to the from address in MailSlurp to use the override. For more control consider fetching the email and sending it a new using the send email endpoints.
         * @summary Forward email to recipients
         * @param {string} emailId ID of email
         * @param {ForwardEmailOptions} forwardEmailOptions forwardEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forwardEmail(
            emailId: string,
            forwardEmailOptions: ForwardEmailOptions,
            options?: any
        ) {
            return EmailControllerApiFp(configuration).forwardEmail(
                emailId,
                forwardEmailOptions,
                options
            )(fetch, basePath);
        },
        /**
         * Returns the metadata such as name and content-type for a given attachment and email.
         * @summary Get email attachment metadata. This is the `contentType` and `contentLength` of an attachment. To get the individual attachments  use the `downloadAttachment` methods.
         * @param {string} attachmentId ID of attachment
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachmentMetaData(
            attachmentId: string,
            emailId: string,
            options?: any
        ) {
            return EmailControllerApiFp(configuration).getAttachmentMetaData(
                attachmentId,
                emailId,
                options
            )(fetch, basePath);
        },
        /**
         * Returns an array of attachment metadata such as name and content-type for a given email if present.
         * @summary Get all email attachment metadata. Metadata includes name and size of attachments.
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachments1(emailId: string, options?: any) {
            return EmailControllerApiFp(configuration).getAttachments1(
                emailId,
                options
            )(fetch, basePath);
        },
        /**
         * Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawEmail endpoints
         * @summary Get email content including headers and body. Expects email to exist by ID. For emails that may not have arrived yet use the WaitForController.
         * @param {string} emailId emailId
         * @param {boolean} [decode] Decode email body quoted-printable encoding to plain text. SMTP servers often encode text using quoted-printable format (for instance &#x60;&#x3D;D7&#x60;). This can be a pain for testing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmail(emailId: string, decode?: boolean, options?: any) {
            return EmailControllerApiFp(configuration).getEmail(
                emailId,
                decode,
                options
            )(fetch, basePath);
        },
        /**
         * Return the matches for a given Java style regex pattern. Do not include the typical `/` at start or end of regex in some languages. Given an example `your code is: 12345` the pattern to extract match looks like `code is: (\\d{6})`. This will return an array of matches with the first matching the entire pattern and the subsequent matching the groups: `['code is: 123456', '123456']` See https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html for more information of available patterns.
         * @summary Get email content regex pattern match results. Runs regex against email body and returns match groups.
         * @param {ContentMatchOptions} contentMatchOptions contentMatchOptions
         * @param {string} emailId ID of email to match against
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailContentMatch(
            contentMatchOptions: ContentMatchOptions,
            emailId: string,
            options?: any
        ) {
            return EmailControllerApiFp(configuration).getEmailContentMatch(
                contentMatchOptions,
                emailId,
                options
            )(fetch, basePath);
        },
        /**
         * Retrieve email content as HTML response for viewing in browsers. Decodes quoted-printable entities and converts charset to UTF-8. Pass your API KEY as a request parameter when viewing in a browser: `?apiKey=xxx`
         * @summary Get email content as HTML. For displaying emails in browser context.
         * @param {string} emailId emailId
         * @param {boolean} [decode] decode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailHTML(emailId: string, decode?: boolean, options?: any) {
            return EmailControllerApiFp(configuration).getEmailHTML(
                emailId,
                decode,
                options
            )(fetch, basePath);
        },
        /**
         * Parse an email body and return the content as an array of text. HTML parsing uses JSoup which supports JQuery/CSS style selectors
         * @summary Parse and return text from an email, stripping HTML and decoding encoded characters
         * @param {string} emailId ID of email to perform HTML query on
         * @param {string} [htmlSelector] HTML selector to search for. Uses JQuery/JSoup/CSS style selector like &#39;.my-div&#39; to match content. See https://jsoup.org/apidocs/org/jsoup/select/Selector.html for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailHTMLQuery(
            emailId: string,
            htmlSelector?: string,
            options?: any
        ) {
            return EmailControllerApiFp(configuration).getEmailHTMLQuery(
                emailId,
                htmlSelector,
                options
            )(fetch, basePath);
        },
        /**
         * Parse an email body and return the content as an array of strings. HTML parsing uses JSoup and UNIX line separators.
         * @summary Parse and return text from an email, stripping HTML and decoding encoded characters
         * @param {string} emailId ID of email to fetch text for
         * @param {boolean} [decodeHtmlEntities] Decode HTML entities
         * @param {string} [lineSeparator] Line separator character
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailTextLines(
            emailId: string,
            decodeHtmlEntities?: boolean,
            lineSeparator?: string,
            options?: any
        ) {
            return EmailControllerApiFp(configuration).getEmailTextLines(
                emailId,
                decodeHtmlEntities,
                lineSeparator,
                options
            )(fetch, basePath);
        },
        /**
         * By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
         * @summary Get all emails in all inboxes in paginated form. Email API list all.
         * @param {Array<string>} [inboxId] Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account.
         * @param {number} [page] Optional page index in email list pagination
         * @param {number} [size] Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {boolean} [unreadOnly] Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailsPaginated(
            inboxId?: Array<string>,
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            unreadOnly?: boolean,
            options?: any
        ) {
            return EmailControllerApiFp(configuration).getEmailsPaginated(
                inboxId,
                page,
                size,
                sort,
                unreadOnly,
                options
            )(fetch, basePath);
        },
        /**
         * Get the newest email in all inboxes or in a passed set of inbox IDs
         * @summary Get latest email in all inboxes. Most recently received.
         * @param {Array<string>} [inboxIds] Optional set of inboxes to filter by. Only get the latest email from these inbox IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestEmail(inboxIds?: Array<string>, options?: any) {
            return EmailControllerApiFp(configuration).getLatestEmail(
                inboxIds,
                options
            )(fetch, basePath);
        },
        /**
         * Get the newest email in all inboxes or in a passed set of inbox IDs
         * @summary Get latest email in an inbox. Use `WaitForController` to get emails that may not have arrived yet.
         * @param {string} [inboxId] ID of the inbox you want to get the latest email from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestEmailInInbox(inboxId?: string, options?: any) {
            return EmailControllerApiFp(configuration).getLatestEmailInInbox(
                inboxId,
                options
            )(fetch, basePath);
        },
        /**
         * By default returns all emails across all team inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
         * @summary Get all organization emails. List team or shared test email accounts
         * @param {Array<string>} [inboxId] Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account.
         * @param {number} [page] Optional page index in email list pagination
         * @param {number} [size] Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {boolean} [unreadOnly] Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationEmailsPaginated(
            inboxId?: Array<string>,
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            unreadOnly?: boolean,
            options?: any
        ) {
            return EmailControllerApiFp(
                configuration
            ).getOrganizationEmailsPaginated(
                inboxId,
                page,
                size,
                sort,
                unreadOnly,
                options
            )(fetch, basePath);
        },
        /**
         * Returns a raw, unparsed, and unprocessed email. If your client has issues processing the response it is likely due to the response content-type which is text/plain. If you need a JSON response content-type use the getRawEmailJson endpoint
         * @summary Get raw email string. Returns unparsed raw SMTP message with headers and body.
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawEmailContents(emailId: string, options?: any) {
            return EmailControllerApiFp(configuration).getRawEmailContents(
                emailId,
                options
            )(fetch, basePath);
        },
        /**
         * Returns a raw, unparsed, and unprocessed email wrapped in a JSON response object for easier handling when compared with the getRawEmail text/plain response
         * @summary Get raw email in JSON. Unparsed SMTP message in JSON wrapper format.
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawEmailJson(emailId: string, options?: any) {
            return EmailControllerApiFp(configuration).getRawEmailJson(
                emailId,
                options
            )(fetch, basePath);
        },
        /**
         * Get number of emails unread. Unread means has not been viewed in dashboard or returned in an email API response
         * @summary Get unread email count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnreadEmailCount(options?: any) {
            return EmailControllerApiFp(configuration).getUnreadEmailCount(
                options
            )(fetch, basePath);
        },
        /**
         * Send the reply to the email sender or reply-to and include same subject cc bcc etc. Reply to an email and the contents will be sent with the existing subject to the emails `to`, `cc`, and `bcc`.
         * @summary Reply to an email
         * @param {string} emailId ID of the email that should be replied to
         * @param {ReplyToEmailOptions} replyToEmailOptions replyToEmailOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replyToEmail(
            emailId: string,
            replyToEmailOptions: ReplyToEmailOptions,
            options?: any
        ) {
            return EmailControllerApiFp(configuration).replyToEmail(
                emailId,
                replyToEmailOptions,
                options
            )(fetch, basePath);
        },
        /**
         * Validate the HTML content of email if HTML is found. Considered valid if no HTML is present.
         * @summary Validate email HTML contents
         * @param {string} emailId ID of email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateEmail(emailId: string, options?: any) {
            return EmailControllerApiFp(configuration).validateEmail(
                emailId,
                options
            )(fetch, basePath);
        },
    };
};

/**
 * EmailControllerApi - object-oriented interface
 * @export
 * @class EmailControllerApi
 * @extends {BaseAPI}
 */
export class EmailControllerApi extends BaseAPI {
    /**
     * Deletes all emails in your account. Be careful as emails cannot be recovered
     * @summary Delete all emails in all inboxes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    public deleteAllEmails(options?: any) {
        return EmailControllerApiFp(this.configuration).deleteAllEmails(
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Deletes an email and removes it from the inbox. Deleted emails cannot be recovered.
     * @summary Delete an email
     * @param {string} emailId ID of email to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    public deleteEmail(emailId: string, options?: any) {
        return EmailControllerApiFp(this.configuration).deleteEmail(
            emailId,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Returns the specified attachment for a given email as a stream / array of bytes. You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
     * @summary Get email attachment bytes. Returned as `octet-stream` with content type header. If you have trouble with byte responses try the `downloadAttachmentBase64` response endpoints and convert the base 64 encoded content to a file or string.
     * @param {string} attachmentId ID of attachment
     * @param {string} emailId ID of email
     * @param {string} [apiKey] Can pass apiKey in url for this request if you wish to download the file in a browser. Content type will be set to original content type of the attachment file. This is so that browsers can download the file correctly.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    public downloadAttachment(
        attachmentId: string,
        emailId: string,
        apiKey?: string,
        options?: any
    ) {
        return EmailControllerApiFp(this.configuration).downloadAttachment(
            attachmentId,
            emailId,
            apiKey,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Returns the specified attachment for a given email as a base 64 encoded string. The response type is application/json. This method is similar to the `downloadAttachment` method but allows some clients to get around issues with binary responses.
     * @summary Get email attachment as base64 encoded string as an alternative to binary responses. Decode the `base64FileContents` as a `utf-8` encoded string or array of bytes depending on the `contentType`.
     * @param {string} attachmentId ID of attachment
     * @param {string} emailId ID of email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    public downloadAttachmentBase64(
        attachmentId: string,
        emailId: string,
        options?: any
    ) {
        return EmailControllerApiFp(
            this.configuration
        ).downloadAttachmentBase64(attachmentId, emailId, options)(
            this.fetch,
            this.basePath
        );
    }

    /**
     * Returns the specified email body for a given email as a string
     * @summary Get email body as string. Returned as `plain/text` with content type header.
     * @param {string} emailId ID of email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    public downloadBody(emailId: string, options?: any) {
        return EmailControllerApiFp(this.configuration).downloadBody(
            emailId,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Returns the specified email body for a given email as a stream / array of bytes.
     * @summary Get email body in bytes. Returned as `octet-stream` with content type header.
     * @param {string} emailId ID of email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    public downloadBodyBytes(emailId: string, options?: any) {
        return EmailControllerApiFp(this.configuration).downloadBodyBytes(
            emailId,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Forward an existing email to new recipients. The sender of the email will be the inbox that received the email you are forwarding. You can override the sender with the `from` option. Note you must have access to the from address in MailSlurp to use the override. For more control consider fetching the email and sending it a new using the send email endpoints.
     * @summary Forward email to recipients
     * @param {string} emailId ID of email
     * @param {ForwardEmailOptions} forwardEmailOptions forwardEmailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    public forwardEmail(
        emailId: string,
        forwardEmailOptions: ForwardEmailOptions,
        options?: any
    ) {
        return EmailControllerApiFp(this.configuration).forwardEmail(
            emailId,
            forwardEmailOptions,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Returns the metadata such as name and content-type for a given attachment and email.
     * @summary Get email attachment metadata. This is the `contentType` and `contentLength` of an attachment. To get the individual attachments  use the `downloadAttachment` methods.
     * @param {string} attachmentId ID of attachment
     * @param {string} emailId ID of email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    public getAttachmentMetaData(
        attachmentId: string,
        emailId: string,
        options?: any
    ) {
        return EmailControllerApiFp(this.configuration).getAttachmentMetaData(
            attachmentId,
            emailId,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Returns an array of attachment metadata such as name and content-type for a given email if present.
     * @summary Get all email attachment metadata. Metadata includes name and size of attachments.
     * @param {string} emailId ID of email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    public getAttachments1(emailId: string, options?: any) {
        return EmailControllerApiFp(this.configuration).getAttachments1(
            emailId,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawEmail endpoints
     * @summary Get email content including headers and body. Expects email to exist by ID. For emails that may not have arrived yet use the WaitForController.
     * @param {string} emailId emailId
     * @param {boolean} [decode] Decode email body quoted-printable encoding to plain text. SMTP servers often encode text using quoted-printable format (for instance &#x60;&#x3D;D7&#x60;). This can be a pain for testing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    public getEmail(emailId: string, decode?: boolean, options?: any) {
        return EmailControllerApiFp(this.configuration).getEmail(
            emailId,
            decode,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Return the matches for a given Java style regex pattern. Do not include the typical `/` at start or end of regex in some languages. Given an example `your code is: 12345` the pattern to extract match looks like `code is: (\\d{6})`. This will return an array of matches with the first matching the entire pattern and the subsequent matching the groups: `['code is: 123456', '123456']` See https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html for more information of available patterns.
     * @summary Get email content regex pattern match results. Runs regex against email body and returns match groups.
     * @param {ContentMatchOptions} contentMatchOptions contentMatchOptions
     * @param {string} emailId ID of email to match against
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    public getEmailContentMatch(
        contentMatchOptions: ContentMatchOptions,
        emailId: string,
        options?: any
    ) {
        return EmailControllerApiFp(this.configuration).getEmailContentMatch(
            contentMatchOptions,
            emailId,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Retrieve email content as HTML response for viewing in browsers. Decodes quoted-printable entities and converts charset to UTF-8. Pass your API KEY as a request parameter when viewing in a browser: `?apiKey=xxx`
     * @summary Get email content as HTML. For displaying emails in browser context.
     * @param {string} emailId emailId
     * @param {boolean} [decode] decode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    public getEmailHTML(emailId: string, decode?: boolean, options?: any) {
        return EmailControllerApiFp(this.configuration).getEmailHTML(
            emailId,
            decode,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Parse an email body and return the content as an array of text. HTML parsing uses JSoup which supports JQuery/CSS style selectors
     * @summary Parse and return text from an email, stripping HTML and decoding encoded characters
     * @param {string} emailId ID of email to perform HTML query on
     * @param {string} [htmlSelector] HTML selector to search for. Uses JQuery/JSoup/CSS style selector like &#39;.my-div&#39; to match content. See https://jsoup.org/apidocs/org/jsoup/select/Selector.html for more information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    public getEmailHTMLQuery(
        emailId: string,
        htmlSelector?: string,
        options?: any
    ) {
        return EmailControllerApiFp(this.configuration).getEmailHTMLQuery(
            emailId,
            htmlSelector,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Parse an email body and return the content as an array of strings. HTML parsing uses JSoup and UNIX line separators.
     * @summary Parse and return text from an email, stripping HTML and decoding encoded characters
     * @param {string} emailId ID of email to fetch text for
     * @param {boolean} [decodeHtmlEntities] Decode HTML entities
     * @param {string} [lineSeparator] Line separator character
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    public getEmailTextLines(
        emailId: string,
        decodeHtmlEntities?: boolean,
        lineSeparator?: string,
        options?: any
    ) {
        return EmailControllerApiFp(this.configuration).getEmailTextLines(
            emailId,
            decodeHtmlEntities,
            lineSeparator,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
     * @summary Get all emails in all inboxes in paginated form. Email API list all.
     * @param {Array<string>} [inboxId] Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account.
     * @param {number} [page] Optional page index in email list pagination
     * @param {number} [size] Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {boolean} [unreadOnly] Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    public getEmailsPaginated(
        inboxId?: Array<string>,
        page?: number,
        size?: number,
        sort?: 'ASC' | 'DESC',
        unreadOnly?: boolean,
        options?: any
    ) {
        return EmailControllerApiFp(this.configuration).getEmailsPaginated(
            inboxId,
            page,
            size,
            sort,
            unreadOnly,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Get the newest email in all inboxes or in a passed set of inbox IDs
     * @summary Get latest email in all inboxes. Most recently received.
     * @param {Array<string>} [inboxIds] Optional set of inboxes to filter by. Only get the latest email from these inbox IDs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    public getLatestEmail(inboxIds?: Array<string>, options?: any) {
        return EmailControllerApiFp(this.configuration).getLatestEmail(
            inboxIds,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Get the newest email in all inboxes or in a passed set of inbox IDs
     * @summary Get latest email in an inbox. Use `WaitForController` to get emails that may not have arrived yet.
     * @param {string} [inboxId] ID of the inbox you want to get the latest email from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    public getLatestEmailInInbox(inboxId?: string, options?: any) {
        return EmailControllerApiFp(this.configuration).getLatestEmailInInbox(
            inboxId,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * By default returns all emails across all team inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
     * @summary Get all organization emails. List team or shared test email accounts
     * @param {Array<string>} [inboxId] Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account.
     * @param {number} [page] Optional page index in email list pagination
     * @param {number} [size] Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {boolean} [unreadOnly] Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    public getOrganizationEmailsPaginated(
        inboxId?: Array<string>,
        page?: number,
        size?: number,
        sort?: 'ASC' | 'DESC',
        unreadOnly?: boolean,
        options?: any
    ) {
        return EmailControllerApiFp(
            this.configuration
        ).getOrganizationEmailsPaginated(
            inboxId,
            page,
            size,
            sort,
            unreadOnly,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Returns a raw, unparsed, and unprocessed email. If your client has issues processing the response it is likely due to the response content-type which is text/plain. If you need a JSON response content-type use the getRawEmailJson endpoint
     * @summary Get raw email string. Returns unparsed raw SMTP message with headers and body.
     * @param {string} emailId ID of email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    public getRawEmailContents(emailId: string, options?: any) {
        return EmailControllerApiFp(this.configuration).getRawEmailContents(
            emailId,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Returns a raw, unparsed, and unprocessed email wrapped in a JSON response object for easier handling when compared with the getRawEmail text/plain response
     * @summary Get raw email in JSON. Unparsed SMTP message in JSON wrapper format.
     * @param {string} emailId ID of email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    public getRawEmailJson(emailId: string, options?: any) {
        return EmailControllerApiFp(this.configuration).getRawEmailJson(
            emailId,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Get number of emails unread. Unread means has not been viewed in dashboard or returned in an email API response
     * @summary Get unread email count
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    public getUnreadEmailCount(options?: any) {
        return EmailControllerApiFp(this.configuration).getUnreadEmailCount(
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Send the reply to the email sender or reply-to and include same subject cc bcc etc. Reply to an email and the contents will be sent with the existing subject to the emails `to`, `cc`, and `bcc`.
     * @summary Reply to an email
     * @param {string} emailId ID of the email that should be replied to
     * @param {ReplyToEmailOptions} replyToEmailOptions replyToEmailOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    public replyToEmail(
        emailId: string,
        replyToEmailOptions: ReplyToEmailOptions,
        options?: any
    ) {
        return EmailControllerApiFp(this.configuration).replyToEmail(
            emailId,
            replyToEmailOptions,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Validate the HTML content of email if HTML is found. Considered valid if no HTML is present.
     * @summary Validate email HTML contents
     * @param {string} emailId ID of email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailControllerApi
     */
    public validateEmail(emailId: string, options?: any) {
        return EmailControllerApiFp(this.configuration).validateEmail(
            emailId,
            options
        )(this.fetch, this.basePath);
    }
}

/**
 * ExpiredControllerApi - fetch parameter creator
 * @export
 */
export const ExpiredControllerApiFetchParamCreator = function(
    configuration?: Configuration
) {
    return {
        /**
         * Return default times used for inbox expiration
         * @summary Get default expiration settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpirationDefaults(options: any = {}): FetchArgs {
            const localVarPath = `/expired/defaults`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use the inboxId to return an ExpiredInboxRecord if an inbox has expired. Inboxes expire and are disabled if an expiration date is set or plan requires. Returns 404 if no expired inbox is found for the inboxId
         * @summary Get expired inbox record for a previously existing inbox
         * @param {string} inboxId ID of inbox you want to retrieve (not the inbox ID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpiredInboxByInboxId(
            inboxId: string,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError(
                    'inboxId',
                    'Required parameter inboxId was null or undefined when calling getExpiredInboxByInboxId.'
                );
            }
            const localVarPath = `/expired/inbox/{inboxId}`.replace(
                `{${'inboxId'}}`,
                encodeURIComponent(String(inboxId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Inboxes created with an expiration date will expire after the given date and be moved to an ExpiredInbox entity. You can still read emails in the inbox but it can no longer send or receive emails. Fetch the expired inboxes to view the old inboxes properties
         * @summary Get an expired inbox record
         * @param {string} expiredId ID of the ExpiredInboxRecord you want to retrieve. This is different from the ID of the inbox you are interested in. See other methods for getting ExpiredInboxRecord for an inbox inboxId)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpiredInboxRecord(expiredId: string, options: any = {}): FetchArgs {
            // verify required parameter 'expiredId' is not null or undefined
            if (expiredId === null || expiredId === undefined) {
                throw new RequiredError(
                    'expiredId',
                    'Required parameter expiredId was null or undefined when calling getExpiredInboxRecord.'
                );
            }
            const localVarPath = `/expired/{expiredId}`.replace(
                `{${'expiredId'}}`,
                encodeURIComponent(String(expiredId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Inboxes created with an expiration date will expire after the given date. An ExpiredInboxRecord is created that records the inboxes old ID and email address. You can still read emails in the inbox (using the inboxes old ID) but the email address associated with the inbox can no longer send or receive emails. Fetch expired inbox records to view the old inboxes properties
         * @summary List records of expired inboxes
         * @param {number} [page] Optional page index in inbox sent email list pagination
         * @param {number} [size] Optional page size in inbox sent email list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpiredInboxes(
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options: any = {}
        ): FetchArgs {
            const localVarPath = `/expired`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * ExpiredControllerApi - functional programming interface
 * @export
 */
export const ExpiredControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Return default times used for inbox expiration
         * @summary Get default expiration settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpirationDefaults(
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<ExpirationDefaults> {
            const localVarFetchArgs = ExpiredControllerApiFetchParamCreator(
                configuration
            ).getExpirationDefaults(options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Use the inboxId to return an ExpiredInboxRecord if an inbox has expired. Inboxes expire and are disabled if an expiration date is set or plan requires. Returns 404 if no expired inbox is found for the inboxId
         * @summary Get expired inbox record for a previously existing inbox
         * @param {string} inboxId ID of inbox you want to retrieve (not the inbox ID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpiredInboxByInboxId(
            inboxId: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<ExpiredInboxDto> {
            const localVarFetchArgs = ExpiredControllerApiFetchParamCreator(
                configuration
            ).getExpiredInboxByInboxId(inboxId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Inboxes created with an expiration date will expire after the given date and be moved to an ExpiredInbox entity. You can still read emails in the inbox but it can no longer send or receive emails. Fetch the expired inboxes to view the old inboxes properties
         * @summary Get an expired inbox record
         * @param {string} expiredId ID of the ExpiredInboxRecord you want to retrieve. This is different from the ID of the inbox you are interested in. See other methods for getting ExpiredInboxRecord for an inbox inboxId)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpiredInboxRecord(
            expiredId: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<ExpiredInboxDto> {
            const localVarFetchArgs = ExpiredControllerApiFetchParamCreator(
                configuration
            ).getExpiredInboxRecord(expiredId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Inboxes created with an expiration date will expire after the given date. An ExpiredInboxRecord is created that records the inboxes old ID and email address. You can still read emails in the inbox (using the inboxes old ID) but the email address associated with the inbox can no longer send or receive emails. Fetch expired inbox records to view the old inboxes properties
         * @summary List records of expired inboxes
         * @param {number} [page] Optional page index in inbox sent email list pagination
         * @param {number} [size] Optional page size in inbox sent email list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpiredInboxes(
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<PageExpiredInboxRecordProjection> {
            const localVarFetchArgs = ExpiredControllerApiFetchParamCreator(
                configuration
            ).getExpiredInboxes(page, size, sort, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    };
};

/**
 * ExpiredControllerApi - factory interface
 * @export
 */
export const ExpiredControllerApiFactory = function(
    configuration?: Configuration,
    fetch?: FetchAPI,
    basePath?: string
) {
    return {
        /**
         * Return default times used for inbox expiration
         * @summary Get default expiration settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpirationDefaults(options?: any) {
            return ExpiredControllerApiFp(configuration).getExpirationDefaults(
                options
            )(fetch, basePath);
        },
        /**
         * Use the inboxId to return an ExpiredInboxRecord if an inbox has expired. Inboxes expire and are disabled if an expiration date is set or plan requires. Returns 404 if no expired inbox is found for the inboxId
         * @summary Get expired inbox record for a previously existing inbox
         * @param {string} inboxId ID of inbox you want to retrieve (not the inbox ID)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpiredInboxByInboxId(inboxId: string, options?: any) {
            return ExpiredControllerApiFp(
                configuration
            ).getExpiredInboxByInboxId(inboxId, options)(fetch, basePath);
        },
        /**
         * Inboxes created with an expiration date will expire after the given date and be moved to an ExpiredInbox entity. You can still read emails in the inbox but it can no longer send or receive emails. Fetch the expired inboxes to view the old inboxes properties
         * @summary Get an expired inbox record
         * @param {string} expiredId ID of the ExpiredInboxRecord you want to retrieve. This is different from the ID of the inbox you are interested in. See other methods for getting ExpiredInboxRecord for an inbox inboxId)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpiredInboxRecord(expiredId: string, options?: any) {
            return ExpiredControllerApiFp(configuration).getExpiredInboxRecord(
                expiredId,
                options
            )(fetch, basePath);
        },
        /**
         * Inboxes created with an expiration date will expire after the given date. An ExpiredInboxRecord is created that records the inboxes old ID and email address. You can still read emails in the inbox (using the inboxes old ID) but the email address associated with the inbox can no longer send or receive emails. Fetch expired inbox records to view the old inboxes properties
         * @summary List records of expired inboxes
         * @param {number} [page] Optional page index in inbox sent email list pagination
         * @param {number} [size] Optional page size in inbox sent email list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpiredInboxes(
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ) {
            return ExpiredControllerApiFp(configuration).getExpiredInboxes(
                page,
                size,
                sort,
                options
            )(fetch, basePath);
        },
    };
};

/**
 * ExpiredControllerApi - object-oriented interface
 * @export
 * @class ExpiredControllerApi
 * @extends {BaseAPI}
 */
export class ExpiredControllerApi extends BaseAPI {
    /**
     * Return default times used for inbox expiration
     * @summary Get default expiration settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExpiredControllerApi
     */
    public getExpirationDefaults(options?: any) {
        return ExpiredControllerApiFp(this.configuration).getExpirationDefaults(
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Use the inboxId to return an ExpiredInboxRecord if an inbox has expired. Inboxes expire and are disabled if an expiration date is set or plan requires. Returns 404 if no expired inbox is found for the inboxId
     * @summary Get expired inbox record for a previously existing inbox
     * @param {string} inboxId ID of inbox you want to retrieve (not the inbox ID)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExpiredControllerApi
     */
    public getExpiredInboxByInboxId(inboxId: string, options?: any) {
        return ExpiredControllerApiFp(
            this.configuration
        ).getExpiredInboxByInboxId(inboxId, options)(this.fetch, this.basePath);
    }

    /**
     * Inboxes created with an expiration date will expire after the given date and be moved to an ExpiredInbox entity. You can still read emails in the inbox but it can no longer send or receive emails. Fetch the expired inboxes to view the old inboxes properties
     * @summary Get an expired inbox record
     * @param {string} expiredId ID of the ExpiredInboxRecord you want to retrieve. This is different from the ID of the inbox you are interested in. See other methods for getting ExpiredInboxRecord for an inbox inboxId)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExpiredControllerApi
     */
    public getExpiredInboxRecord(expiredId: string, options?: any) {
        return ExpiredControllerApiFp(this.configuration).getExpiredInboxRecord(
            expiredId,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Inboxes created with an expiration date will expire after the given date. An ExpiredInboxRecord is created that records the inboxes old ID and email address. You can still read emails in the inbox (using the inboxes old ID) but the email address associated with the inbox can no longer send or receive emails. Fetch expired inbox records to view the old inboxes properties
     * @summary List records of expired inboxes
     * @param {number} [page] Optional page index in inbox sent email list pagination
     * @param {number} [size] Optional page size in inbox sent email list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExpiredControllerApi
     */
    public getExpiredInboxes(
        page?: number,
        size?: number,
        sort?: 'ASC' | 'DESC',
        options?: any
    ) {
        return ExpiredControllerApiFp(this.configuration).getExpiredInboxes(
            page,
            size,
            sort,
            options
        )(this.fetch, this.basePath);
    }
}

/**
 * FormControllerApi - fetch parameter creator
 * @export
 */
export const FormControllerApiFetchParamCreator = function(
    configuration?: Configuration
) {
    return {
        /**
         * This endpoint allows you to submit HTML forms and receive the field values and files via email.   #### Parameters The endpoint looks for special meta parameters in the form fields OR in the URL request parameters. The meta parameters can be used to specify the behaviour of the email.   You must provide at-least a `_to` email address to tell the endpoint where the form should be emailed. These can be submitted as hidden HTML input fields with the corresponding `name` attributes or as URL query parameters such as `?_to=test@example.com`  The endpoint takes all other form fields that are named and includes them in the message body of the email. Files are sent as attachments.  #### Submitting This endpoint accepts form submission via POST method. It accepts `application/x-www-form-urlencoded`, and `multipart/form-data` content-types.  #### HTML Example ```html <form    action=\"https://api.mailslurp.com/forms\"   method=\"post\" >   <input name=\"_to\" type=\"hidden\" value=\"test@example.com\"/>   <textarea name=\"feedback\"></textarea>   <button type=\"submit\">Submit</button> </form> ```  #### URL Example ```html <form    action=\"https://api.mailslurp.com/forms?_to=test@example.com\"   method=\"post\" >   <textarea name=\"feedback\"></textarea>   <button type=\"submit\">Submit</button> </form> ```    The email address is specified by a `_to` field OR is extracted from an email alias specified by a `_toAlias` field (see the alias controller for more information).  Endpoint accepts .  You can specify a content type in HTML forms using the `enctype` attribute, for instance: `<form enctype=\"multipart/form-data\">`.
         * @summary Submit a form to be parsed and sent as an email to an address determined by the form fields
         * @param {string} [emailAddress] Email address of the submitting user. Include this if you wish to record the submitters email address and reply to it later.
         * @param {string} [redirectTo] Optional URL to redirect form submitter to after submission. If not present user will see a success message.
         * @param {string} [spamCheck] Optional but recommended field that catches spammers out. Include as a hidden form field but LEAVE EMPTY. Spam-bots will usually fill every field. If the _spamCheck field is filled the form submission will be ignored.
         * @param {string} [subject] Optional subject of the email that will be sent.
         * @param {string} [successMessage] Optional success message to display if no _redirectTo present.
         * @param {string} [to] The email address that submitted form should be sent to.
         * @param {string} [otherParameters] All other parameters or fields will be accepted and attached to the sent email. This includes files and any HTML form field with a name. These fields will become the body of the email that is sent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitForm(
            emailAddress?: string,
            redirectTo?: string,
            spamCheck?: string,
            subject?: string,
            successMessage?: string,
            to?: string,
            otherParameters?: string,
            options: any = {}
        ): FetchArgs {
            const localVarPath = `/forms`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (emailAddress !== undefined) {
                localVarFormParams.set('_emailAddress', emailAddress as any);
            }

            if (redirectTo !== undefined) {
                localVarFormParams.set('_redirectTo', redirectTo as any);
            }

            if (spamCheck !== undefined) {
                localVarFormParams.set('_spamCheck', spamCheck as any);
            }

            if (subject !== undefined) {
                localVarFormParams.set('_subject', subject as any);
            }

            if (successMessage !== undefined) {
                localVarFormParams.set(
                    '_successMessage',
                    successMessage as any
                );
            }

            if (to !== undefined) {
                localVarFormParams.set('_to', to as any);
            }

            if (otherParameters !== undefined) {
                localVarFormParams.set(
                    'otherParameters',
                    otherParameters as any
                );
            }

            localVarHeaderParameter['Content-Type'] =
                'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * FormControllerApi - functional programming interface
 * @export
 */
export const FormControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This endpoint allows you to submit HTML forms and receive the field values and files via email.   #### Parameters The endpoint looks for special meta parameters in the form fields OR in the URL request parameters. The meta parameters can be used to specify the behaviour of the email.   You must provide at-least a `_to` email address to tell the endpoint where the form should be emailed. These can be submitted as hidden HTML input fields with the corresponding `name` attributes or as URL query parameters such as `?_to=test@example.com`  The endpoint takes all other form fields that are named and includes them in the message body of the email. Files are sent as attachments.  #### Submitting This endpoint accepts form submission via POST method. It accepts `application/x-www-form-urlencoded`, and `multipart/form-data` content-types.  #### HTML Example ```html <form    action=\"https://api.mailslurp.com/forms\"   method=\"post\" >   <input name=\"_to\" type=\"hidden\" value=\"test@example.com\"/>   <textarea name=\"feedback\"></textarea>   <button type=\"submit\">Submit</button> </form> ```  #### URL Example ```html <form    action=\"https://api.mailslurp.com/forms?_to=test@example.com\"   method=\"post\" >   <textarea name=\"feedback\"></textarea>   <button type=\"submit\">Submit</button> </form> ```    The email address is specified by a `_to` field OR is extracted from an email alias specified by a `_toAlias` field (see the alias controller for more information).  Endpoint accepts .  You can specify a content type in HTML forms using the `enctype` attribute, for instance: `<form enctype=\"multipart/form-data\">`.
         * @summary Submit a form to be parsed and sent as an email to an address determined by the form fields
         * @param {string} [emailAddress] Email address of the submitting user. Include this if you wish to record the submitters email address and reply to it later.
         * @param {string} [redirectTo] Optional URL to redirect form submitter to after submission. If not present user will see a success message.
         * @param {string} [spamCheck] Optional but recommended field that catches spammers out. Include as a hidden form field but LEAVE EMPTY. Spam-bots will usually fill every field. If the _spamCheck field is filled the form submission will be ignored.
         * @param {string} [subject] Optional subject of the email that will be sent.
         * @param {string} [successMessage] Optional success message to display if no _redirectTo present.
         * @param {string} [to] The email address that submitted form should be sent to.
         * @param {string} [otherParameters] All other parameters or fields will be accepted and attached to the sent email. This includes files and any HTML form field with a name. These fields will become the body of the email that is sent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitForm(
            emailAddress?: string,
            redirectTo?: string,
            spamCheck?: string,
            subject?: string,
            successMessage?: string,
            to?: string,
            otherParameters?: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = FormControllerApiFetchParamCreator(
                configuration
            ).submitForm(
                emailAddress,
                redirectTo,
                spamCheck,
                subject,
                successMessage,
                to,
                otherParameters,
                options
            );
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    };
};

/**
 * FormControllerApi - factory interface
 * @export
 */
export const FormControllerApiFactory = function(
    configuration?: Configuration,
    fetch?: FetchAPI,
    basePath?: string
) {
    return {
        /**
         * This endpoint allows you to submit HTML forms and receive the field values and files via email.   #### Parameters The endpoint looks for special meta parameters in the form fields OR in the URL request parameters. The meta parameters can be used to specify the behaviour of the email.   You must provide at-least a `_to` email address to tell the endpoint where the form should be emailed. These can be submitted as hidden HTML input fields with the corresponding `name` attributes or as URL query parameters such as `?_to=test@example.com`  The endpoint takes all other form fields that are named and includes them in the message body of the email. Files are sent as attachments.  #### Submitting This endpoint accepts form submission via POST method. It accepts `application/x-www-form-urlencoded`, and `multipart/form-data` content-types.  #### HTML Example ```html <form    action=\"https://api.mailslurp.com/forms\"   method=\"post\" >   <input name=\"_to\" type=\"hidden\" value=\"test@example.com\"/>   <textarea name=\"feedback\"></textarea>   <button type=\"submit\">Submit</button> </form> ```  #### URL Example ```html <form    action=\"https://api.mailslurp.com/forms?_to=test@example.com\"   method=\"post\" >   <textarea name=\"feedback\"></textarea>   <button type=\"submit\">Submit</button> </form> ```    The email address is specified by a `_to` field OR is extracted from an email alias specified by a `_toAlias` field (see the alias controller for more information).  Endpoint accepts .  You can specify a content type in HTML forms using the `enctype` attribute, for instance: `<form enctype=\"multipart/form-data\">`.
         * @summary Submit a form to be parsed and sent as an email to an address determined by the form fields
         * @param {string} [emailAddress] Email address of the submitting user. Include this if you wish to record the submitters email address and reply to it later.
         * @param {string} [redirectTo] Optional URL to redirect form submitter to after submission. If not present user will see a success message.
         * @param {string} [spamCheck] Optional but recommended field that catches spammers out. Include as a hidden form field but LEAVE EMPTY. Spam-bots will usually fill every field. If the _spamCheck field is filled the form submission will be ignored.
         * @param {string} [subject] Optional subject of the email that will be sent.
         * @param {string} [successMessage] Optional success message to display if no _redirectTo present.
         * @param {string} [to] The email address that submitted form should be sent to.
         * @param {string} [otherParameters] All other parameters or fields will be accepted and attached to the sent email. This includes files and any HTML form field with a name. These fields will become the body of the email that is sent.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitForm(
            emailAddress?: string,
            redirectTo?: string,
            spamCheck?: string,
            subject?: string,
            successMessage?: string,
            to?: string,
            otherParameters?: string,
            options?: any
        ) {
            return FormControllerApiFp(configuration).submitForm(
                emailAddress,
                redirectTo,
                spamCheck,
                subject,
                successMessage,
                to,
                otherParameters,
                options
            )(fetch, basePath);
        },
    };
};

/**
 * FormControllerApi - object-oriented interface
 * @export
 * @class FormControllerApi
 * @extends {BaseAPI}
 */
export class FormControllerApi extends BaseAPI {
    /**
     * This endpoint allows you to submit HTML forms and receive the field values and files via email.   #### Parameters The endpoint looks for special meta parameters in the form fields OR in the URL request parameters. The meta parameters can be used to specify the behaviour of the email.   You must provide at-least a `_to` email address to tell the endpoint where the form should be emailed. These can be submitted as hidden HTML input fields with the corresponding `name` attributes or as URL query parameters such as `?_to=test@example.com`  The endpoint takes all other form fields that are named and includes them in the message body of the email. Files are sent as attachments.  #### Submitting This endpoint accepts form submission via POST method. It accepts `application/x-www-form-urlencoded`, and `multipart/form-data` content-types.  #### HTML Example ```html <form    action=\"https://api.mailslurp.com/forms\"   method=\"post\" >   <input name=\"_to\" type=\"hidden\" value=\"test@example.com\"/>   <textarea name=\"feedback\"></textarea>   <button type=\"submit\">Submit</button> </form> ```  #### URL Example ```html <form    action=\"https://api.mailslurp.com/forms?_to=test@example.com\"   method=\"post\" >   <textarea name=\"feedback\"></textarea>   <button type=\"submit\">Submit</button> </form> ```    The email address is specified by a `_to` field OR is extracted from an email alias specified by a `_toAlias` field (see the alias controller for more information).  Endpoint accepts .  You can specify a content type in HTML forms using the `enctype` attribute, for instance: `<form enctype=\"multipart/form-data\">`.
     * @summary Submit a form to be parsed and sent as an email to an address determined by the form fields
     * @param {string} [emailAddress] Email address of the submitting user. Include this if you wish to record the submitters email address and reply to it later.
     * @param {string} [redirectTo] Optional URL to redirect form submitter to after submission. If not present user will see a success message.
     * @param {string} [spamCheck] Optional but recommended field that catches spammers out. Include as a hidden form field but LEAVE EMPTY. Spam-bots will usually fill every field. If the _spamCheck field is filled the form submission will be ignored.
     * @param {string} [subject] Optional subject of the email that will be sent.
     * @param {string} [successMessage] Optional success message to display if no _redirectTo present.
     * @param {string} [to] The email address that submitted form should be sent to.
     * @param {string} [otherParameters] All other parameters or fields will be accepted and attached to the sent email. This includes files and any HTML form field with a name. These fields will become the body of the email that is sent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormControllerApi
     */
    public submitForm(
        emailAddress?: string,
        redirectTo?: string,
        spamCheck?: string,
        subject?: string,
        successMessage?: string,
        to?: string,
        otherParameters?: string,
        options?: any
    ) {
        return FormControllerApiFp(this.configuration).submitForm(
            emailAddress,
            redirectTo,
            spamCheck,
            subject,
            successMessage,
            to,
            otherParameters,
            options
        )(this.fetch, this.basePath);
    }
}

/**
 * GroupControllerApi - fetch parameter creator
 * @export
 */
export const GroupControllerApiFetchParamCreator = function(
    configuration?: Configuration
) {
    return {
        /**
         *
         * @summary Add contacts to a group
         * @param {string} groupId groupId
         * @param {UpdateGroupContacts} updateGroupContactsOption updateGroupContactsOption
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addContactsToGroup(
            groupId: string,
            updateGroupContactsOption: UpdateGroupContacts,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError(
                    'groupId',
                    'Required parameter groupId was null or undefined when calling addContactsToGroup.'
                );
            }
            // verify required parameter 'updateGroupContactsOption' is not null or undefined
            if (
                updateGroupContactsOption === null ||
                updateGroupContactsOption === undefined
            ) {
                throw new RequiredError(
                    'updateGroupContactsOption',
                    'Required parameter updateGroupContactsOption was null or undefined when calling addContactsToGroup.'
                );
            }
            const localVarPath = `/groups/{groupId}/contacts`.replace(
                `{${'groupId'}}`,
                encodeURIComponent(String(groupId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'PUT' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'UpdateGroupContacts' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(updateGroupContactsOption || {})
                : updateGroupContactsOption || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a group
         * @param {CreateGroupOptions} createGroupOptions createGroupOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(
            createGroupOptions: CreateGroupOptions,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'createGroupOptions' is not null or undefined
            if (
                createGroupOptions === null ||
                createGroupOptions === undefined
            ) {
                throw new RequiredError(
                    'createGroupOptions',
                    'Required parameter createGroupOptions was null or undefined when calling createGroup.'
                );
            }
            const localVarPath = `/groups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'CreateGroupOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(createGroupOptions || {})
                : createGroupOptions || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete group
         * @param {string} groupId groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(groupId: string, options: any = {}): FetchArgs {
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError(
                    'groupId',
                    'Required parameter groupId was null or undefined when calling deleteGroup.'
                );
            }
            const localVarPath = `/groups/{groupId}`.replace(
                `{${'groupId'}}`,
                encodeURIComponent(String(groupId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'DELETE' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Contact Groups in paginated format
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllGroups(
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options: any = {}
        ): FetchArgs {
            const localVarPath = `/groups/paginated`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get group
         * @param {string} groupId groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(groupId: string, options: any = {}): FetchArgs {
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError(
                    'groupId',
                    'Required parameter groupId was null or undefined when calling getGroup.'
                );
            }
            const localVarPath = `/groups/{groupId}`.replace(
                `{${'groupId'}}`,
                encodeURIComponent(String(groupId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get group and contacts belonging to it
         * @param {string} groupId groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupWithContacts(groupId: string, options: any = {}): FetchArgs {
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError(
                    'groupId',
                    'Required parameter groupId was null or undefined when calling getGroupWithContacts.'
                );
            }
            const localVarPath = `/groups/{groupId}/contacts`.replace(
                `{${'groupId'}}`,
                encodeURIComponent(String(groupId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get group and paginated contacts belonging to it
         * @param {string} groupId groupId
         * @param {number} [page] Optional page index in group contact pagination
         * @param {number} [size] Optional page size in group contact pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupWithContactsPaginated(
            groupId: string,
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError(
                    'groupId',
                    'Required parameter groupId was null or undefined when calling getGroupWithContactsPaginated.'
                );
            }
            const localVarPath = `/groups/{groupId}/contacts-paginated`.replace(
                `{${'groupId'}}`,
                encodeURIComponent(String(groupId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups(options: any = {}): FetchArgs {
            const localVarPath = `/groups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Remove contacts from a group
         * @param {string} groupId groupId
         * @param {UpdateGroupContacts} updateGroupContactsOption updateGroupContactsOption
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeContactsFromGroup(
            groupId: string,
            updateGroupContactsOption: UpdateGroupContacts,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError(
                    'groupId',
                    'Required parameter groupId was null or undefined when calling removeContactsFromGroup.'
                );
            }
            // verify required parameter 'updateGroupContactsOption' is not null or undefined
            if (
                updateGroupContactsOption === null ||
                updateGroupContactsOption === undefined
            ) {
                throw new RequiredError(
                    'updateGroupContactsOption',
                    'Required parameter updateGroupContactsOption was null or undefined when calling removeContactsFromGroup.'
                );
            }
            const localVarPath = `/groups/{groupId}/contacts`.replace(
                `{${'groupId'}}`,
                encodeURIComponent(String(groupId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'DELETE' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'UpdateGroupContacts' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(updateGroupContactsOption || {})
                : updateGroupContactsOption || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * GroupControllerApi - functional programming interface
 * @export
 */
export const GroupControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Add contacts to a group
         * @param {string} groupId groupId
         * @param {UpdateGroupContacts} updateGroupContactsOption updateGroupContactsOption
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addContactsToGroup(
            groupId: string,
            updateGroupContactsOption: UpdateGroupContacts,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<GroupContactsDto> {
            const localVarFetchArgs = GroupControllerApiFetchParamCreator(
                configuration
            ).addContactsToGroup(groupId, updateGroupContactsOption, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Create a group
         * @param {CreateGroupOptions} createGroupOptions createGroupOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(
            createGroupOptions: CreateGroupOptions,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<GroupDto> {
            const localVarFetchArgs = GroupControllerApiFetchParamCreator(
                configuration
            ).createGroup(createGroupOptions, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete group
         * @param {string} groupId groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(
            groupId: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = GroupControllerApiFetchParamCreator(
                configuration
            ).deleteGroup(groupId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all Contact Groups in paginated format
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllGroups(
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<PageGroupProjection> {
            const localVarFetchArgs = GroupControllerApiFetchParamCreator(
                configuration
            ).getAllGroups(page, size, sort, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get group
         * @param {string} groupId groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(
            groupId: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<GroupDto> {
            const localVarFetchArgs = GroupControllerApiFetchParamCreator(
                configuration
            ).getGroup(groupId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get group and contacts belonging to it
         * @param {string} groupId groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupWithContacts(
            groupId: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<GroupContactsDto> {
            const localVarFetchArgs = GroupControllerApiFetchParamCreator(
                configuration
            ).getGroupWithContacts(groupId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get group and paginated contacts belonging to it
         * @param {string} groupId groupId
         * @param {number} [page] Optional page index in group contact pagination
         * @param {number} [size] Optional page size in group contact pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupWithContactsPaginated(
            groupId: string,
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<PageContactProjection> {
            const localVarFetchArgs = GroupControllerApiFetchParamCreator(
                configuration
            ).getGroupWithContactsPaginated(groupId, page, size, sort, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups(
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<Array<GroupProjection>> {
            const localVarFetchArgs = GroupControllerApiFetchParamCreator(
                configuration
            ).getGroups(options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Remove contacts from a group
         * @param {string} groupId groupId
         * @param {UpdateGroupContacts} updateGroupContactsOption updateGroupContactsOption
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeContactsFromGroup(
            groupId: string,
            updateGroupContactsOption: UpdateGroupContacts,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<GroupContactsDto> {
            const localVarFetchArgs = GroupControllerApiFetchParamCreator(
                configuration
            ).removeContactsFromGroup(
                groupId,
                updateGroupContactsOption,
                options
            );
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    };
};

/**
 * GroupControllerApi - factory interface
 * @export
 */
export const GroupControllerApiFactory = function(
    configuration?: Configuration,
    fetch?: FetchAPI,
    basePath?: string
) {
    return {
        /**
         *
         * @summary Add contacts to a group
         * @param {string} groupId groupId
         * @param {UpdateGroupContacts} updateGroupContactsOption updateGroupContactsOption
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addContactsToGroup(
            groupId: string,
            updateGroupContactsOption: UpdateGroupContacts,
            options?: any
        ) {
            return GroupControllerApiFp(configuration).addContactsToGroup(
                groupId,
                updateGroupContactsOption,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Create a group
         * @param {CreateGroupOptions} createGroupOptions createGroupOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(createGroupOptions: CreateGroupOptions, options?: any) {
            return GroupControllerApiFp(configuration).createGroup(
                createGroupOptions,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Delete group
         * @param {string} groupId groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(groupId: string, options?: any) {
            return GroupControllerApiFp(configuration).deleteGroup(
                groupId,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Get all Contact Groups in paginated format
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllGroups(
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ) {
            return GroupControllerApiFp(configuration).getAllGroups(
                page,
                size,
                sort,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Get group
         * @param {string} groupId groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(groupId: string, options?: any) {
            return GroupControllerApiFp(configuration).getGroup(
                groupId,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Get group and contacts belonging to it
         * @param {string} groupId groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupWithContacts(groupId: string, options?: any) {
            return GroupControllerApiFp(configuration).getGroupWithContacts(
                groupId,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Get group and paginated contacts belonging to it
         * @param {string} groupId groupId
         * @param {number} [page] Optional page index in group contact pagination
         * @param {number} [size] Optional page size in group contact pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupWithContactsPaginated(
            groupId: string,
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ) {
            return GroupControllerApiFp(
                configuration
            ).getGroupWithContactsPaginated(groupId, page, size, sort, options)(
                fetch,
                basePath
            );
        },
        /**
         *
         * @summary Get all groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups(options?: any) {
            return GroupControllerApiFp(configuration).getGroups(options)(
                fetch,
                basePath
            );
        },
        /**
         *
         * @summary Remove contacts from a group
         * @param {string} groupId groupId
         * @param {UpdateGroupContacts} updateGroupContactsOption updateGroupContactsOption
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeContactsFromGroup(
            groupId: string,
            updateGroupContactsOption: UpdateGroupContacts,
            options?: any
        ) {
            return GroupControllerApiFp(configuration).removeContactsFromGroup(
                groupId,
                updateGroupContactsOption,
                options
            )(fetch, basePath);
        },
    };
};

/**
 * GroupControllerApi - object-oriented interface
 * @export
 * @class GroupControllerApi
 * @extends {BaseAPI}
 */
export class GroupControllerApi extends BaseAPI {
    /**
     *
     * @summary Add contacts to a group
     * @param {string} groupId groupId
     * @param {UpdateGroupContacts} updateGroupContactsOption updateGroupContactsOption
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupControllerApi
     */
    public addContactsToGroup(
        groupId: string,
        updateGroupContactsOption: UpdateGroupContacts,
        options?: any
    ) {
        return GroupControllerApiFp(this.configuration).addContactsToGroup(
            groupId,
            updateGroupContactsOption,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Create a group
     * @param {CreateGroupOptions} createGroupOptions createGroupOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupControllerApi
     */
    public createGroup(createGroupOptions: CreateGroupOptions, options?: any) {
        return GroupControllerApiFp(this.configuration).createGroup(
            createGroupOptions,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Delete group
     * @param {string} groupId groupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupControllerApi
     */
    public deleteGroup(groupId: string, options?: any) {
        return GroupControllerApiFp(this.configuration).deleteGroup(
            groupId,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get all Contact Groups in paginated format
     * @param {number} [page] Optional page index in inbox list pagination
     * @param {number} [size] Optional page size in inbox list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupControllerApi
     */
    public getAllGroups(
        page?: number,
        size?: number,
        sort?: 'ASC' | 'DESC',
        options?: any
    ) {
        return GroupControllerApiFp(this.configuration).getAllGroups(
            page,
            size,
            sort,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get group
     * @param {string} groupId groupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupControllerApi
     */
    public getGroup(groupId: string, options?: any) {
        return GroupControllerApiFp(this.configuration).getGroup(
            groupId,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get group and contacts belonging to it
     * @param {string} groupId groupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupControllerApi
     */
    public getGroupWithContacts(groupId: string, options?: any) {
        return GroupControllerApiFp(this.configuration).getGroupWithContacts(
            groupId,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get group and paginated contacts belonging to it
     * @param {string} groupId groupId
     * @param {number} [page] Optional page index in group contact pagination
     * @param {number} [size] Optional page size in group contact pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupControllerApi
     */
    public getGroupWithContactsPaginated(
        groupId: string,
        page?: number,
        size?: number,
        sort?: 'ASC' | 'DESC',
        options?: any
    ) {
        return GroupControllerApiFp(
            this.configuration
        ).getGroupWithContactsPaginated(groupId, page, size, sort, options)(
            this.fetch,
            this.basePath
        );
    }

    /**
     *
     * @summary Get all groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupControllerApi
     */
    public getGroups(options?: any) {
        return GroupControllerApiFp(this.configuration).getGroups(options)(
            this.fetch,
            this.basePath
        );
    }

    /**
     *
     * @summary Remove contacts from a group
     * @param {string} groupId groupId
     * @param {UpdateGroupContacts} updateGroupContactsOption updateGroupContactsOption
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupControllerApi
     */
    public removeContactsFromGroup(
        groupId: string,
        updateGroupContactsOption: UpdateGroupContacts,
        options?: any
    ) {
        return GroupControllerApiFp(this.configuration).removeContactsFromGroup(
            groupId,
            updateGroupContactsOption,
            options
        )(this.fetch, this.basePath);
    }
}

/**
 * InboxControllerApi - fetch parameter creator
 * @export
 */
export const InboxControllerApiFetchParamCreator = function(
    configuration?: Configuration
) {
    return {
        /**
         * Create a new inbox and with a randomized email address to send and receive from. Pass emailAddress parameter if you wish to use a specific email address. Creating an inbox is required before sending or receiving emails. If writing tests it is recommended that you create a new inbox during each test method so that it is unique and empty.
         * @summary Create an inbox email address. An inbox has a real email address and can send and receive emails. Inboxes can be either `SMTP` or `HTTP` inboxes.
         * @param {boolean} [allowTeamAccess] Grant team access to this inbox and the emails that belong to it for team members of your organization.
         * @param {string} [description] Optional description of the inbox for labelling purposes. Is shown in the dashboard and can be used with
         * @param {string} [emailAddress] A custom email address to use with the inbox. Defaults to null. When null MailSlurp will assign a random email address to the inbox such as &#x60;123@mailslurp.com&#x60;. If you use the &#x60;useDomainPool&#x60; option when the email address is null it will generate an email address with a more varied domain ending such as &#x60;123@mailslurp.info&#x60; or &#x60;123@mailslurp.biz&#x60;. When a custom email address is provided the address is split into a domain and the domain is queried against your user. If you have created the domain in the MailSlurp dashboard and verified it you can use any email address that ends with the domain. Note domain types must match the inbox type - so &#x60;SMTP&#x60; inboxes will only work with &#x60;SMTP&#x60; type domains. Send an email to this address and the inbox will receive and store it for you. To retrieve the email use the Inbox and Email Controller endpoints with the inbox ID.
         * @param {Date} [expiresAt] Optional inbox expiration date. If null then this inbox is permanent and the emails in it won&#39;t be deleted. If an expiration date is provided or is required by your plan the inbox will be closed when the expiration time is reached. Expired inboxes still contain their emails but can no longer send or receive emails. An ExpiredInboxRecord is created when an inbox and the email address and inbox ID are recorded. The expiresAt property is a timestamp string in ISO DateTime Format yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSXXX.
         * @param {number} [expiresIn] Number of milliseconds that inbox should exist for
         * @param {boolean} [favourite] Is the inbox a favorite. Marking an inbox as a favorite is typically done in the dashboard for quick access or filtering
         * @param {'HTTP_INBOX' | 'SMTP_INBOX'} [inboxType] HTTP (default) or SMTP inbox type. HTTP inboxes are best for testing while SMTP inboxes are more reliable for public inbound email consumption. When using custom domains the domain type must match the inbox type. HTTP inboxes are processed by AWS SES while SMTP inboxes use a custom mail server running at &#x60;mx.mailslurp.com&#x60;.
         * @param {string} [name] Optional name of the inbox. Displayed in the dashboard for easier search and used as the sender name when sending emails.
         * @param {Array<string>} [tags] Tags that inbox has been tagged with. Tags can be added to inboxes to group different inboxes within an account. You can also search for inboxes by tag in the dashboard UI.
         * @param {boolean} [useDomainPool] Use the MailSlurp domain name pool with this inbox when creating the email address. Defaults to null. If enabled the inbox will be an email address with a domain randomly chosen from a list of the MailSlurp domains. This is useful when the default &#x60;@mailslurp.com&#x60; email addresses used with inboxes are blocked or considered spam by a provider or receiving service. When domain pool is enabled an email address will be generated ending in &#x60;@mailslurp.{world,info,xyz,...}&#x60; . This means a TLD is randomly selecting from a list of &#x60;.biz&#x60;, &#x60;.info&#x60;, &#x60;.xyz&#x60; etc to add variance to the generated email addresses. When null or false MailSlurp uses the default behavior of &#x60;@mailslurp.com&#x60; or custom email address provided by the emailAddress field. Note this feature is only available for &#x60;HTTP&#x60; inbox types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInbox(
            allowTeamAccess?: boolean,
            description?: string,
            emailAddress?: string,
            expiresAt?: Date,
            expiresIn?: number,
            favourite?: boolean,
            inboxType?: 'HTTP_INBOX' | 'SMTP_INBOX',
            name?: string,
            tags?: Array<string>,
            useDomainPool?: boolean,
            options: any = {}
        ): FetchArgs {
            const localVarPath = `/inboxes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (allowTeamAccess !== undefined) {
                localVarQueryParameter['allowTeamAccess'] = allowTeamAccess;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (emailAddress !== undefined) {
                localVarQueryParameter['emailAddress'] = emailAddress;
            }

            if (expiresAt !== undefined) {
                localVarQueryParameter[
                    'expiresAt'
                ] = (expiresAt as any).toISOString();
            }

            if (expiresIn !== undefined) {
                localVarQueryParameter['expiresIn'] = expiresIn;
            }

            if (favourite !== undefined) {
                localVarQueryParameter['favourite'] = favourite;
            }

            if (inboxType !== undefined) {
                localVarQueryParameter['inboxType'] = inboxType;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (useDomainPool !== undefined) {
                localVarQueryParameter['useDomainPool'] = useDomainPool;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create an inbox with default options. Uses MailSlurp domain pool address and is private.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInboxWithDefaults(options: any = {}): FetchArgs {
            const localVarPath = `/inboxes/withDefaults`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Additional endpoint that allows inbox creation with request body options. Can be more flexible that other methods for some clients.
         * @summary Create an inbox with options. Extended options for inbox creation.
         * @param {CreateInboxDto} createInboxDto createInboxDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInboxWithOptions(
            createInboxDto: CreateInboxDto,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'createInboxDto' is not null or undefined
            if (createInboxDto === null || createInboxDto === undefined) {
                throw new RequiredError(
                    'createInboxDto',
                    'Required parameter createInboxDto was null or undefined when calling createInboxWithOptions.'
                );
            }
            const localVarPath = `/inboxes/withOptions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'CreateInboxDto' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(createInboxDto || {})
                : createInboxDto || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently delete all inboxes and associated email addresses. This will also delete all emails within the inboxes. Be careful as inboxes cannot be recovered once deleted. Note: deleting inboxes will not impact your usage limits. Monthly inbox creation limits are based on how many inboxes were created in the last 30 days, not how many inboxes you currently have.
         * @summary Delete all inboxes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllInboxes(options: any = {}): FetchArgs {
            const localVarPath = `/inboxes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'DELETE' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently delete an inbox and associated email address as well as all emails within the given inbox. This action cannot be undone. Note: deleting an inbox will not affect your account usage. Monthly inbox usage is based on how many inboxes you create within 30 days, not how many exist at time of request.
         * @summary Delete inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInbox(inboxId: string, options: any = {}): FetchArgs {
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError(
                    'inboxId',
                    'Required parameter inboxId was null or undefined when calling deleteInbox.'
                );
            }
            const localVarPath = `/inboxes/{inboxId}`.replace(
                `{${'inboxId'}}`,
                encodeURIComponent(String(inboxId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'DELETE' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List inboxes in paginated form. The results are available on the `content` property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). You Can also filter by whether an inbox is favorited or use email address pattern. This method is the recommended way to query inboxes. The alternative `getInboxes` method returns a full list of inboxes but is limited to 100 results. Results do not include team access inboxes by default. Use organization method to list team inboxes or set `teamAccess` to true.
         * @summary List All Inboxes Paginated
         * @param {boolean} [favourite] Optionally filter results for favourites only
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {string} [search] Optionally filter by search words partial matching ID, tags, name, and email address
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {string} [tag] Optionally filter by tags. Will return inboxes that include given tags
         * @param {boolean} [teamAccess] Optionally filter by team access. Defaults to false so organization inboxes are not included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllInboxes(
            favourite?: boolean,
            page?: number,
            search?: string,
            size?: number,
            sort?: 'ASC' | 'DESC',
            tag?: string,
            teamAccess?: boolean,
            options: any = {}
        ): FetchArgs {
            const localVarPath = `/inboxes/paginated`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (favourite !== undefined) {
                localVarQueryParameter['favourite'] = favourite;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (teamAccess !== undefined) {
                localVarQueryParameter['teamAccess'] = teamAccess;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List emails that an inbox has received. Only emails that are sent to the inbox's email address will appear in the inbox. It may take several seconds for any email you send to an inbox's email address to appear in the inbox. To make this endpoint wait for a minimum number of emails use the `minCount` parameter. The server will retry the inbox database until the `minCount` is satisfied or the `retryTimeout` is reached
         * @summary Get emails in an Inbox. This method is not idempotent as it allows retries and waits if you want certain conditions to be met before returning. For simple listing and sorting of known emails use the email controller instead.
         * @param {string} inboxId Id of inbox that emails belongs to
         * @param {number} [limit] Limit the result set, ordered by received date time sort direction. Maximum 100. For more listing options see the email controller
         * @param {number} [minCount] Minimum acceptable email count. Will cause request to hang (and retry) until minCount is satisfied or retryTimeout is reached.
         * @param {number} [retryTimeout] Maximum milliseconds to spend retrying inbox database until minCount emails are returned
         * @param {Date} [since] Exclude emails received before this ISO 8601 date time
         * @param {number} [size] Alias for limit. Assessed first before assessing any passed limit.
         * @param {'ASC' | 'DESC'} [sort] Sort the results by received date and direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmails(
            inboxId: string,
            limit?: number,
            minCount?: number,
            retryTimeout?: number,
            since?: Date,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError(
                    'inboxId',
                    'Required parameter inboxId was null or undefined when calling getEmails.'
                );
            }
            const localVarPath = `/inboxes/{inboxId}/emails`.replace(
                `{${'inboxId'}}`,
                encodeURIComponent(String(inboxId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (minCount !== undefined) {
                localVarQueryParameter['minCount'] = minCount;
            }

            if (retryTimeout !== undefined) {
                localVarQueryParameter['retryTimeout'] = retryTimeout;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = (since as any).toISOString();
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an inbox's properties, including its email address and ID.
         * @summary Get Inbox. Returns properties of an inbox.
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInbox(inboxId: string, options: any = {}): FetchArgs {
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError(
                    'inboxId',
                    'Required parameter inboxId was null or undefined when calling getInbox.'
                );
            }
            const localVarPath = `/inboxes/{inboxId}`.replace(
                `{${'inboxId'}}`,
                encodeURIComponent(String(inboxId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a paginated list of emails in an inbox. Does not hold connections open.
         * @summary Get inbox emails paginated
         * @param {string} inboxId Id of inbox that emails belongs to
         * @param {number} [page] Optional page index in inbox emails list pagination
         * @param {number} [size] Optional page size in inbox emails list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxEmailsPaginated(
            inboxId: string,
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError(
                    'inboxId',
                    'Required parameter inboxId was null or undefined when calling getInboxEmailsPaginated.'
                );
            }
            const localVarPath = `/inboxes/{inboxId}/emails/paginated`.replace(
                `{${'inboxId'}}`,
                encodeURIComponent(String(inboxId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an inbox's sent email receipts. Call individual sent email endpoints for more details. Note for privacy reasons the full body of sent emails is never stored. An MD5 hash hex is available for comparison instead.
         * @summary Get Inbox Sent Emails
         * @param {string} inboxId inboxId
         * @param {number} [page] Optional page index in inbox sent email list pagination
         * @param {number} [size] Optional page size in inbox sent email list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxSentEmails(
            inboxId: string,
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError(
                    'inboxId',
                    'Required parameter inboxId was null or undefined when calling getInboxSentEmails.'
                );
            }
            const localVarPath = `/inboxes/{inboxId}/sent`.replace(
                `{${'inboxId'}}`,
                encodeURIComponent(String(inboxId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all inbox tags
         * @summary Get inbox tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxTags(options: any = {}): FetchArgs {
            const localVarPath = `/inboxes/tags`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the inboxes you have created. Note use of the more advanced `getAllEmails` is recommended. You can provide a limit and sort parameter.
         * @summary List Inboxes and email eddresses
         * @param {number} [size] Optional result size limit. Note an automatic limit of 100 results is applied. See the paginated &#x60;getAllEmails&#x60; for larger queries.
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxes(
            size?: number,
            sort?: 'ASC' | 'DESC',
            options: any = {}
        ): FetchArgs {
            const localVarPath = `/inboxes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List organization inboxes in paginated form. These are inboxes created with `allowTeamAccess` flag enabled. Organization inboxes are `readOnly` for non-admin users. The results are available on the `content` property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time).
         * @summary List Organization Inboxes Paginated
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationInboxes(
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options: any = {}
        ): FetchArgs {
            const localVarPath = `/inboxes/organization`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send an email from an inbox's email address.  The request body should contain the `SendEmailOptions` that include recipients, attachments, body etc. See `SendEmailOptions` for all available properties. Note the `inboxId` refers to the inbox's id not the inbox's email address. See https://www.mailslurp.com/guides/ for more information on how to send emails. This method does not return a sent email entity due to legacy reasons. To send and get a sent email as returned response use the sister method `sendEmailAndConfirm`.
         * @summary Send Email
         * @param {string} inboxId ID of the inbox you want to send the email from
         * @param {SendEmailOptions} [sendEmailOptions] Options for the email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmail(
            inboxId: string,
            sendEmailOptions?: SendEmailOptions,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError(
                    'inboxId',
                    'Required parameter inboxId was null or undefined when calling sendEmail.'
                );
            }
            const localVarPath = `/inboxes/{inboxId}`.replace(
                `{${'inboxId'}}`,
                encodeURIComponent(String(inboxId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'SendEmailOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(sendEmailOptions || {})
                : sendEmailOptions || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sister method for standard `sendEmail` method with the benefit of returning a `SentEmail` entity confirming the successful sending of the email with a link to the sent object created for it.
         * @summary Send email and return sent confirmation
         * @param {string} inboxId ID of the inbox you want to send the email from
         * @param {SendEmailOptions} [sendEmailOptions] Options for the email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailAndConfirm(
            inboxId: string,
            sendEmailOptions?: SendEmailOptions,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError(
                    'inboxId',
                    'Required parameter inboxId was null or undefined when calling sendEmailAndConfirm.'
                );
            }
            const localVarPath = `/inboxes/{inboxId}/confirm`.replace(
                `{${'inboxId'}}`,
                encodeURIComponent(String(inboxId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'SendEmailOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(sendEmailOptions || {})
                : sendEmailOptions || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send an inbox a test email to test email receiving is working
         * @summary Send a test email to inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTestEmail(inboxId: string, options: any = {}): FetchArgs {
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError(
                    'inboxId',
                    'Required parameter inboxId was null or undefined when calling sendTestEmail.'
                );
            }
            const localVarPath = `/inboxes/{inboxId}/send-test-email`.replace(
                `{${'inboxId'}}`,
                encodeURIComponent(String(inboxId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set and return new favourite state for an inbox
         * @summary Set inbox favourited state
         * @param {string} inboxId inboxId
         * @param {SetInboxFavouritedOptions} setInboxFavouritedOptions setInboxFavouritedOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setInboxFavourited(
            inboxId: string,
            setInboxFavouritedOptions: SetInboxFavouritedOptions,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError(
                    'inboxId',
                    'Required parameter inboxId was null or undefined when calling setInboxFavourited.'
                );
            }
            // verify required parameter 'setInboxFavouritedOptions' is not null or undefined
            if (
                setInboxFavouritedOptions === null ||
                setInboxFavouritedOptions === undefined
            ) {
                throw new RequiredError(
                    'setInboxFavouritedOptions',
                    'Required parameter setInboxFavouritedOptions was null or undefined when calling setInboxFavourited.'
                );
            }
            const localVarPath = `/inboxes/{inboxId}/favourite`.replace(
                `{${'inboxId'}}`,
                encodeURIComponent(String(inboxId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'PUT' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'SetInboxFavouritedOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(setInboxFavouritedOptions || {})
                : setInboxFavouritedOptions || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update editable fields on an inbox
         * @summary Update Inbox. Change name and description. Email address is not editable.
         * @param {string} inboxId inboxId
         * @param {UpdateInboxOptions} updateInboxOptions updateInboxOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInbox(
            inboxId: string,
            updateInboxOptions: UpdateInboxOptions,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError(
                    'inboxId',
                    'Required parameter inboxId was null or undefined when calling updateInbox.'
                );
            }
            // verify required parameter 'updateInboxOptions' is not null or undefined
            if (
                updateInboxOptions === null ||
                updateInboxOptions === undefined
            ) {
                throw new RequiredError(
                    'updateInboxOptions',
                    'Required parameter updateInboxOptions was null or undefined when calling updateInbox.'
                );
            }
            const localVarPath = `/inboxes/{inboxId}`.replace(
                `{${'inboxId'}}`,
                encodeURIComponent(String(inboxId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'PATCH' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'UpdateInboxOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(updateInboxOptions || {})
                : updateInboxOptions || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * InboxControllerApi - functional programming interface
 * @export
 */
export const InboxControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a new inbox and with a randomized email address to send and receive from. Pass emailAddress parameter if you wish to use a specific email address. Creating an inbox is required before sending or receiving emails. If writing tests it is recommended that you create a new inbox during each test method so that it is unique and empty.
         * @summary Create an inbox email address. An inbox has a real email address and can send and receive emails. Inboxes can be either `SMTP` or `HTTP` inboxes.
         * @param {boolean} [allowTeamAccess] Grant team access to this inbox and the emails that belong to it for team members of your organization.
         * @param {string} [description] Optional description of the inbox for labelling purposes. Is shown in the dashboard and can be used with
         * @param {string} [emailAddress] A custom email address to use with the inbox. Defaults to null. When null MailSlurp will assign a random email address to the inbox such as &#x60;123@mailslurp.com&#x60;. If you use the &#x60;useDomainPool&#x60; option when the email address is null it will generate an email address with a more varied domain ending such as &#x60;123@mailslurp.info&#x60; or &#x60;123@mailslurp.biz&#x60;. When a custom email address is provided the address is split into a domain and the domain is queried against your user. If you have created the domain in the MailSlurp dashboard and verified it you can use any email address that ends with the domain. Note domain types must match the inbox type - so &#x60;SMTP&#x60; inboxes will only work with &#x60;SMTP&#x60; type domains. Send an email to this address and the inbox will receive and store it for you. To retrieve the email use the Inbox and Email Controller endpoints with the inbox ID.
         * @param {Date} [expiresAt] Optional inbox expiration date. If null then this inbox is permanent and the emails in it won&#39;t be deleted. If an expiration date is provided or is required by your plan the inbox will be closed when the expiration time is reached. Expired inboxes still contain their emails but can no longer send or receive emails. An ExpiredInboxRecord is created when an inbox and the email address and inbox ID are recorded. The expiresAt property is a timestamp string in ISO DateTime Format yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSXXX.
         * @param {number} [expiresIn] Number of milliseconds that inbox should exist for
         * @param {boolean} [favourite] Is the inbox a favorite. Marking an inbox as a favorite is typically done in the dashboard for quick access or filtering
         * @param {'HTTP_INBOX' | 'SMTP_INBOX'} [inboxType] HTTP (default) or SMTP inbox type. HTTP inboxes are best for testing while SMTP inboxes are more reliable for public inbound email consumption. When using custom domains the domain type must match the inbox type. HTTP inboxes are processed by AWS SES while SMTP inboxes use a custom mail server running at &#x60;mx.mailslurp.com&#x60;.
         * @param {string} [name] Optional name of the inbox. Displayed in the dashboard for easier search and used as the sender name when sending emails.
         * @param {Array<string>} [tags] Tags that inbox has been tagged with. Tags can be added to inboxes to group different inboxes within an account. You can also search for inboxes by tag in the dashboard UI.
         * @param {boolean} [useDomainPool] Use the MailSlurp domain name pool with this inbox when creating the email address. Defaults to null. If enabled the inbox will be an email address with a domain randomly chosen from a list of the MailSlurp domains. This is useful when the default &#x60;@mailslurp.com&#x60; email addresses used with inboxes are blocked or considered spam by a provider or receiving service. When domain pool is enabled an email address will be generated ending in &#x60;@mailslurp.{world,info,xyz,...}&#x60; . This means a TLD is randomly selecting from a list of &#x60;.biz&#x60;, &#x60;.info&#x60;, &#x60;.xyz&#x60; etc to add variance to the generated email addresses. When null or false MailSlurp uses the default behavior of &#x60;@mailslurp.com&#x60; or custom email address provided by the emailAddress field. Note this feature is only available for &#x60;HTTP&#x60; inbox types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInbox(
            allowTeamAccess?: boolean,
            description?: string,
            emailAddress?: string,
            expiresAt?: Date,
            expiresIn?: number,
            favourite?: boolean,
            inboxType?: 'HTTP_INBOX' | 'SMTP_INBOX',
            name?: string,
            tags?: Array<string>,
            useDomainPool?: boolean,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Inbox> {
            const localVarFetchArgs = InboxControllerApiFetchParamCreator(
                configuration
            ).createInbox(
                allowTeamAccess,
                description,
                emailAddress,
                expiresAt,
                expiresIn,
                favourite,
                inboxType,
                name,
                tags,
                useDomainPool,
                options
            );
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Create an inbox with default options. Uses MailSlurp domain pool address and is private.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInboxWithDefaults(
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Inbox> {
            const localVarFetchArgs = InboxControllerApiFetchParamCreator(
                configuration
            ).createInboxWithDefaults(options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Additional endpoint that allows inbox creation with request body options. Can be more flexible that other methods for some clients.
         * @summary Create an inbox with options. Extended options for inbox creation.
         * @param {CreateInboxDto} createInboxDto createInboxDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInboxWithOptions(
            createInboxDto: CreateInboxDto,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Inbox> {
            const localVarFetchArgs = InboxControllerApiFetchParamCreator(
                configuration
            ).createInboxWithOptions(createInboxDto, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Permanently delete all inboxes and associated email addresses. This will also delete all emails within the inboxes. Be careful as inboxes cannot be recovered once deleted. Note: deleting inboxes will not impact your usage limits. Monthly inbox creation limits are based on how many inboxes were created in the last 30 days, not how many inboxes you currently have.
         * @summary Delete all inboxes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllInboxes(
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = InboxControllerApiFetchParamCreator(
                configuration
            ).deleteAllInboxes(options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Permanently delete an inbox and associated email address as well as all emails within the given inbox. This action cannot be undone. Note: deleting an inbox will not affect your account usage. Monthly inbox usage is based on how many inboxes you create within 30 days, not how many exist at time of request.
         * @summary Delete inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInbox(
            inboxId: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = InboxControllerApiFetchParamCreator(
                configuration
            ).deleteInbox(inboxId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List inboxes in paginated form. The results are available on the `content` property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). You Can also filter by whether an inbox is favorited or use email address pattern. This method is the recommended way to query inboxes. The alternative `getInboxes` method returns a full list of inboxes but is limited to 100 results. Results do not include team access inboxes by default. Use organization method to list team inboxes or set `teamAccess` to true.
         * @summary List All Inboxes Paginated
         * @param {boolean} [favourite] Optionally filter results for favourites only
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {string} [search] Optionally filter by search words partial matching ID, tags, name, and email address
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {string} [tag] Optionally filter by tags. Will return inboxes that include given tags
         * @param {boolean} [teamAccess] Optionally filter by team access. Defaults to false so organization inboxes are not included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllInboxes(
            favourite?: boolean,
            page?: number,
            search?: string,
            size?: number,
            sort?: 'ASC' | 'DESC',
            tag?: string,
            teamAccess?: boolean,
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<PageInboxProjection> {
            const localVarFetchArgs = InboxControllerApiFetchParamCreator(
                configuration
            ).getAllInboxes(
                favourite,
                page,
                search,
                size,
                sort,
                tag,
                teamAccess,
                options
            );
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List emails that an inbox has received. Only emails that are sent to the inbox's email address will appear in the inbox. It may take several seconds for any email you send to an inbox's email address to appear in the inbox. To make this endpoint wait for a minimum number of emails use the `minCount` parameter. The server will retry the inbox database until the `minCount` is satisfied or the `retryTimeout` is reached
         * @summary Get emails in an Inbox. This method is not idempotent as it allows retries and waits if you want certain conditions to be met before returning. For simple listing and sorting of known emails use the email controller instead.
         * @param {string} inboxId Id of inbox that emails belongs to
         * @param {number} [limit] Limit the result set, ordered by received date time sort direction. Maximum 100. For more listing options see the email controller
         * @param {number} [minCount] Minimum acceptable email count. Will cause request to hang (and retry) until minCount is satisfied or retryTimeout is reached.
         * @param {number} [retryTimeout] Maximum milliseconds to spend retrying inbox database until minCount emails are returned
         * @param {Date} [since] Exclude emails received before this ISO 8601 date time
         * @param {number} [size] Alias for limit. Assessed first before assessing any passed limit.
         * @param {'ASC' | 'DESC'} [sort] Sort the results by received date and direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmails(
            inboxId: string,
            limit?: number,
            minCount?: number,
            retryTimeout?: number,
            since?: Date,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<Array<EmailPreview>> {
            const localVarFetchArgs = InboxControllerApiFetchParamCreator(
                configuration
            ).getEmails(
                inboxId,
                limit,
                minCount,
                retryTimeout,
                since,
                size,
                sort,
                options
            );
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns an inbox's properties, including its email address and ID.
         * @summary Get Inbox. Returns properties of an inbox.
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInbox(
            inboxId: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Inbox> {
            const localVarFetchArgs = InboxControllerApiFetchParamCreator(
                configuration
            ).getInbox(inboxId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a paginated list of emails in an inbox. Does not hold connections open.
         * @summary Get inbox emails paginated
         * @param {string} inboxId Id of inbox that emails belongs to
         * @param {number} [page] Optional page index in inbox emails list pagination
         * @param {number} [size] Optional page size in inbox emails list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxEmailsPaginated(
            inboxId: string,
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<PageEmailPreview> {
            const localVarFetchArgs = InboxControllerApiFetchParamCreator(
                configuration
            ).getInboxEmailsPaginated(inboxId, page, size, sort, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns an inbox's sent email receipts. Call individual sent email endpoints for more details. Note for privacy reasons the full body of sent emails is never stored. An MD5 hash hex is available for comparison instead.
         * @summary Get Inbox Sent Emails
         * @param {string} inboxId inboxId
         * @param {number} [page] Optional page index in inbox sent email list pagination
         * @param {number} [size] Optional page size in inbox sent email list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxSentEmails(
            inboxId: string,
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<PageSentEmailProjection> {
            const localVarFetchArgs = InboxControllerApiFetchParamCreator(
                configuration
            ).getInboxSentEmails(inboxId, page, size, sort, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get all inbox tags
         * @summary Get inbox tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxTags(
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = InboxControllerApiFetchParamCreator(
                configuration
            ).getInboxTags(options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List the inboxes you have created. Note use of the more advanced `getAllEmails` is recommended. You can provide a limit and sort parameter.
         * @summary List Inboxes and email eddresses
         * @param {number} [size] Optional result size limit. Note an automatic limit of 100 results is applied. See the paginated &#x60;getAllEmails&#x60; for larger queries.
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxes(
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Inbox>> {
            const localVarFetchArgs = InboxControllerApiFetchParamCreator(
                configuration
            ).getInboxes(size, sort, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List organization inboxes in paginated form. These are inboxes created with `allowTeamAccess` flag enabled. Organization inboxes are `readOnly` for non-admin users. The results are available on the `content` property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time).
         * @summary List Organization Inboxes Paginated
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationInboxes(
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<PageOrganizationInboxProjection> {
            const localVarFetchArgs = InboxControllerApiFetchParamCreator(
                configuration
            ).getOrganizationInboxes(page, size, sort, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Send an email from an inbox's email address.  The request body should contain the `SendEmailOptions` that include recipients, attachments, body etc. See `SendEmailOptions` for all available properties. Note the `inboxId` refers to the inbox's id not the inbox's email address. See https://www.mailslurp.com/guides/ for more information on how to send emails. This method does not return a sent email entity due to legacy reasons. To send and get a sent email as returned response use the sister method `sendEmailAndConfirm`.
         * @summary Send Email
         * @param {string} inboxId ID of the inbox you want to send the email from
         * @param {SendEmailOptions} [sendEmailOptions] Options for the email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmail(
            inboxId: string,
            sendEmailOptions?: SendEmailOptions,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = InboxControllerApiFetchParamCreator(
                configuration
            ).sendEmail(inboxId, sendEmailOptions, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Sister method for standard `sendEmail` method with the benefit of returning a `SentEmail` entity confirming the successful sending of the email with a link to the sent object created for it.
         * @summary Send email and return sent confirmation
         * @param {string} inboxId ID of the inbox you want to send the email from
         * @param {SendEmailOptions} [sendEmailOptions] Options for the email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailAndConfirm(
            inboxId: string,
            sendEmailOptions?: SendEmailOptions,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<SentEmailDto> {
            const localVarFetchArgs = InboxControllerApiFetchParamCreator(
                configuration
            ).sendEmailAndConfirm(inboxId, sendEmailOptions, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Send an inbox a test email to test email receiving is working
         * @summary Send a test email to inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTestEmail(
            inboxId: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = InboxControllerApiFetchParamCreator(
                configuration
            ).sendTestEmail(inboxId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Set and return new favourite state for an inbox
         * @summary Set inbox favourited state
         * @param {string} inboxId inboxId
         * @param {SetInboxFavouritedOptions} setInboxFavouritedOptions setInboxFavouritedOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setInboxFavourited(
            inboxId: string,
            setInboxFavouritedOptions: SetInboxFavouritedOptions,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Inbox> {
            const localVarFetchArgs = InboxControllerApiFetchParamCreator(
                configuration
            ).setInboxFavourited(inboxId, setInboxFavouritedOptions, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update editable fields on an inbox
         * @summary Update Inbox. Change name and description. Email address is not editable.
         * @param {string} inboxId inboxId
         * @param {UpdateInboxOptions} updateInboxOptions updateInboxOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInbox(
            inboxId: string,
            updateInboxOptions: UpdateInboxOptions,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Inbox> {
            const localVarFetchArgs = InboxControllerApiFetchParamCreator(
                configuration
            ).updateInbox(inboxId, updateInboxOptions, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    };
};

/**
 * InboxControllerApi - factory interface
 * @export
 */
export const InboxControllerApiFactory = function(
    configuration?: Configuration,
    fetch?: FetchAPI,
    basePath?: string
) {
    return {
        /**
         * Create a new inbox and with a randomized email address to send and receive from. Pass emailAddress parameter if you wish to use a specific email address. Creating an inbox is required before sending or receiving emails. If writing tests it is recommended that you create a new inbox during each test method so that it is unique and empty.
         * @summary Create an inbox email address. An inbox has a real email address and can send and receive emails. Inboxes can be either `SMTP` or `HTTP` inboxes.
         * @param {boolean} [allowTeamAccess] Grant team access to this inbox and the emails that belong to it for team members of your organization.
         * @param {string} [description] Optional description of the inbox for labelling purposes. Is shown in the dashboard and can be used with
         * @param {string} [emailAddress] A custom email address to use with the inbox. Defaults to null. When null MailSlurp will assign a random email address to the inbox such as &#x60;123@mailslurp.com&#x60;. If you use the &#x60;useDomainPool&#x60; option when the email address is null it will generate an email address with a more varied domain ending such as &#x60;123@mailslurp.info&#x60; or &#x60;123@mailslurp.biz&#x60;. When a custom email address is provided the address is split into a domain and the domain is queried against your user. If you have created the domain in the MailSlurp dashboard and verified it you can use any email address that ends with the domain. Note domain types must match the inbox type - so &#x60;SMTP&#x60; inboxes will only work with &#x60;SMTP&#x60; type domains. Send an email to this address and the inbox will receive and store it for you. To retrieve the email use the Inbox and Email Controller endpoints with the inbox ID.
         * @param {Date} [expiresAt] Optional inbox expiration date. If null then this inbox is permanent and the emails in it won&#39;t be deleted. If an expiration date is provided or is required by your plan the inbox will be closed when the expiration time is reached. Expired inboxes still contain their emails but can no longer send or receive emails. An ExpiredInboxRecord is created when an inbox and the email address and inbox ID are recorded. The expiresAt property is a timestamp string in ISO DateTime Format yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSXXX.
         * @param {number} [expiresIn] Number of milliseconds that inbox should exist for
         * @param {boolean} [favourite] Is the inbox a favorite. Marking an inbox as a favorite is typically done in the dashboard for quick access or filtering
         * @param {'HTTP_INBOX' | 'SMTP_INBOX'} [inboxType] HTTP (default) or SMTP inbox type. HTTP inboxes are best for testing while SMTP inboxes are more reliable for public inbound email consumption. When using custom domains the domain type must match the inbox type. HTTP inboxes are processed by AWS SES while SMTP inboxes use a custom mail server running at &#x60;mx.mailslurp.com&#x60;.
         * @param {string} [name] Optional name of the inbox. Displayed in the dashboard for easier search and used as the sender name when sending emails.
         * @param {Array<string>} [tags] Tags that inbox has been tagged with. Tags can be added to inboxes to group different inboxes within an account. You can also search for inboxes by tag in the dashboard UI.
         * @param {boolean} [useDomainPool] Use the MailSlurp domain name pool with this inbox when creating the email address. Defaults to null. If enabled the inbox will be an email address with a domain randomly chosen from a list of the MailSlurp domains. This is useful when the default &#x60;@mailslurp.com&#x60; email addresses used with inboxes are blocked or considered spam by a provider or receiving service. When domain pool is enabled an email address will be generated ending in &#x60;@mailslurp.{world,info,xyz,...}&#x60; . This means a TLD is randomly selecting from a list of &#x60;.biz&#x60;, &#x60;.info&#x60;, &#x60;.xyz&#x60; etc to add variance to the generated email addresses. When null or false MailSlurp uses the default behavior of &#x60;@mailslurp.com&#x60; or custom email address provided by the emailAddress field. Note this feature is only available for &#x60;HTTP&#x60; inbox types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInbox(
            allowTeamAccess?: boolean,
            description?: string,
            emailAddress?: string,
            expiresAt?: Date,
            expiresIn?: number,
            favourite?: boolean,
            inboxType?: 'HTTP_INBOX' | 'SMTP_INBOX',
            name?: string,
            tags?: Array<string>,
            useDomainPool?: boolean,
            options?: any
        ) {
            return InboxControllerApiFp(configuration).createInbox(
                allowTeamAccess,
                description,
                emailAddress,
                expiresAt,
                expiresIn,
                favourite,
                inboxType,
                name,
                tags,
                useDomainPool,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Create an inbox with default options. Uses MailSlurp domain pool address and is private.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInboxWithDefaults(options?: any) {
            return InboxControllerApiFp(configuration).createInboxWithDefaults(
                options
            )(fetch, basePath);
        },
        /**
         * Additional endpoint that allows inbox creation with request body options. Can be more flexible that other methods for some clients.
         * @summary Create an inbox with options. Extended options for inbox creation.
         * @param {CreateInboxDto} createInboxDto createInboxDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInboxWithOptions(createInboxDto: CreateInboxDto, options?: any) {
            return InboxControllerApiFp(configuration).createInboxWithOptions(
                createInboxDto,
                options
            )(fetch, basePath);
        },
        /**
         * Permanently delete all inboxes and associated email addresses. This will also delete all emails within the inboxes. Be careful as inboxes cannot be recovered once deleted. Note: deleting inboxes will not impact your usage limits. Monthly inbox creation limits are based on how many inboxes were created in the last 30 days, not how many inboxes you currently have.
         * @summary Delete all inboxes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllInboxes(options?: any) {
            return InboxControllerApiFp(configuration).deleteAllInboxes(
                options
            )(fetch, basePath);
        },
        /**
         * Permanently delete an inbox and associated email address as well as all emails within the given inbox. This action cannot be undone. Note: deleting an inbox will not affect your account usage. Monthly inbox usage is based on how many inboxes you create within 30 days, not how many exist at time of request.
         * @summary Delete inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInbox(inboxId: string, options?: any) {
            return InboxControllerApiFp(configuration).deleteInbox(
                inboxId,
                options
            )(fetch, basePath);
        },
        /**
         * List inboxes in paginated form. The results are available on the `content` property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). You Can also filter by whether an inbox is favorited or use email address pattern. This method is the recommended way to query inboxes. The alternative `getInboxes` method returns a full list of inboxes but is limited to 100 results. Results do not include team access inboxes by default. Use organization method to list team inboxes or set `teamAccess` to true.
         * @summary List All Inboxes Paginated
         * @param {boolean} [favourite] Optionally filter results for favourites only
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {string} [search] Optionally filter by search words partial matching ID, tags, name, and email address
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {string} [tag] Optionally filter by tags. Will return inboxes that include given tags
         * @param {boolean} [teamAccess] Optionally filter by team access. Defaults to false so organization inboxes are not included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllInboxes(
            favourite?: boolean,
            page?: number,
            search?: string,
            size?: number,
            sort?: 'ASC' | 'DESC',
            tag?: string,
            teamAccess?: boolean,
            options?: any
        ) {
            return InboxControllerApiFp(configuration).getAllInboxes(
                favourite,
                page,
                search,
                size,
                sort,
                tag,
                teamAccess,
                options
            )(fetch, basePath);
        },
        /**
         * List emails that an inbox has received. Only emails that are sent to the inbox's email address will appear in the inbox. It may take several seconds for any email you send to an inbox's email address to appear in the inbox. To make this endpoint wait for a minimum number of emails use the `minCount` parameter. The server will retry the inbox database until the `minCount` is satisfied or the `retryTimeout` is reached
         * @summary Get emails in an Inbox. This method is not idempotent as it allows retries and waits if you want certain conditions to be met before returning. For simple listing and sorting of known emails use the email controller instead.
         * @param {string} inboxId Id of inbox that emails belongs to
         * @param {number} [limit] Limit the result set, ordered by received date time sort direction. Maximum 100. For more listing options see the email controller
         * @param {number} [minCount] Minimum acceptable email count. Will cause request to hang (and retry) until minCount is satisfied or retryTimeout is reached.
         * @param {number} [retryTimeout] Maximum milliseconds to spend retrying inbox database until minCount emails are returned
         * @param {Date} [since] Exclude emails received before this ISO 8601 date time
         * @param {number} [size] Alias for limit. Assessed first before assessing any passed limit.
         * @param {'ASC' | 'DESC'} [sort] Sort the results by received date and direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmails(
            inboxId: string,
            limit?: number,
            minCount?: number,
            retryTimeout?: number,
            since?: Date,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ) {
            return InboxControllerApiFp(configuration).getEmails(
                inboxId,
                limit,
                minCount,
                retryTimeout,
                since,
                size,
                sort,
                options
            )(fetch, basePath);
        },
        /**
         * Returns an inbox's properties, including its email address and ID.
         * @summary Get Inbox. Returns properties of an inbox.
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInbox(inboxId: string, options?: any) {
            return InboxControllerApiFp(configuration).getInbox(
                inboxId,
                options
            )(fetch, basePath);
        },
        /**
         * Get a paginated list of emails in an inbox. Does not hold connections open.
         * @summary Get inbox emails paginated
         * @param {string} inboxId Id of inbox that emails belongs to
         * @param {number} [page] Optional page index in inbox emails list pagination
         * @param {number} [size] Optional page size in inbox emails list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxEmailsPaginated(
            inboxId: string,
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ) {
            return InboxControllerApiFp(configuration).getInboxEmailsPaginated(
                inboxId,
                page,
                size,
                sort,
                options
            )(fetch, basePath);
        },
        /**
         * Returns an inbox's sent email receipts. Call individual sent email endpoints for more details. Note for privacy reasons the full body of sent emails is never stored. An MD5 hash hex is available for comparison instead.
         * @summary Get Inbox Sent Emails
         * @param {string} inboxId inboxId
         * @param {number} [page] Optional page index in inbox sent email list pagination
         * @param {number} [size] Optional page size in inbox sent email list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxSentEmails(
            inboxId: string,
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ) {
            return InboxControllerApiFp(configuration).getInboxSentEmails(
                inboxId,
                page,
                size,
                sort,
                options
            )(fetch, basePath);
        },
        /**
         * Get all inbox tags
         * @summary Get inbox tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxTags(options?: any) {
            return InboxControllerApiFp(configuration).getInboxTags(options)(
                fetch,
                basePath
            );
        },
        /**
         * List the inboxes you have created. Note use of the more advanced `getAllEmails` is recommended. You can provide a limit and sort parameter.
         * @summary List Inboxes and email eddresses
         * @param {number} [size] Optional result size limit. Note an automatic limit of 100 results is applied. See the paginated &#x60;getAllEmails&#x60; for larger queries.
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInboxes(size?: number, sort?: 'ASC' | 'DESC', options?: any) {
            return InboxControllerApiFp(configuration).getInboxes(
                size,
                sort,
                options
            )(fetch, basePath);
        },
        /**
         * List organization inboxes in paginated form. These are inboxes created with `allowTeamAccess` flag enabled. Organization inboxes are `readOnly` for non-admin users. The results are available on the `content` property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time).
         * @summary List Organization Inboxes Paginated
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationInboxes(
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ) {
            return InboxControllerApiFp(configuration).getOrganizationInboxes(
                page,
                size,
                sort,
                options
            )(fetch, basePath);
        },
        /**
         * Send an email from an inbox's email address.  The request body should contain the `SendEmailOptions` that include recipients, attachments, body etc. See `SendEmailOptions` for all available properties. Note the `inboxId` refers to the inbox's id not the inbox's email address. See https://www.mailslurp.com/guides/ for more information on how to send emails. This method does not return a sent email entity due to legacy reasons. To send and get a sent email as returned response use the sister method `sendEmailAndConfirm`.
         * @summary Send Email
         * @param {string} inboxId ID of the inbox you want to send the email from
         * @param {SendEmailOptions} [sendEmailOptions] Options for the email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmail(
            inboxId: string,
            sendEmailOptions?: SendEmailOptions,
            options?: any
        ) {
            return InboxControllerApiFp(configuration).sendEmail(
                inboxId,
                sendEmailOptions,
                options
            )(fetch, basePath);
        },
        /**
         * Sister method for standard `sendEmail` method with the benefit of returning a `SentEmail` entity confirming the successful sending of the email with a link to the sent object created for it.
         * @summary Send email and return sent confirmation
         * @param {string} inboxId ID of the inbox you want to send the email from
         * @param {SendEmailOptions} [sendEmailOptions] Options for the email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailAndConfirm(
            inboxId: string,
            sendEmailOptions?: SendEmailOptions,
            options?: any
        ) {
            return InboxControllerApiFp(configuration).sendEmailAndConfirm(
                inboxId,
                sendEmailOptions,
                options
            )(fetch, basePath);
        },
        /**
         * Send an inbox a test email to test email receiving is working
         * @summary Send a test email to inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTestEmail(inboxId: string, options?: any) {
            return InboxControllerApiFp(configuration).sendTestEmail(
                inboxId,
                options
            )(fetch, basePath);
        },
        /**
         * Set and return new favourite state for an inbox
         * @summary Set inbox favourited state
         * @param {string} inboxId inboxId
         * @param {SetInboxFavouritedOptions} setInboxFavouritedOptions setInboxFavouritedOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setInboxFavourited(
            inboxId: string,
            setInboxFavouritedOptions: SetInboxFavouritedOptions,
            options?: any
        ) {
            return InboxControllerApiFp(configuration).setInboxFavourited(
                inboxId,
                setInboxFavouritedOptions,
                options
            )(fetch, basePath);
        },
        /**
         * Update editable fields on an inbox
         * @summary Update Inbox. Change name and description. Email address is not editable.
         * @param {string} inboxId inboxId
         * @param {UpdateInboxOptions} updateInboxOptions updateInboxOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInbox(
            inboxId: string,
            updateInboxOptions: UpdateInboxOptions,
            options?: any
        ) {
            return InboxControllerApiFp(configuration).updateInbox(
                inboxId,
                updateInboxOptions,
                options
            )(fetch, basePath);
        },
    };
};

/**
 * InboxControllerApi - object-oriented interface
 * @export
 * @class InboxControllerApi
 * @extends {BaseAPI}
 */
export class InboxControllerApi extends BaseAPI {
    /**
     * Create a new inbox and with a randomized email address to send and receive from. Pass emailAddress parameter if you wish to use a specific email address. Creating an inbox is required before sending or receiving emails. If writing tests it is recommended that you create a new inbox during each test method so that it is unique and empty.
     * @summary Create an inbox email address. An inbox has a real email address and can send and receive emails. Inboxes can be either `SMTP` or `HTTP` inboxes.
     * @param {boolean} [allowTeamAccess] Grant team access to this inbox and the emails that belong to it for team members of your organization.
     * @param {string} [description] Optional description of the inbox for labelling purposes. Is shown in the dashboard and can be used with
     * @param {string} [emailAddress] A custom email address to use with the inbox. Defaults to null. When null MailSlurp will assign a random email address to the inbox such as &#x60;123@mailslurp.com&#x60;. If you use the &#x60;useDomainPool&#x60; option when the email address is null it will generate an email address with a more varied domain ending such as &#x60;123@mailslurp.info&#x60; or &#x60;123@mailslurp.biz&#x60;. When a custom email address is provided the address is split into a domain and the domain is queried against your user. If you have created the domain in the MailSlurp dashboard and verified it you can use any email address that ends with the domain. Note domain types must match the inbox type - so &#x60;SMTP&#x60; inboxes will only work with &#x60;SMTP&#x60; type domains. Send an email to this address and the inbox will receive and store it for you. To retrieve the email use the Inbox and Email Controller endpoints with the inbox ID.
     * @param {Date} [expiresAt] Optional inbox expiration date. If null then this inbox is permanent and the emails in it won&#39;t be deleted. If an expiration date is provided or is required by your plan the inbox will be closed when the expiration time is reached. Expired inboxes still contain their emails but can no longer send or receive emails. An ExpiredInboxRecord is created when an inbox and the email address and inbox ID are recorded. The expiresAt property is a timestamp string in ISO DateTime Format yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSXXX.
     * @param {number} [expiresIn] Number of milliseconds that inbox should exist for
     * @param {boolean} [favourite] Is the inbox a favorite. Marking an inbox as a favorite is typically done in the dashboard for quick access or filtering
     * @param {'HTTP_INBOX' | 'SMTP_INBOX'} [inboxType] HTTP (default) or SMTP inbox type. HTTP inboxes are best for testing while SMTP inboxes are more reliable for public inbound email consumption. When using custom domains the domain type must match the inbox type. HTTP inboxes are processed by AWS SES while SMTP inboxes use a custom mail server running at &#x60;mx.mailslurp.com&#x60;.
     * @param {string} [name] Optional name of the inbox. Displayed in the dashboard for easier search and used as the sender name when sending emails.
     * @param {Array<string>} [tags] Tags that inbox has been tagged with. Tags can be added to inboxes to group different inboxes within an account. You can also search for inboxes by tag in the dashboard UI.
     * @param {boolean} [useDomainPool] Use the MailSlurp domain name pool with this inbox when creating the email address. Defaults to null. If enabled the inbox will be an email address with a domain randomly chosen from a list of the MailSlurp domains. This is useful when the default &#x60;@mailslurp.com&#x60; email addresses used with inboxes are blocked or considered spam by a provider or receiving service. When domain pool is enabled an email address will be generated ending in &#x60;@mailslurp.{world,info,xyz,...}&#x60; . This means a TLD is randomly selecting from a list of &#x60;.biz&#x60;, &#x60;.info&#x60;, &#x60;.xyz&#x60; etc to add variance to the generated email addresses. When null or false MailSlurp uses the default behavior of &#x60;@mailslurp.com&#x60; or custom email address provided by the emailAddress field. Note this feature is only available for &#x60;HTTP&#x60; inbox types.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    public createInbox(
        allowTeamAccess?: boolean,
        description?: string,
        emailAddress?: string,
        expiresAt?: Date,
        expiresIn?: number,
        favourite?: boolean,
        inboxType?: 'HTTP_INBOX' | 'SMTP_INBOX',
        name?: string,
        tags?: Array<string>,
        useDomainPool?: boolean,
        options?: any
    ) {
        return InboxControllerApiFp(this.configuration).createInbox(
            allowTeamAccess,
            description,
            emailAddress,
            expiresAt,
            expiresIn,
            favourite,
            inboxType,
            name,
            tags,
            useDomainPool,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Create an inbox with default options. Uses MailSlurp domain pool address and is private.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    public createInboxWithDefaults(options?: any) {
        return InboxControllerApiFp(this.configuration).createInboxWithDefaults(
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Additional endpoint that allows inbox creation with request body options. Can be more flexible that other methods for some clients.
     * @summary Create an inbox with options. Extended options for inbox creation.
     * @param {CreateInboxDto} createInboxDto createInboxDto
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    public createInboxWithOptions(
        createInboxDto: CreateInboxDto,
        options?: any
    ) {
        return InboxControllerApiFp(this.configuration).createInboxWithOptions(
            createInboxDto,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Permanently delete all inboxes and associated email addresses. This will also delete all emails within the inboxes. Be careful as inboxes cannot be recovered once deleted. Note: deleting inboxes will not impact your usage limits. Monthly inbox creation limits are based on how many inboxes were created in the last 30 days, not how many inboxes you currently have.
     * @summary Delete all inboxes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    public deleteAllInboxes(options?: any) {
        return InboxControllerApiFp(this.configuration).deleteAllInboxes(
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Permanently delete an inbox and associated email address as well as all emails within the given inbox. This action cannot be undone. Note: deleting an inbox will not affect your account usage. Monthly inbox usage is based on how many inboxes you create within 30 days, not how many exist at time of request.
     * @summary Delete inbox
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    public deleteInbox(inboxId: string, options?: any) {
        return InboxControllerApiFp(this.configuration).deleteInbox(
            inboxId,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * List inboxes in paginated form. The results are available on the `content` property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time). You Can also filter by whether an inbox is favorited or use email address pattern. This method is the recommended way to query inboxes. The alternative `getInboxes` method returns a full list of inboxes but is limited to 100 results. Results do not include team access inboxes by default. Use organization method to list team inboxes or set `teamAccess` to true.
     * @summary List All Inboxes Paginated
     * @param {boolean} [favourite] Optionally filter results for favourites only
     * @param {number} [page] Optional page index in inbox list pagination
     * @param {string} [search] Optionally filter by search words partial matching ID, tags, name, and email address
     * @param {number} [size] Optional page size in inbox list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {string} [tag] Optionally filter by tags. Will return inboxes that include given tags
     * @param {boolean} [teamAccess] Optionally filter by team access. Defaults to false so organization inboxes are not included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    public getAllInboxes(
        favourite?: boolean,
        page?: number,
        search?: string,
        size?: number,
        sort?: 'ASC' | 'DESC',
        tag?: string,
        teamAccess?: boolean,
        options?: any
    ) {
        return InboxControllerApiFp(this.configuration).getAllInboxes(
            favourite,
            page,
            search,
            size,
            sort,
            tag,
            teamAccess,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * List emails that an inbox has received. Only emails that are sent to the inbox's email address will appear in the inbox. It may take several seconds for any email you send to an inbox's email address to appear in the inbox. To make this endpoint wait for a minimum number of emails use the `minCount` parameter. The server will retry the inbox database until the `minCount` is satisfied or the `retryTimeout` is reached
     * @summary Get emails in an Inbox. This method is not idempotent as it allows retries and waits if you want certain conditions to be met before returning. For simple listing and sorting of known emails use the email controller instead.
     * @param {string} inboxId Id of inbox that emails belongs to
     * @param {number} [limit] Limit the result set, ordered by received date time sort direction. Maximum 100. For more listing options see the email controller
     * @param {number} [minCount] Minimum acceptable email count. Will cause request to hang (and retry) until minCount is satisfied or retryTimeout is reached.
     * @param {number} [retryTimeout] Maximum milliseconds to spend retrying inbox database until minCount emails are returned
     * @param {Date} [since] Exclude emails received before this ISO 8601 date time
     * @param {number} [size] Alias for limit. Assessed first before assessing any passed limit.
     * @param {'ASC' | 'DESC'} [sort] Sort the results by received date and direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    public getEmails(
        inboxId: string,
        limit?: number,
        minCount?: number,
        retryTimeout?: number,
        since?: Date,
        size?: number,
        sort?: 'ASC' | 'DESC',
        options?: any
    ) {
        return InboxControllerApiFp(this.configuration).getEmails(
            inboxId,
            limit,
            minCount,
            retryTimeout,
            since,
            size,
            sort,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Returns an inbox's properties, including its email address and ID.
     * @summary Get Inbox. Returns properties of an inbox.
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    public getInbox(inboxId: string, options?: any) {
        return InboxControllerApiFp(this.configuration).getInbox(
            inboxId,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Get a paginated list of emails in an inbox. Does not hold connections open.
     * @summary Get inbox emails paginated
     * @param {string} inboxId Id of inbox that emails belongs to
     * @param {number} [page] Optional page index in inbox emails list pagination
     * @param {number} [size] Optional page size in inbox emails list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    public getInboxEmailsPaginated(
        inboxId: string,
        page?: number,
        size?: number,
        sort?: 'ASC' | 'DESC',
        options?: any
    ) {
        return InboxControllerApiFp(this.configuration).getInboxEmailsPaginated(
            inboxId,
            page,
            size,
            sort,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Returns an inbox's sent email receipts. Call individual sent email endpoints for more details. Note for privacy reasons the full body of sent emails is never stored. An MD5 hash hex is available for comparison instead.
     * @summary Get Inbox Sent Emails
     * @param {string} inboxId inboxId
     * @param {number} [page] Optional page index in inbox sent email list pagination
     * @param {number} [size] Optional page size in inbox sent email list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    public getInboxSentEmails(
        inboxId: string,
        page?: number,
        size?: number,
        sort?: 'ASC' | 'DESC',
        options?: any
    ) {
        return InboxControllerApiFp(this.configuration).getInboxSentEmails(
            inboxId,
            page,
            size,
            sort,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Get all inbox tags
     * @summary Get inbox tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    public getInboxTags(options?: any) {
        return InboxControllerApiFp(this.configuration).getInboxTags(options)(
            this.fetch,
            this.basePath
        );
    }

    /**
     * List the inboxes you have created. Note use of the more advanced `getAllEmails` is recommended. You can provide a limit and sort parameter.
     * @summary List Inboxes and email eddresses
     * @param {number} [size] Optional result size limit. Note an automatic limit of 100 results is applied. See the paginated &#x60;getAllEmails&#x60; for larger queries.
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    public getInboxes(size?: number, sort?: 'ASC' | 'DESC', options?: any) {
        return InboxControllerApiFp(this.configuration).getInboxes(
            size,
            sort,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * List organization inboxes in paginated form. These are inboxes created with `allowTeamAccess` flag enabled. Organization inboxes are `readOnly` for non-admin users. The results are available on the `content` property of the returned object. This method allows for page index (zero based), page size (how many results to return), and a sort direction (based on createdAt time).
     * @summary List Organization Inboxes Paginated
     * @param {number} [page] Optional page index in inbox list pagination
     * @param {number} [size] Optional page size in inbox list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    public getOrganizationInboxes(
        page?: number,
        size?: number,
        sort?: 'ASC' | 'DESC',
        options?: any
    ) {
        return InboxControllerApiFp(this.configuration).getOrganizationInboxes(
            page,
            size,
            sort,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Send an email from an inbox's email address.  The request body should contain the `SendEmailOptions` that include recipients, attachments, body etc. See `SendEmailOptions` for all available properties. Note the `inboxId` refers to the inbox's id not the inbox's email address. See https://www.mailslurp.com/guides/ for more information on how to send emails. This method does not return a sent email entity due to legacy reasons. To send and get a sent email as returned response use the sister method `sendEmailAndConfirm`.
     * @summary Send Email
     * @param {string} inboxId ID of the inbox you want to send the email from
     * @param {SendEmailOptions} [sendEmailOptions] Options for the email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    public sendEmail(
        inboxId: string,
        sendEmailOptions?: SendEmailOptions,
        options?: any
    ) {
        return InboxControllerApiFp(this.configuration).sendEmail(
            inboxId,
            sendEmailOptions,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Sister method for standard `sendEmail` method with the benefit of returning a `SentEmail` entity confirming the successful sending of the email with a link to the sent object created for it.
     * @summary Send email and return sent confirmation
     * @param {string} inboxId ID of the inbox you want to send the email from
     * @param {SendEmailOptions} [sendEmailOptions] Options for the email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    public sendEmailAndConfirm(
        inboxId: string,
        sendEmailOptions?: SendEmailOptions,
        options?: any
    ) {
        return InboxControllerApiFp(this.configuration).sendEmailAndConfirm(
            inboxId,
            sendEmailOptions,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Send an inbox a test email to test email receiving is working
     * @summary Send a test email to inbox
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    public sendTestEmail(inboxId: string, options?: any) {
        return InboxControllerApiFp(this.configuration).sendTestEmail(
            inboxId,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Set and return new favourite state for an inbox
     * @summary Set inbox favourited state
     * @param {string} inboxId inboxId
     * @param {SetInboxFavouritedOptions} setInboxFavouritedOptions setInboxFavouritedOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    public setInboxFavourited(
        inboxId: string,
        setInboxFavouritedOptions: SetInboxFavouritedOptions,
        options?: any
    ) {
        return InboxControllerApiFp(this.configuration).setInboxFavourited(
            inboxId,
            setInboxFavouritedOptions,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Update editable fields on an inbox
     * @summary Update Inbox. Change name and description. Email address is not editable.
     * @param {string} inboxId inboxId
     * @param {UpdateInboxOptions} updateInboxOptions updateInboxOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxControllerApi
     */
    public updateInbox(
        inboxId: string,
        updateInboxOptions: UpdateInboxOptions,
        options?: any
    ) {
        return InboxControllerApiFp(this.configuration).updateInbox(
            inboxId,
            updateInboxOptions,
            options
        )(this.fetch, this.basePath);
    }
}

/**
 * MailServerControllerApi - fetch parameter creator
 * @export
 */
export const MailServerControllerApiFetchParamCreator = function(
    configuration?: Configuration
) {
    return {
        /**
         *
         * @summary Get DNS Mail Server records for a domain
         * @param {DescribeDomainOptions} describeOptions describeOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        describeMailServerDomain(
            describeOptions: DescribeDomainOptions,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'describeOptions' is not null or undefined
            if (describeOptions === null || describeOptions === undefined) {
                throw new RequiredError(
                    'describeOptions',
                    'Required parameter describeOptions was null or undefined when calling describeMailServerDomain.'
                );
            }
            const localVarPath = `/mail-server/describe/domain`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'DescribeDomainOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(describeOptions || {})
                : describeOptions || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Lookup DNS records for a domain
         * @param {DNSLookupOptions} dnsLookupOptions dnsLookupOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDnsLookup(
            dnsLookupOptions: DNSLookupOptions,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'dnsLookupOptions' is not null or undefined
            if (dnsLookupOptions === null || dnsLookupOptions === undefined) {
                throw new RequiredError(
                    'dnsLookupOptions',
                    'Required parameter dnsLookupOptions was null or undefined when calling getDnsLookup.'
                );
            }
            const localVarPath = `/mail-server/describe/dns-lookup`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'DNSLookupOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(dnsLookupOptions || {})
                : dnsLookupOptions || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get IP address for a domain
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIpAddress(name: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError(
                    'name',
                    'Required parameter name was null or undefined when calling getIpAddress.'
                );
            }
            const localVarPath = `/mail-server/describe/ip-address`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Verify the existence of an email address at a given mail server.
         * @param {VerifyEmailAddressOptions} verifyOptions verifyOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmailAddress(
            verifyOptions: VerifyEmailAddressOptions,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'verifyOptions' is not null or undefined
            if (verifyOptions === null || verifyOptions === undefined) {
                throw new RequiredError(
                    'verifyOptions',
                    'Required parameter verifyOptions was null or undefined when calling verifyEmailAddress.'
                );
            }
            const localVarPath = `/mail-server/verify/email-address`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'VerifyEmailAddressOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(verifyOptions || {})
                : verifyOptions || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * MailServerControllerApi - functional programming interface
 * @export
 */
export const MailServerControllerApiFp = function(
    configuration?: Configuration
) {
    return {
        /**
         *
         * @summary Get DNS Mail Server records for a domain
         * @param {DescribeDomainOptions} describeOptions describeOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        describeMailServerDomain(
            describeOptions: DescribeDomainOptions,
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<DescribeMailServerDomainResult> {
            const localVarFetchArgs = MailServerControllerApiFetchParamCreator(
                configuration
            ).describeMailServerDomain(describeOptions, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Lookup DNS records for a domain
         * @param {DNSLookupOptions} dnsLookupOptions dnsLookupOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDnsLookup(
            dnsLookupOptions: DNSLookupOptions,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<DNSLookupResults> {
            const localVarFetchArgs = MailServerControllerApiFetchParamCreator(
                configuration
            ).getDnsLookup(dnsLookupOptions, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get IP address for a domain
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIpAddress(
            name: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<IPAddressResult> {
            const localVarFetchArgs = MailServerControllerApiFetchParamCreator(
                configuration
            ).getIpAddress(name, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Verify the existence of an email address at a given mail server.
         * @param {VerifyEmailAddressOptions} verifyOptions verifyOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmailAddress(
            verifyOptions: VerifyEmailAddressOptions,
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<EmailVerificationResult> {
            const localVarFetchArgs = MailServerControllerApiFetchParamCreator(
                configuration
            ).verifyEmailAddress(verifyOptions, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    };
};

/**
 * MailServerControllerApi - factory interface
 * @export
 */
export const MailServerControllerApiFactory = function(
    configuration?: Configuration,
    fetch?: FetchAPI,
    basePath?: string
) {
    return {
        /**
         *
         * @summary Get DNS Mail Server records for a domain
         * @param {DescribeDomainOptions} describeOptions describeOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        describeMailServerDomain(
            describeOptions: DescribeDomainOptions,
            options?: any
        ) {
            return MailServerControllerApiFp(
                configuration
            ).describeMailServerDomain(describeOptions, options)(
                fetch,
                basePath
            );
        },
        /**
         *
         * @summary Lookup DNS records for a domain
         * @param {DNSLookupOptions} dnsLookupOptions dnsLookupOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDnsLookup(dnsLookupOptions: DNSLookupOptions, options?: any) {
            return MailServerControllerApiFp(configuration).getDnsLookup(
                dnsLookupOptions,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Get IP address for a domain
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIpAddress(name: string, options?: any) {
            return MailServerControllerApiFp(configuration).getIpAddress(
                name,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Verify the existence of an email address at a given mail server.
         * @param {VerifyEmailAddressOptions} verifyOptions verifyOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmailAddress(
            verifyOptions: VerifyEmailAddressOptions,
            options?: any
        ) {
            return MailServerControllerApiFp(configuration).verifyEmailAddress(
                verifyOptions,
                options
            )(fetch, basePath);
        },
    };
};

/**
 * MailServerControllerApi - object-oriented interface
 * @export
 * @class MailServerControllerApi
 * @extends {BaseAPI}
 */
export class MailServerControllerApi extends BaseAPI {
    /**
     *
     * @summary Get DNS Mail Server records for a domain
     * @param {DescribeDomainOptions} describeOptions describeOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailServerControllerApi
     */
    public describeMailServerDomain(
        describeOptions: DescribeDomainOptions,
        options?: any
    ) {
        return MailServerControllerApiFp(
            this.configuration
        ).describeMailServerDomain(describeOptions, options)(
            this.fetch,
            this.basePath
        );
    }

    /**
     *
     * @summary Lookup DNS records for a domain
     * @param {DNSLookupOptions} dnsLookupOptions dnsLookupOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailServerControllerApi
     */
    public getDnsLookup(dnsLookupOptions: DNSLookupOptions, options?: any) {
        return MailServerControllerApiFp(this.configuration).getDnsLookup(
            dnsLookupOptions,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get IP address for a domain
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailServerControllerApi
     */
    public getIpAddress(name: string, options?: any) {
        return MailServerControllerApiFp(this.configuration).getIpAddress(
            name,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Verify the existence of an email address at a given mail server.
     * @param {VerifyEmailAddressOptions} verifyOptions verifyOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailServerControllerApi
     */
    public verifyEmailAddress(
        verifyOptions: VerifyEmailAddressOptions,
        options?: any
    ) {
        return MailServerControllerApiFp(this.configuration).verifyEmailAddress(
            verifyOptions,
            options
        )(this.fetch, this.basePath);
    }
}

/**
 * MissedEmailControllerApi - fetch parameter creator
 * @export
 */
export const MissedEmailControllerApiFetchParamCreator = function(
    configuration?: Configuration
) {
    return {
        /**
         *
         * @summary Get all MissedEmails in paginated format
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMissedEmails(
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options: any = {}
        ): FetchArgs {
            const localVarPath = `/missed-emails`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get MissedEmail
         * @param {string} missedEmailId MissedEmailId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMissedEmail(missedEmailId: string, options: any = {}): FetchArgs {
            // verify required parameter 'missedEmailId' is not null or undefined
            if (missedEmailId === null || missedEmailId === undefined) {
                throw new RequiredError(
                    'missedEmailId',
                    'Required parameter missedEmailId was null or undefined when calling getMissedEmail.'
                );
            }
            const localVarPath = `/missed-emails/{MissedEmailId}`.replace(
                `{${'MissedEmailId'}}`,
                encodeURIComponent(String(missedEmailId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * MissedEmailControllerApi - functional programming interface
 * @export
 */
export const MissedEmailControllerApiFp = function(
    configuration?: Configuration
) {
    return {
        /**
         *
         * @summary Get all MissedEmails in paginated format
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMissedEmails(
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<PageMissedEmailProjection> {
            const localVarFetchArgs = MissedEmailControllerApiFetchParamCreator(
                configuration
            ).getAllMissedEmails(page, size, sort, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get MissedEmail
         * @param {string} missedEmailId MissedEmailId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMissedEmail(
            missedEmailId: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<MissedEmail> {
            const localVarFetchArgs = MissedEmailControllerApiFetchParamCreator(
                configuration
            ).getMissedEmail(missedEmailId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    };
};

/**
 * MissedEmailControllerApi - factory interface
 * @export
 */
export const MissedEmailControllerApiFactory = function(
    configuration?: Configuration,
    fetch?: FetchAPI,
    basePath?: string
) {
    return {
        /**
         *
         * @summary Get all MissedEmails in paginated format
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMissedEmails(
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ) {
            return MissedEmailControllerApiFp(configuration).getAllMissedEmails(
                page,
                size,
                sort,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Get MissedEmail
         * @param {string} missedEmailId MissedEmailId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMissedEmail(missedEmailId: string, options?: any) {
            return MissedEmailControllerApiFp(configuration).getMissedEmail(
                missedEmailId,
                options
            )(fetch, basePath);
        },
    };
};

/**
 * MissedEmailControllerApi - object-oriented interface
 * @export
 * @class MissedEmailControllerApi
 * @extends {BaseAPI}
 */
export class MissedEmailControllerApi extends BaseAPI {
    /**
     *
     * @summary Get all MissedEmails in paginated format
     * @param {number} [page] Optional page index in inbox list pagination
     * @param {number} [size] Optional page size in inbox list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MissedEmailControllerApi
     */
    public getAllMissedEmails(
        page?: number,
        size?: number,
        sort?: 'ASC' | 'DESC',
        options?: any
    ) {
        return MissedEmailControllerApiFp(
            this.configuration
        ).getAllMissedEmails(page, size, sort, options)(
            this.fetch,
            this.basePath
        );
    }

    /**
     *
     * @summary Get MissedEmail
     * @param {string} missedEmailId MissedEmailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MissedEmailControllerApi
     */
    public getMissedEmail(missedEmailId: string, options?: any) {
        return MissedEmailControllerApiFp(this.configuration).getMissedEmail(
            missedEmailId,
            options
        )(this.fetch, this.basePath);
    }
}

/**
 * SentEmailsControllerApi - fetch parameter creator
 * @export
 */
export const SentEmailsControllerApiFetchParamCreator = function(
    configuration?: Configuration
) {
    return {
        /**
         *
         * @summary Get sent email receipt
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSentEmail(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError(
                    'id',
                    'Required parameter id was null or undefined when calling getSentEmail.'
                );
            }
            const localVarPath = `/sent/{id}`.replace(
                `{${'id'}}`,
                encodeURIComponent(String(id))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all sent emails in paginated form
         * @param {string} [inboxId] Optional inboxId to filter sender of sent emails by
         * @param {number} [page] Optional page index in inbox sent email list pagination
         * @param {number} [size] Optional page size in inbox sent email list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSentEmails(
            inboxId?: string,
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options: any = {}
        ): FetchArgs {
            const localVarPath = `/sent`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (inboxId !== undefined) {
                localVarQueryParameter['inboxId'] = inboxId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all sent organization emails in paginated form
         * @param {string} [inboxId] Optional inboxId to filter sender of sent emails by
         * @param {number} [page] Optional page index in inbox sent email list pagination
         * @param {number} [size] Optional page size in inbox sent email list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSentOrganizationEmails(
            inboxId?: string,
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options: any = {}
        ): FetchArgs {
            const localVarPath = `/sent/organization`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (inboxId !== undefined) {
                localVarQueryParameter['inboxId'] = inboxId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * SentEmailsControllerApi - functional programming interface
 * @export
 */
export const SentEmailsControllerApiFp = function(
    configuration?: Configuration
) {
    return {
        /**
         *
         * @summary Get sent email receipt
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSentEmail(
            id: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<SentEmailDto> {
            const localVarFetchArgs = SentEmailsControllerApiFetchParamCreator(
                configuration
            ).getSentEmail(id, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all sent emails in paginated form
         * @param {string} [inboxId] Optional inboxId to filter sender of sent emails by
         * @param {number} [page] Optional page index in inbox sent email list pagination
         * @param {number} [size] Optional page size in inbox sent email list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSentEmails(
            inboxId?: string,
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<PageSentEmailProjection> {
            const localVarFetchArgs = SentEmailsControllerApiFetchParamCreator(
                configuration
            ).getSentEmails(inboxId, page, size, sort, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all sent organization emails in paginated form
         * @param {string} [inboxId] Optional inboxId to filter sender of sent emails by
         * @param {number} [page] Optional page index in inbox sent email list pagination
         * @param {number} [size] Optional page size in inbox sent email list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSentOrganizationEmails(
            inboxId?: string,
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<PageSentEmailProjection> {
            const localVarFetchArgs = SentEmailsControllerApiFetchParamCreator(
                configuration
            ).getSentOrganizationEmails(inboxId, page, size, sort, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    };
};

/**
 * SentEmailsControllerApi - factory interface
 * @export
 */
export const SentEmailsControllerApiFactory = function(
    configuration?: Configuration,
    fetch?: FetchAPI,
    basePath?: string
) {
    return {
        /**
         *
         * @summary Get sent email receipt
         * @param {string} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSentEmail(id: string, options?: any) {
            return SentEmailsControllerApiFp(configuration).getSentEmail(
                id,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Get all sent emails in paginated form
         * @param {string} [inboxId] Optional inboxId to filter sender of sent emails by
         * @param {number} [page] Optional page index in inbox sent email list pagination
         * @param {number} [size] Optional page size in inbox sent email list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSentEmails(
            inboxId?: string,
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ) {
            return SentEmailsControllerApiFp(configuration).getSentEmails(
                inboxId,
                page,
                size,
                sort,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Get all sent organization emails in paginated form
         * @param {string} [inboxId] Optional inboxId to filter sender of sent emails by
         * @param {number} [page] Optional page index in inbox sent email list pagination
         * @param {number} [size] Optional page size in inbox sent email list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSentOrganizationEmails(
            inboxId?: string,
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ) {
            return SentEmailsControllerApiFp(
                configuration
            ).getSentOrganizationEmails(inboxId, page, size, sort, options)(
                fetch,
                basePath
            );
        },
    };
};

/**
 * SentEmailsControllerApi - object-oriented interface
 * @export
 * @class SentEmailsControllerApi
 * @extends {BaseAPI}
 */
export class SentEmailsControllerApi extends BaseAPI {
    /**
     *
     * @summary Get sent email receipt
     * @param {string} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SentEmailsControllerApi
     */
    public getSentEmail(id: string, options?: any) {
        return SentEmailsControllerApiFp(this.configuration).getSentEmail(
            id,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get all sent emails in paginated form
     * @param {string} [inboxId] Optional inboxId to filter sender of sent emails by
     * @param {number} [page] Optional page index in inbox sent email list pagination
     * @param {number} [size] Optional page size in inbox sent email list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SentEmailsControllerApi
     */
    public getSentEmails(
        inboxId?: string,
        page?: number,
        size?: number,
        sort?: 'ASC' | 'DESC',
        options?: any
    ) {
        return SentEmailsControllerApiFp(this.configuration).getSentEmails(
            inboxId,
            page,
            size,
            sort,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get all sent organization emails in paginated form
     * @param {string} [inboxId] Optional inboxId to filter sender of sent emails by
     * @param {number} [page] Optional page index in inbox sent email list pagination
     * @param {number} [size] Optional page size in inbox sent email list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SentEmailsControllerApi
     */
    public getSentOrganizationEmails(
        inboxId?: string,
        page?: number,
        size?: number,
        sort?: 'ASC' | 'DESC',
        options?: any
    ) {
        return SentEmailsControllerApiFp(
            this.configuration
        ).getSentOrganizationEmails(inboxId, page, size, sort, options)(
            this.fetch,
            this.basePath
        );
    }
}

/**
 * TemplateControllerApi - fetch parameter creator
 * @export
 */
export const TemplateControllerApiFetchParamCreator = function(
    configuration?: Configuration
) {
    return {
        /**
         *
         * @summary Create a Template
         * @param {CreateTemplateOptions} createTemplateOptions createTemplateOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTemplate(
            createTemplateOptions: CreateTemplateOptions,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'createTemplateOptions' is not null or undefined
            if (
                createTemplateOptions === null ||
                createTemplateOptions === undefined
            ) {
                throw new RequiredError(
                    'createTemplateOptions',
                    'Required parameter createTemplateOptions was null or undefined when calling createTemplate.'
                );
            }
            const localVarPath = `/templates`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'CreateTemplateOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(createTemplateOptions || {})
                : createTemplateOptions || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete Template
         * @param {string} templateId TemplateId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTemplate(templateId: string, options: any = {}): FetchArgs {
            // verify required parameter 'templateId' is not null or undefined
            if (templateId === null || templateId === undefined) {
                throw new RequiredError(
                    'templateId',
                    'Required parameter templateId was null or undefined when calling deleteTemplate.'
                );
            }
            const localVarPath = `/templates/{TemplateId}`.replace(
                `{${'TemplateId'}}`,
                encodeURIComponent(String(templateId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'DELETE' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Templates in paginated format
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTemplates(
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options: any = {}
        ): FetchArgs {
            const localVarPath = `/templates/paginated`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get Template
         * @param {string} templateId TemplateId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplate(templateId: string, options: any = {}): FetchArgs {
            // verify required parameter 'templateId' is not null or undefined
            if (templateId === null || templateId === undefined) {
                throw new RequiredError(
                    'templateId',
                    'Required parameter templateId was null or undefined when calling getTemplate.'
                );
            }
            const localVarPath = `/templates/{TemplateId}`.replace(
                `{${'TemplateId'}}`,
                encodeURIComponent(String(templateId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplates(options: any = {}): FetchArgs {
            const localVarPath = `/templates`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * TemplateControllerApi - functional programming interface
 * @export
 */
export const TemplateControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a Template
         * @param {CreateTemplateOptions} createTemplateOptions createTemplateOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTemplate(
            createTemplateOptions: CreateTemplateOptions,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<TemplateDto> {
            const localVarFetchArgs = TemplateControllerApiFetchParamCreator(
                configuration
            ).createTemplate(createTemplateOptions, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete Template
         * @param {string} templateId TemplateId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTemplate(
            templateId: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TemplateControllerApiFetchParamCreator(
                configuration
            ).deleteTemplate(templateId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all Templates in paginated format
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTemplates(
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<PageTemplateProjection> {
            const localVarFetchArgs = TemplateControllerApiFetchParamCreator(
                configuration
            ).getAllTemplates(page, size, sort, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get Template
         * @param {string} templateId TemplateId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplate(
            templateId: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<TemplateDto> {
            const localVarFetchArgs = TemplateControllerApiFetchParamCreator(
                configuration
            ).getTemplate(templateId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplates(
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<Array<TemplateProjection>> {
            const localVarFetchArgs = TemplateControllerApiFetchParamCreator(
                configuration
            ).getTemplates(options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    };
};

/**
 * TemplateControllerApi - factory interface
 * @export
 */
export const TemplateControllerApiFactory = function(
    configuration?: Configuration,
    fetch?: FetchAPI,
    basePath?: string
) {
    return {
        /**
         *
         * @summary Create a Template
         * @param {CreateTemplateOptions} createTemplateOptions createTemplateOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTemplate(
            createTemplateOptions: CreateTemplateOptions,
            options?: any
        ) {
            return TemplateControllerApiFp(configuration).createTemplate(
                createTemplateOptions,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Delete Template
         * @param {string} templateId TemplateId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTemplate(templateId: string, options?: any) {
            return TemplateControllerApiFp(configuration).deleteTemplate(
                templateId,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Get all Templates in paginated format
         * @param {number} [page] Optional page index in inbox list pagination
         * @param {number} [size] Optional page size in inbox list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTemplates(
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ) {
            return TemplateControllerApiFp(configuration).getAllTemplates(
                page,
                size,
                sort,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Get Template
         * @param {string} templateId TemplateId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplate(templateId: string, options?: any) {
            return TemplateControllerApiFp(configuration).getTemplate(
                templateId,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Get all Templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplates(options?: any) {
            return TemplateControllerApiFp(configuration).getTemplates(options)(
                fetch,
                basePath
            );
        },
    };
};

/**
 * TemplateControllerApi - object-oriented interface
 * @export
 * @class TemplateControllerApi
 * @extends {BaseAPI}
 */
export class TemplateControllerApi extends BaseAPI {
    /**
     *
     * @summary Create a Template
     * @param {CreateTemplateOptions} createTemplateOptions createTemplateOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateControllerApi
     */
    public createTemplate(
        createTemplateOptions: CreateTemplateOptions,
        options?: any
    ) {
        return TemplateControllerApiFp(this.configuration).createTemplate(
            createTemplateOptions,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Delete Template
     * @param {string} templateId TemplateId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateControllerApi
     */
    public deleteTemplate(templateId: string, options?: any) {
        return TemplateControllerApiFp(this.configuration).deleteTemplate(
            templateId,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get all Templates in paginated format
     * @param {number} [page] Optional page index in inbox list pagination
     * @param {number} [size] Optional page size in inbox list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateControllerApi
     */
    public getAllTemplates(
        page?: number,
        size?: number,
        sort?: 'ASC' | 'DESC',
        options?: any
    ) {
        return TemplateControllerApiFp(this.configuration).getAllTemplates(
            page,
            size,
            sort,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get Template
     * @param {string} templateId TemplateId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateControllerApi
     */
    public getTemplate(templateId: string, options?: any) {
        return TemplateControllerApiFp(this.configuration).getTemplate(
            templateId,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get all Templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateControllerApi
     */
    public getTemplates(options?: any) {
        return TemplateControllerApiFp(this.configuration).getTemplates(
            options
        )(this.fetch, this.basePath);
    }
}

/**
 * WaitForControllerApi - fetch parameter creator
 * @export
 */
export const WaitForControllerApiFetchParamCreator = function(
    configuration?: Configuration
) {
    return {
        /**
         * Generic waitFor method that will wait until an inbox meets given conditions or return immediately if already met
         * @summary Wait for an email to match the provided filter conditions such as subject contains keyword.
         * @param {WaitForConditions} [waitForConditions] Conditions to apply to emails that you are waiting for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitFor(
            waitForConditions?: WaitForConditions,
            options: any = {}
        ): FetchArgs {
            const localVarPath = `/waitFor`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'WaitForConditions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(waitForConditions || {})
                : waitForConditions || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If inbox contains count or more emails at time of request then return count worth of emails. If not wait until the count is reached and return those or return an error if timeout is exceeded.
         * @summary Wait for and return count number of emails. Hold connection until inbox count matches expected or timeout occurs
         * @param {number} [count] Number of emails to wait for. Must be greater that 1
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {boolean} [unreadOnly] Optional filter for unread only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForEmailCount(
            count?: number,
            inboxId?: string,
            timeout?: number,
            unreadOnly?: boolean,
            options: any = {}
        ): FetchArgs {
            const localVarPath = `/waitForEmailCount`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (inboxId !== undefined) {
                localVarQueryParameter['inboxId'] = inboxId;
            }

            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }

            if (unreadOnly !== undefined) {
                localVarQueryParameter['unreadOnly'] = unreadOnly;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox set `unreadOnly=true` or see the other receive methods such as `waitForNthEmail` or `waitForEmailCount`.
         * @summary Fetch inbox's latest email or if empty wait for an email to arrive
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {boolean} [unreadOnly] Optional filter for unread only.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForLatestEmail(
            inboxId?: string,
            timeout?: number,
            unreadOnly?: boolean,
            options: any = {}
        ): FetchArgs {
            const localVarPath = `/waitForLatestEmail`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (inboxId !== undefined) {
                localVarQueryParameter['inboxId'] = inboxId;
            }

            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }

            if (unreadOnly !== undefined) {
                localVarQueryParameter['unreadOnly'] = unreadOnly;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Perform a search of emails in an inbox with the given patterns. If results match expected count then return or else retry the search until results are found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the `MatchOptions` object for options. An example payload is `{ matches: [{field: 'SUBJECT',should:'CONTAIN',value:'needle'}] }`. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController `getEmailContentMatch` method.
         * @summary Wait or return list of emails that match simple matching patterns
         * @param {MatchOptions} matchOptions matchOptions
         * @param {number} [count] Number of emails to wait for. Must be greater that 1
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {boolean} [unreadOnly] Optional filter for unread only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForMatchingEmail(
            matchOptions: MatchOptions,
            count?: number,
            inboxId?: string,
            timeout?: number,
            unreadOnly?: boolean,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'matchOptions' is not null or undefined
            if (matchOptions === null || matchOptions === undefined) {
                throw new RequiredError(
                    'matchOptions',
                    'Required parameter matchOptions was null or undefined when calling waitForMatchingEmail.'
                );
            }
            const localVarPath = `/waitForMatchingEmails`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (count !== undefined) {
                localVarQueryParameter['count'] = count;
            }

            if (inboxId !== undefined) {
                localVarQueryParameter['inboxId'] = inboxId;
            }

            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }

            if (unreadOnly !== undefined) {
                localVarQueryParameter['unreadOnly'] = unreadOnly;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'MatchOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(matchOptions || {})
                : matchOptions || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Perform a search of emails in an inbox with the given patterns. If a result if found then return or else retry the search until a result is found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the `MatchOptions` object for options. An example payload is `{ matches: [{field: 'SUBJECT',should:'CONTAIN',value:'needle'}] }`. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController `getEmailContentMatch` method.
         * @summary Wait for or return the first email that matches proved MatchOptions array
         * @param {MatchOptions} matchOptions matchOptions
         * @param {string} [inboxId] Id of the inbox we are matching an email for
         * @param {number} [timeout] Max milliseconds to wait
         * @param {boolean} [unreadOnly] Optional filter for unread only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForMatchingFirstEmail(
            matchOptions: MatchOptions,
            inboxId?: string,
            timeout?: number,
            unreadOnly?: boolean,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'matchOptions' is not null or undefined
            if (matchOptions === null || matchOptions === undefined) {
                throw new RequiredError(
                    'matchOptions',
                    'Required parameter matchOptions was null or undefined when calling waitForMatchingFirstEmail.'
                );
            }
            const localVarPath = `/waitForMatchingFirstEmail`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (inboxId !== undefined) {
                localVarQueryParameter['inboxId'] = inboxId;
            }

            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }

            if (unreadOnly !== undefined) {
                localVarQueryParameter['unreadOnly'] = unreadOnly;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'MatchOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(matchOptions || {})
                : matchOptions || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If nth email is already present in inbox then return it. If not hold the connection open until timeout expires or the nth email is received and returned.
         * @summary Wait for or fetch the email with a given index in the inbox specified. IF indx doesn't exist waits for it to exist or timeout to occur.
         * @param {string} [inboxId] Id of the inbox you are fetching emails from
         * @param {number} [index] Zero based index of the email to wait for. If an inbox has 1 email already and you want to wait for the 2nd email pass index&#x3D;1
         * @param {number} [timeout] Max milliseconds to wait for the nth email if not already present
         * @param {boolean} [unreadOnly] Optional filter for unread only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForNthEmail(
            inboxId?: string,
            index?: number,
            timeout?: number,
            unreadOnly?: boolean,
            options: any = {}
        ): FetchArgs {
            const localVarPath = `/waitForNthEmail`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (inboxId !== undefined) {
                localVarQueryParameter['inboxId'] = inboxId;
            }

            if (index !== undefined) {
                localVarQueryParameter['index'] = index;
            }

            if (timeout !== undefined) {
                localVarQueryParameter['timeout'] = timeout;
            }

            if (unreadOnly !== undefined) {
                localVarQueryParameter['unreadOnly'] = unreadOnly;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * WaitForControllerApi - functional programming interface
 * @export
 */
export const WaitForControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Generic waitFor method that will wait until an inbox meets given conditions or return immediately if already met
         * @summary Wait for an email to match the provided filter conditions such as subject contains keyword.
         * @param {WaitForConditions} [waitForConditions] Conditions to apply to emails that you are waiting for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitFor(
            waitForConditions?: WaitForConditions,
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<Array<EmailPreview>> {
            const localVarFetchArgs = WaitForControllerApiFetchParamCreator(
                configuration
            ).waitFor(waitForConditions, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * If inbox contains count or more emails at time of request then return count worth of emails. If not wait until the count is reached and return those or return an error if timeout is exceeded.
         * @summary Wait for and return count number of emails. Hold connection until inbox count matches expected or timeout occurs
         * @param {number} [count] Number of emails to wait for. Must be greater that 1
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {boolean} [unreadOnly] Optional filter for unread only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForEmailCount(
            count?: number,
            inboxId?: string,
            timeout?: number,
            unreadOnly?: boolean,
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<Array<EmailPreview>> {
            const localVarFetchArgs = WaitForControllerApiFetchParamCreator(
                configuration
            ).waitForEmailCount(count, inboxId, timeout, unreadOnly, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox set `unreadOnly=true` or see the other receive methods such as `waitForNthEmail` or `waitForEmailCount`.
         * @summary Fetch inbox's latest email or if empty wait for an email to arrive
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {boolean} [unreadOnly] Optional filter for unread only.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForLatestEmail(
            inboxId?: string,
            timeout?: number,
            unreadOnly?: boolean,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Email> {
            const localVarFetchArgs = WaitForControllerApiFetchParamCreator(
                configuration
            ).waitForLatestEmail(inboxId, timeout, unreadOnly, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Perform a search of emails in an inbox with the given patterns. If results match expected count then return or else retry the search until results are found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the `MatchOptions` object for options. An example payload is `{ matches: [{field: 'SUBJECT',should:'CONTAIN',value:'needle'}] }`. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController `getEmailContentMatch` method.
         * @summary Wait or return list of emails that match simple matching patterns
         * @param {MatchOptions} matchOptions matchOptions
         * @param {number} [count] Number of emails to wait for. Must be greater that 1
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {boolean} [unreadOnly] Optional filter for unread only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForMatchingEmail(
            matchOptions: MatchOptions,
            count?: number,
            inboxId?: string,
            timeout?: number,
            unreadOnly?: boolean,
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<Array<EmailPreview>> {
            const localVarFetchArgs = WaitForControllerApiFetchParamCreator(
                configuration
            ).waitForMatchingEmail(
                matchOptions,
                count,
                inboxId,
                timeout,
                unreadOnly,
                options
            );
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Perform a search of emails in an inbox with the given patterns. If a result if found then return or else retry the search until a result is found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the `MatchOptions` object for options. An example payload is `{ matches: [{field: 'SUBJECT',should:'CONTAIN',value:'needle'}] }`. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController `getEmailContentMatch` method.
         * @summary Wait for or return the first email that matches proved MatchOptions array
         * @param {MatchOptions} matchOptions matchOptions
         * @param {string} [inboxId] Id of the inbox we are matching an email for
         * @param {number} [timeout] Max milliseconds to wait
         * @param {boolean} [unreadOnly] Optional filter for unread only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForMatchingFirstEmail(
            matchOptions: MatchOptions,
            inboxId?: string,
            timeout?: number,
            unreadOnly?: boolean,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Email> {
            const localVarFetchArgs = WaitForControllerApiFetchParamCreator(
                configuration
            ).waitForMatchingFirstEmail(
                matchOptions,
                inboxId,
                timeout,
                unreadOnly,
                options
            );
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * If nth email is already present in inbox then return it. If not hold the connection open until timeout expires or the nth email is received and returned.
         * @summary Wait for or fetch the email with a given index in the inbox specified. IF indx doesn't exist waits for it to exist or timeout to occur.
         * @param {string} [inboxId] Id of the inbox you are fetching emails from
         * @param {number} [index] Zero based index of the email to wait for. If an inbox has 1 email already and you want to wait for the 2nd email pass index&#x3D;1
         * @param {number} [timeout] Max milliseconds to wait for the nth email if not already present
         * @param {boolean} [unreadOnly] Optional filter for unread only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForNthEmail(
            inboxId?: string,
            index?: number,
            timeout?: number,
            unreadOnly?: boolean,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Email> {
            const localVarFetchArgs = WaitForControllerApiFetchParamCreator(
                configuration
            ).waitForNthEmail(inboxId, index, timeout, unreadOnly, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    };
};

/**
 * WaitForControllerApi - factory interface
 * @export
 */
export const WaitForControllerApiFactory = function(
    configuration?: Configuration,
    fetch?: FetchAPI,
    basePath?: string
) {
    return {
        /**
         * Generic waitFor method that will wait until an inbox meets given conditions or return immediately if already met
         * @summary Wait for an email to match the provided filter conditions such as subject contains keyword.
         * @param {WaitForConditions} [waitForConditions] Conditions to apply to emails that you are waiting for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitFor(waitForConditions?: WaitForConditions, options?: any) {
            return WaitForControllerApiFp(configuration).waitFor(
                waitForConditions,
                options
            )(fetch, basePath);
        },
        /**
         * If inbox contains count or more emails at time of request then return count worth of emails. If not wait until the count is reached and return those or return an error if timeout is exceeded.
         * @summary Wait for and return count number of emails. Hold connection until inbox count matches expected or timeout occurs
         * @param {number} [count] Number of emails to wait for. Must be greater that 1
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {boolean} [unreadOnly] Optional filter for unread only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForEmailCount(
            count?: number,
            inboxId?: string,
            timeout?: number,
            unreadOnly?: boolean,
            options?: any
        ) {
            return WaitForControllerApiFp(configuration).waitForEmailCount(
                count,
                inboxId,
                timeout,
                unreadOnly,
                options
            )(fetch, basePath);
        },
        /**
         * Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox set `unreadOnly=true` or see the other receive methods such as `waitForNthEmail` or `waitForEmailCount`.
         * @summary Fetch inbox's latest email or if empty wait for an email to arrive
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {boolean} [unreadOnly] Optional filter for unread only.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForLatestEmail(
            inboxId?: string,
            timeout?: number,
            unreadOnly?: boolean,
            options?: any
        ) {
            return WaitForControllerApiFp(configuration).waitForLatestEmail(
                inboxId,
                timeout,
                unreadOnly,
                options
            )(fetch, basePath);
        },
        /**
         * Perform a search of emails in an inbox with the given patterns. If results match expected count then return or else retry the search until results are found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the `MatchOptions` object for options. An example payload is `{ matches: [{field: 'SUBJECT',should:'CONTAIN',value:'needle'}] }`. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController `getEmailContentMatch` method.
         * @summary Wait or return list of emails that match simple matching patterns
         * @param {MatchOptions} matchOptions matchOptions
         * @param {number} [count] Number of emails to wait for. Must be greater that 1
         * @param {string} [inboxId] Id of the inbox we are fetching emails from
         * @param {number} [timeout] Max milliseconds to wait
         * @param {boolean} [unreadOnly] Optional filter for unread only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForMatchingEmail(
            matchOptions: MatchOptions,
            count?: number,
            inboxId?: string,
            timeout?: number,
            unreadOnly?: boolean,
            options?: any
        ) {
            return WaitForControllerApiFp(configuration).waitForMatchingEmail(
                matchOptions,
                count,
                inboxId,
                timeout,
                unreadOnly,
                options
            )(fetch, basePath);
        },
        /**
         * Perform a search of emails in an inbox with the given patterns. If a result if found then return or else retry the search until a result is found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the `MatchOptions` object for options. An example payload is `{ matches: [{field: 'SUBJECT',should:'CONTAIN',value:'needle'}] }`. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController `getEmailContentMatch` method.
         * @summary Wait for or return the first email that matches proved MatchOptions array
         * @param {MatchOptions} matchOptions matchOptions
         * @param {string} [inboxId] Id of the inbox we are matching an email for
         * @param {number} [timeout] Max milliseconds to wait
         * @param {boolean} [unreadOnly] Optional filter for unread only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForMatchingFirstEmail(
            matchOptions: MatchOptions,
            inboxId?: string,
            timeout?: number,
            unreadOnly?: boolean,
            options?: any
        ) {
            return WaitForControllerApiFp(
                configuration
            ).waitForMatchingFirstEmail(
                matchOptions,
                inboxId,
                timeout,
                unreadOnly,
                options
            )(fetch, basePath);
        },
        /**
         * If nth email is already present in inbox then return it. If not hold the connection open until timeout expires or the nth email is received and returned.
         * @summary Wait for or fetch the email with a given index in the inbox specified. IF indx doesn't exist waits for it to exist or timeout to occur.
         * @param {string} [inboxId] Id of the inbox you are fetching emails from
         * @param {number} [index] Zero based index of the email to wait for. If an inbox has 1 email already and you want to wait for the 2nd email pass index&#x3D;1
         * @param {number} [timeout] Max milliseconds to wait for the nth email if not already present
         * @param {boolean} [unreadOnly] Optional filter for unread only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        waitForNthEmail(
            inboxId?: string,
            index?: number,
            timeout?: number,
            unreadOnly?: boolean,
            options?: any
        ) {
            return WaitForControllerApiFp(configuration).waitForNthEmail(
                inboxId,
                index,
                timeout,
                unreadOnly,
                options
            )(fetch, basePath);
        },
    };
};

/**
 * WaitForControllerApi - object-oriented interface
 * @export
 * @class WaitForControllerApi
 * @extends {BaseAPI}
 */
export class WaitForControllerApi extends BaseAPI {
    /**
     * Generic waitFor method that will wait until an inbox meets given conditions or return immediately if already met
     * @summary Wait for an email to match the provided filter conditions such as subject contains keyword.
     * @param {WaitForConditions} [waitForConditions] Conditions to apply to emails that you are waiting for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitForControllerApi
     */
    public waitFor(waitForConditions?: WaitForConditions, options?: any) {
        return WaitForControllerApiFp(this.configuration).waitFor(
            waitForConditions,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * If inbox contains count or more emails at time of request then return count worth of emails. If not wait until the count is reached and return those or return an error if timeout is exceeded.
     * @summary Wait for and return count number of emails. Hold connection until inbox count matches expected or timeout occurs
     * @param {number} [count] Number of emails to wait for. Must be greater that 1
     * @param {string} [inboxId] Id of the inbox we are fetching emails from
     * @param {number} [timeout] Max milliseconds to wait
     * @param {boolean} [unreadOnly] Optional filter for unread only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitForControllerApi
     */
    public waitForEmailCount(
        count?: number,
        inboxId?: string,
        timeout?: number,
        unreadOnly?: boolean,
        options?: any
    ) {
        return WaitForControllerApiFp(this.configuration).waitForEmailCount(
            count,
            inboxId,
            timeout,
            unreadOnly,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Will return either the last received email or wait for an email to arrive and return that. If you need to wait for an email for a non-empty inbox set `unreadOnly=true` or see the other receive methods such as `waitForNthEmail` or `waitForEmailCount`.
     * @summary Fetch inbox's latest email or if empty wait for an email to arrive
     * @param {string} [inboxId] Id of the inbox we are fetching emails from
     * @param {number} [timeout] Max milliseconds to wait
     * @param {boolean} [unreadOnly] Optional filter for unread only.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitForControllerApi
     */
    public waitForLatestEmail(
        inboxId?: string,
        timeout?: number,
        unreadOnly?: boolean,
        options?: any
    ) {
        return WaitForControllerApiFp(this.configuration).waitForLatestEmail(
            inboxId,
            timeout,
            unreadOnly,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Perform a search of emails in an inbox with the given patterns. If results match expected count then return or else retry the search until results are found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the `MatchOptions` object for options. An example payload is `{ matches: [{field: 'SUBJECT',should:'CONTAIN',value:'needle'}] }`. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController `getEmailContentMatch` method.
     * @summary Wait or return list of emails that match simple matching patterns
     * @param {MatchOptions} matchOptions matchOptions
     * @param {number} [count] Number of emails to wait for. Must be greater that 1
     * @param {string} [inboxId] Id of the inbox we are fetching emails from
     * @param {number} [timeout] Max milliseconds to wait
     * @param {boolean} [unreadOnly] Optional filter for unread only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitForControllerApi
     */
    public waitForMatchingEmail(
        matchOptions: MatchOptions,
        count?: number,
        inboxId?: string,
        timeout?: number,
        unreadOnly?: boolean,
        options?: any
    ) {
        return WaitForControllerApiFp(this.configuration).waitForMatchingEmail(
            matchOptions,
            count,
            inboxId,
            timeout,
            unreadOnly,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * Perform a search of emails in an inbox with the given patterns. If a result if found then return or else retry the search until a result is found or timeout is reached. Match options allow simple CONTAINS or EQUALS filtering on SUBJECT, TO, BCC, CC, and FROM. See the `MatchOptions` object for options. An example payload is `{ matches: [{field: 'SUBJECT',should:'CONTAIN',value:'needle'}] }`. You can use an array of matches and they will be applied sequentially to filter out emails. If you want to perform matches and extractions of content using Regex patterns see the EmailController `getEmailContentMatch` method.
     * @summary Wait for or return the first email that matches proved MatchOptions array
     * @param {MatchOptions} matchOptions matchOptions
     * @param {string} [inboxId] Id of the inbox we are matching an email for
     * @param {number} [timeout] Max milliseconds to wait
     * @param {boolean} [unreadOnly] Optional filter for unread only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitForControllerApi
     */
    public waitForMatchingFirstEmail(
        matchOptions: MatchOptions,
        inboxId?: string,
        timeout?: number,
        unreadOnly?: boolean,
        options?: any
    ) {
        return WaitForControllerApiFp(
            this.configuration
        ).waitForMatchingFirstEmail(
            matchOptions,
            inboxId,
            timeout,
            unreadOnly,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * If nth email is already present in inbox then return it. If not hold the connection open until timeout expires or the nth email is received and returned.
     * @summary Wait for or fetch the email with a given index in the inbox specified. IF indx doesn't exist waits for it to exist or timeout to occur.
     * @param {string} [inboxId] Id of the inbox you are fetching emails from
     * @param {number} [index] Zero based index of the email to wait for. If an inbox has 1 email already and you want to wait for the 2nd email pass index&#x3D;1
     * @param {number} [timeout] Max milliseconds to wait for the nth email if not already present
     * @param {boolean} [unreadOnly] Optional filter for unread only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WaitForControllerApi
     */
    public waitForNthEmail(
        inboxId?: string,
        index?: number,
        timeout?: number,
        unreadOnly?: boolean,
        options?: any
    ) {
        return WaitForControllerApiFp(this.configuration).waitForNthEmail(
            inboxId,
            index,
            timeout,
            unreadOnly,
            options
        )(this.fetch, this.basePath);
    }
}

/**
 * WebhookControllerApi - fetch parameter creator
 * @export
 */
export const WebhookControllerApiFetchParamCreator = function(
    configuration?: Configuration
) {
    return {
        /**
         * Get notified whenever an inbox receives an email via a WebHook URL. An emailID will be posted to this URL every time an email is received for this inbox. The URL must be publicly reachable by the MailSlurp server. You can provide basicAuth values if you wish to secure this endpoint.
         * @summary Attach a WebHook URL to an inbox
         * @param {string} inboxId inboxId
         * @param {CreateWebhookOptions} webhookOptions webhookOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook(
            inboxId: string,
            webhookOptions: CreateWebhookOptions,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError(
                    'inboxId',
                    'Required parameter inboxId was null or undefined when calling createWebhook.'
                );
            }
            // verify required parameter 'webhookOptions' is not null or undefined
            if (webhookOptions === null || webhookOptions === undefined) {
                throw new RequiredError(
                    'webhookOptions',
                    'Required parameter webhookOptions was null or undefined when calling createWebhook.'
                );
            }
            const localVarPath = `/inboxes/{inboxId}/webhooks`.replace(
                `{${'inboxId'}}`,
                encodeURIComponent(String(inboxId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'CreateWebhookOptions' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] ===
                    'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(webhookOptions || {})
                : webhookOptions || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete and disable a Webhook for an Inbox
         * @param {string} inboxId inboxId
         * @param {string} webhookId webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(
            inboxId: string,
            webhookId: string,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError(
                    'inboxId',
                    'Required parameter inboxId was null or undefined when calling deleteWebhook.'
                );
            }
            // verify required parameter 'webhookId' is not null or undefined
            if (webhookId === null || webhookId === undefined) {
                throw new RequiredError(
                    'webhookId',
                    'Required parameter webhookId was null or undefined when calling deleteWebhook.'
                );
            }
            const localVarPath = `/inboxes/{inboxId}/webhooks/{webhookId}`
                .replace(`{${'inboxId'}}`, encodeURIComponent(String(inboxId)))
                .replace(
                    `{${'webhookId'}}`,
                    encodeURIComponent(String(webhookId))
                );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'DELETE' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List webhooks in paginated form. Allows for page index, page size, and sort direction.
         * @summary List Webhooks Paginated
         * @param {number} [page] Optional page index in list pagination
         * @param {number} [size] Optional page size in list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWebhooks(
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options: any = {}
        ): FetchArgs {
            const localVarPath = `/webhooks/paginated`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get test webhook payload example. Response content depends on eventName passed. Uses `EMAIL_RECEIVED` as default.
         * @param {'EMAIL_RECEIVED' | 'NEW_EMAIL' | 'NEW_CONTACT' | 'NEW_ATTACHMENT'} [eventName] eventName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestWebhookPayload(
            eventName?:
                | 'EMAIL_RECEIVED'
                | 'NEW_EMAIL'
                | 'NEW_CONTACT'
                | 'NEW_ATTACHMENT',
            options: any = {}
        ): FetchArgs {
            const localVarPath = `/webhooks/test`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            if (eventName !== undefined) {
                localVarQueryParameter['eventName'] = eventName;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a webhook for an Inbox
         * @param {string} webhookId webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook(webhookId: string, options: any = {}): FetchArgs {
            // verify required parameter 'webhookId' is not null or undefined
            if (webhookId === null || webhookId === undefined) {
                throw new RequiredError(
                    'webhookId',
                    'Required parameter webhookId was null or undefined when calling getWebhook.'
                );
            }
            const localVarPath = `/webhooks/{webhookId}`.replace(
                `{${'webhookId'}}`,
                encodeURIComponent(String(webhookId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all webhooks for an Inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(inboxId: string, options: any = {}): FetchArgs {
            // verify required parameter 'inboxId' is not null or undefined
            if (inboxId === null || inboxId === undefined) {
                throw new RequiredError(
                    'inboxId',
                    'Required parameter inboxId was null or undefined when calling getWebhooks.'
                );
            }
            const localVarPath = `/inboxes/{inboxId}/webhooks`.replace(
                `{${'inboxId'}}`,
                encodeURIComponent(String(inboxId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'GET' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Send webhook test data
         * @param {string} webhookId webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTestData(webhookId: string, options: any = {}): FetchArgs {
            // verify required parameter 'webhookId' is not null or undefined
            if (webhookId === null || webhookId === undefined) {
                throw new RequiredError(
                    'webhookId',
                    'Required parameter webhookId was null or undefined when calling sendTestData.'
                );
            }
            const localVarPath = `/webhooks/{webhookId}/test`.replace(
                `{${'webhookId'}}`,
                encodeURIComponent(String(webhookId))
            );
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign(
                { method: 'POST' },
                options
            );
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API_KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue =
                    typeof configuration.apiKey === 'function'
                        ? configuration.apiKey('x-api-key')
                        : configuration.apiKey;
                localVarHeaderParameter['x-api-key'] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * WebhookControllerApi - functional programming interface
 * @export
 */
export const WebhookControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get notified whenever an inbox receives an email via a WebHook URL. An emailID will be posted to this URL every time an email is received for this inbox. The URL must be publicly reachable by the MailSlurp server. You can provide basicAuth values if you wish to secure this endpoint.
         * @summary Attach a WebHook URL to an inbox
         * @param {string} inboxId inboxId
         * @param {CreateWebhookOptions} webhookOptions webhookOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook(
            inboxId: string,
            webhookOptions: CreateWebhookOptions,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<WebhookDto> {
            const localVarFetchArgs = WebhookControllerApiFetchParamCreator(
                configuration
            ).createWebhook(inboxId, webhookOptions, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Delete and disable a Webhook for an Inbox
         * @param {string} inboxId inboxId
         * @param {string} webhookId webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(
            inboxId: string,
            webhookId: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = WebhookControllerApiFetchParamCreator(
                configuration
            ).deleteWebhook(inboxId, webhookId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List webhooks in paginated form. Allows for page index, page size, and sort direction.
         * @summary List Webhooks Paginated
         * @param {number} [page] Optional page index in list pagination
         * @param {number} [size] Optional page size in list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWebhooks(
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<PageWebhookProjection> {
            const localVarFetchArgs = WebhookControllerApiFetchParamCreator(
                configuration
            ).getAllWebhooks(page, size, sort, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get test webhook payload example. Response content depends on eventName passed. Uses `EMAIL_RECEIVED` as default.
         * @param {'EMAIL_RECEIVED' | 'NEW_EMAIL' | 'NEW_CONTACT' | 'NEW_ATTACHMENT'} [eventName] eventName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestWebhookPayload(
            eventName?:
                | 'EMAIL_RECEIVED'
                | 'NEW_EMAIL'
                | 'NEW_CONTACT'
                | 'NEW_ATTACHMENT',
            options?: any
        ): (
            fetch?: FetchAPI,
            basePath?: string
        ) => Promise<AbstractWebhookPayload> {
            const localVarFetchArgs = WebhookControllerApiFetchParamCreator(
                configuration
            ).getTestWebhookPayload(eventName, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get a webhook for an Inbox
         * @param {string} webhookId webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook(
            webhookId: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<WebhookDto> {
            const localVarFetchArgs = WebhookControllerApiFetchParamCreator(
                configuration
            ).getWebhook(webhookId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Get all webhooks for an Inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(
            inboxId: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<WebhookDto>> {
            const localVarFetchArgs = WebhookControllerApiFetchParamCreator(
                configuration
            ).getWebhooks(inboxId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *
         * @summary Send webhook test data
         * @param {string} webhookId webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTestData(
            webhookId: string,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<WebhookTestResult> {
            const localVarFetchArgs = WebhookControllerApiFetchParamCreator(
                configuration
            ).sendTestData(webhookId, options);
            return (
                fetch: FetchAPI = portableFetch,
                basePath: string = BASE_PATH
            ) => {
                return fetch(
                    basePath + localVarFetchArgs.url,
                    localVarFetchArgs.options
                ).then(response => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    };
};

/**
 * WebhookControllerApi - factory interface
 * @export
 */
export const WebhookControllerApiFactory = function(
    configuration?: Configuration,
    fetch?: FetchAPI,
    basePath?: string
) {
    return {
        /**
         * Get notified whenever an inbox receives an email via a WebHook URL. An emailID will be posted to this URL every time an email is received for this inbox. The URL must be publicly reachable by the MailSlurp server. You can provide basicAuth values if you wish to secure this endpoint.
         * @summary Attach a WebHook URL to an inbox
         * @param {string} inboxId inboxId
         * @param {CreateWebhookOptions} webhookOptions webhookOptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook(
            inboxId: string,
            webhookOptions: CreateWebhookOptions,
            options?: any
        ) {
            return WebhookControllerApiFp(configuration).createWebhook(
                inboxId,
                webhookOptions,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Delete and disable a Webhook for an Inbox
         * @param {string} inboxId inboxId
         * @param {string} webhookId webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWebhook(inboxId: string, webhookId: string, options?: any) {
            return WebhookControllerApiFp(configuration).deleteWebhook(
                inboxId,
                webhookId,
                options
            )(fetch, basePath);
        },
        /**
         * List webhooks in paginated form. Allows for page index, page size, and sort direction.
         * @summary List Webhooks Paginated
         * @param {number} [page] Optional page index in list pagination
         * @param {number} [size] Optional page size in list pagination
         * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllWebhooks(
            page?: number,
            size?: number,
            sort?: 'ASC' | 'DESC',
            options?: any
        ) {
            return WebhookControllerApiFp(configuration).getAllWebhooks(
                page,
                size,
                sort,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Get test webhook payload example. Response content depends on eventName passed. Uses `EMAIL_RECEIVED` as default.
         * @param {'EMAIL_RECEIVED' | 'NEW_EMAIL' | 'NEW_CONTACT' | 'NEW_ATTACHMENT'} [eventName] eventName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTestWebhookPayload(
            eventName?:
                | 'EMAIL_RECEIVED'
                | 'NEW_EMAIL'
                | 'NEW_CONTACT'
                | 'NEW_ATTACHMENT',
            options?: any
        ) {
            return WebhookControllerApiFp(configuration).getTestWebhookPayload(
                eventName,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Get a webhook for an Inbox
         * @param {string} webhookId webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhook(webhookId: string, options?: any) {
            return WebhookControllerApiFp(configuration).getWebhook(
                webhookId,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Get all webhooks for an Inbox
         * @param {string} inboxId inboxId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(inboxId: string, options?: any) {
            return WebhookControllerApiFp(configuration).getWebhooks(
                inboxId,
                options
            )(fetch, basePath);
        },
        /**
         *
         * @summary Send webhook test data
         * @param {string} webhookId webhookId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTestData(webhookId: string, options?: any) {
            return WebhookControllerApiFp(configuration).sendTestData(
                webhookId,
                options
            )(fetch, basePath);
        },
    };
};

/**
 * WebhookControllerApi - object-oriented interface
 * @export
 * @class WebhookControllerApi
 * @extends {BaseAPI}
 */
export class WebhookControllerApi extends BaseAPI {
    /**
     * Get notified whenever an inbox receives an email via a WebHook URL. An emailID will be posted to this URL every time an email is received for this inbox. The URL must be publicly reachable by the MailSlurp server. You can provide basicAuth values if you wish to secure this endpoint.
     * @summary Attach a WebHook URL to an inbox
     * @param {string} inboxId inboxId
     * @param {CreateWebhookOptions} webhookOptions webhookOptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookControllerApi
     */
    public createWebhook(
        inboxId: string,
        webhookOptions: CreateWebhookOptions,
        options?: any
    ) {
        return WebhookControllerApiFp(this.configuration).createWebhook(
            inboxId,
            webhookOptions,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Delete and disable a Webhook for an Inbox
     * @param {string} inboxId inboxId
     * @param {string} webhookId webhookId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookControllerApi
     */
    public deleteWebhook(inboxId: string, webhookId: string, options?: any) {
        return WebhookControllerApiFp(this.configuration).deleteWebhook(
            inboxId,
            webhookId,
            options
        )(this.fetch, this.basePath);
    }

    /**
     * List webhooks in paginated form. Allows for page index, page size, and sort direction.
     * @summary List Webhooks Paginated
     * @param {number} [page] Optional page index in list pagination
     * @param {number} [size] Optional page size in list pagination
     * @param {'ASC' | 'DESC'} [sort] Optional createdAt sort direction ASC or DESC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookControllerApi
     */
    public getAllWebhooks(
        page?: number,
        size?: number,
        sort?: 'ASC' | 'DESC',
        options?: any
    ) {
        return WebhookControllerApiFp(this.configuration).getAllWebhooks(
            page,
            size,
            sort,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get test webhook payload example. Response content depends on eventName passed. Uses `EMAIL_RECEIVED` as default.
     * @param {'EMAIL_RECEIVED' | 'NEW_EMAIL' | 'NEW_CONTACT' | 'NEW_ATTACHMENT'} [eventName] eventName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookControllerApi
     */
    public getTestWebhookPayload(
        eventName?:
            | 'EMAIL_RECEIVED'
            | 'NEW_EMAIL'
            | 'NEW_CONTACT'
            | 'NEW_ATTACHMENT',
        options?: any
    ) {
        return WebhookControllerApiFp(this.configuration).getTestWebhookPayload(
            eventName,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get a webhook for an Inbox
     * @param {string} webhookId webhookId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookControllerApi
     */
    public getWebhook(webhookId: string, options?: any) {
        return WebhookControllerApiFp(this.configuration).getWebhook(
            webhookId,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Get all webhooks for an Inbox
     * @param {string} inboxId inboxId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookControllerApi
     */
    public getWebhooks(inboxId: string, options?: any) {
        return WebhookControllerApiFp(this.configuration).getWebhooks(
            inboxId,
            options
        )(this.fetch, this.basePath);
    }

    /**
     *
     * @summary Send webhook test data
     * @param {string} webhookId webhookId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookControllerApi
     */
    public sendTestData(webhookId: string, options?: any) {
        return WebhookControllerApiFp(this.configuration).sendTestData(
            webhookId,
            options
        )(this.fetch, this.basePath);
    }
}
