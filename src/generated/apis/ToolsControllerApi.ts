/* tslint:disable */
/* eslint-disable */
/**
 * MailSlurp API
 * MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It\'s designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  CheckEmailFeaturesClientSupportOptions,
  CheckEmailFeaturesClientSupportResults,
  FakeEmailPreview,
  FakeEmailResult,
  GenerateBimiRecordOptions,
  GenerateBimiRecordResults,
  GenerateDmarcRecordOptions,
  GenerateDmarcRecordResults,
  GenerateMtaStsRecordOptions,
  GenerateMtaStsRecordResults,
  GenerateTlsReportingRecordOptions,
  GenerateTlsReportingRecordResults,
  LookupBimiDomainOptions,
  LookupBimiDomainResults,
  LookupDmarcDomainOptions,
  LookupDmarcDomainResults,
  LookupMtaStsDomainOptions,
  LookupMtaStsDomainResults,
  LookupTlsReportingDomainOptions,
  LookupTlsReportingDomainResults,
  NewFakeEmailAddressResult,
} from '../models/index';
import {
    CheckEmailFeaturesClientSupportOptionsFromJSON,
    CheckEmailFeaturesClientSupportOptionsToJSON,
    CheckEmailFeaturesClientSupportResultsFromJSON,
    CheckEmailFeaturesClientSupportResultsToJSON,
    FakeEmailPreviewFromJSON,
    FakeEmailPreviewToJSON,
    FakeEmailResultFromJSON,
    FakeEmailResultToJSON,
    GenerateBimiRecordOptionsFromJSON,
    GenerateBimiRecordOptionsToJSON,
    GenerateBimiRecordResultsFromJSON,
    GenerateBimiRecordResultsToJSON,
    GenerateDmarcRecordOptionsFromJSON,
    GenerateDmarcRecordOptionsToJSON,
    GenerateDmarcRecordResultsFromJSON,
    GenerateDmarcRecordResultsToJSON,
    GenerateMtaStsRecordOptionsFromJSON,
    GenerateMtaStsRecordOptionsToJSON,
    GenerateMtaStsRecordResultsFromJSON,
    GenerateMtaStsRecordResultsToJSON,
    GenerateTlsReportingRecordOptionsFromJSON,
    GenerateTlsReportingRecordOptionsToJSON,
    GenerateTlsReportingRecordResultsFromJSON,
    GenerateTlsReportingRecordResultsToJSON,
    LookupBimiDomainOptionsFromJSON,
    LookupBimiDomainOptionsToJSON,
    LookupBimiDomainResultsFromJSON,
    LookupBimiDomainResultsToJSON,
    LookupDmarcDomainOptionsFromJSON,
    LookupDmarcDomainOptionsToJSON,
    LookupDmarcDomainResultsFromJSON,
    LookupDmarcDomainResultsToJSON,
    LookupMtaStsDomainOptionsFromJSON,
    LookupMtaStsDomainOptionsToJSON,
    LookupMtaStsDomainResultsFromJSON,
    LookupMtaStsDomainResultsToJSON,
    LookupTlsReportingDomainOptionsFromJSON,
    LookupTlsReportingDomainOptionsToJSON,
    LookupTlsReportingDomainResultsFromJSON,
    LookupTlsReportingDomainResultsToJSON,
    NewFakeEmailAddressResultFromJSON,
    NewFakeEmailAddressResultToJSON,
} from '../models/index';

export interface CheckEmailFeaturesClientSupportRequest {
    checkEmailFeaturesClientSupportOptions: CheckEmailFeaturesClientSupportOptions;
}

export interface DeleteNewFakeEmailAddressRequest {
    emailAddress: string;
}

export interface GenerateBimiRecordRequest {
    generateBimiRecordOptions: GenerateBimiRecordOptions;
}

export interface GenerateDmarcRecordRequest {
    generateDmarcRecordOptions: GenerateDmarcRecordOptions;
}

export interface GenerateMtaStsRecordRequest {
    generateMtaStsRecordOptions: GenerateMtaStsRecordOptions;
}

export interface GenerateTlsReportingRecordRequest {
    generateTlsReportingRecordOptions: GenerateTlsReportingRecordOptions;
}

export interface GetFakeEmailByEmailAddressRequest {
    emailAddress: string;
}

export interface GetFakeEmailByIdRequest {
    id: string;
}

export interface GetFakeEmailRawRequest {
    id: string;
}

export interface GetFakeEmailsForAddressRequest {
    emailAddress: string;
    page?: number;
}

export interface LookupBimiDomainRequest {
    lookupBimiDomainOptions: LookupBimiDomainOptions;
}

export interface LookupDmarcDomainRequest {
    lookupDmarcDomainOptions: LookupDmarcDomainOptions;
}

export interface LookupMtaStsDomainRequest {
    lookupMtaStsDomainOptions: LookupMtaStsDomainOptions;
}

export interface LookupTlsReportingDomainRequest {
    lookupTlsReportingDomainOptions: LookupTlsReportingDomainOptions;
}

/**
 * 
 */
export class ToolsControllerApi extends runtime.BaseAPI {

    /**
     * Check email client support for email HTML and CSS features
     */
    async checkEmailFeaturesClientSupportRaw(requestParameters: CheckEmailFeaturesClientSupportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CheckEmailFeaturesClientSupportResults>> {
        if (requestParameters['checkEmailFeaturesClientSupportOptions'] == null) {
            throw new runtime.RequiredError(
                'checkEmailFeaturesClientSupportOptions',
                'Required parameter "checkEmailFeaturesClientSupportOptions" was null or undefined when calling checkEmailFeaturesClientSupport().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = await this.configuration.apiKey("x-api-key"); // API_KEY authentication
        }

        const response = await this.request({
            path: `/tools/check-email-features-client-support`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CheckEmailFeaturesClientSupportOptionsToJSON(requestParameters['checkEmailFeaturesClientSupportOptions']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CheckEmailFeaturesClientSupportResultsFromJSON(jsonValue));
    }

    /**
     * Check email client support for email HTML and CSS features
     */
    async checkEmailFeaturesClientSupport(requestParameters: CheckEmailFeaturesClientSupportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CheckEmailFeaturesClientSupportResults> {
        const response = await this.checkEmailFeaturesClientSupportRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new email address using the fake email domains
     */
    async createNewFakeEmailAddressRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NewFakeEmailAddressResult>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = await this.configuration.apiKey("x-api-key"); // API_KEY authentication
        }

        const response = await this.request({
            path: `/tools/fake-email`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NewFakeEmailAddressResultFromJSON(jsonValue));
    }

    /**
     * Create a new email address using the fake email domains
     */
    async createNewFakeEmailAddress(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NewFakeEmailAddressResult> {
        const response = await this.createNewFakeEmailAddressRaw(initOverrides);
        return await response.value();
    }

    /**
     * Delete a fake email address using the fake email domains
     */
    async deleteNewFakeEmailAddressRaw(requestParameters: DeleteNewFakeEmailAddressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['emailAddress'] == null) {
            throw new runtime.RequiredError(
                'emailAddress',
                'Required parameter "emailAddress" was null or undefined when calling deleteNewFakeEmailAddress().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['emailAddress'] != null) {
            queryParameters['emailAddress'] = requestParameters['emailAddress'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = await this.configuration.apiKey("x-api-key"); // API_KEY authentication
        }

        const response = await this.request({
            path: `/tools/fake-email`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a fake email address using the fake email domains
     */
    async deleteNewFakeEmailAddress(requestParameters: DeleteNewFakeEmailAddressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteNewFakeEmailAddressRaw(requestParameters, initOverrides);
    }

    /**
     * Create a BIMI record policy
     */
    async generateBimiRecordRaw(requestParameters: GenerateBimiRecordRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GenerateBimiRecordResults>> {
        if (requestParameters['generateBimiRecordOptions'] == null) {
            throw new runtime.RequiredError(
                'generateBimiRecordOptions',
                'Required parameter "generateBimiRecordOptions" was null or undefined when calling generateBimiRecord().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = await this.configuration.apiKey("x-api-key"); // API_KEY authentication
        }

        const response = await this.request({
            path: `/tools/generate-bimi-record`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: GenerateBimiRecordOptionsToJSON(requestParameters['generateBimiRecordOptions']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GenerateBimiRecordResultsFromJSON(jsonValue));
    }

    /**
     * Create a BIMI record policy
     */
    async generateBimiRecord(requestParameters: GenerateBimiRecordRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GenerateBimiRecordResults> {
        const response = await this.generateBimiRecordRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a DMARC record policy
     */
    async generateDmarcRecordRaw(requestParameters: GenerateDmarcRecordRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GenerateDmarcRecordResults>> {
        if (requestParameters['generateDmarcRecordOptions'] == null) {
            throw new runtime.RequiredError(
                'generateDmarcRecordOptions',
                'Required parameter "generateDmarcRecordOptions" was null or undefined when calling generateDmarcRecord().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = await this.configuration.apiKey("x-api-key"); // API_KEY authentication
        }

        const response = await this.request({
            path: `/tools/generate-dmarc-record`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: GenerateDmarcRecordOptionsToJSON(requestParameters['generateDmarcRecordOptions']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GenerateDmarcRecordResultsFromJSON(jsonValue));
    }

    /**
     * Create a DMARC record policy
     */
    async generateDmarcRecord(requestParameters: GenerateDmarcRecordRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GenerateDmarcRecordResults> {
        const response = await this.generateDmarcRecordRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a TLS reporting record policy
     */
    async generateMtaStsRecordRaw(requestParameters: GenerateMtaStsRecordRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GenerateMtaStsRecordResults>> {
        if (requestParameters['generateMtaStsRecordOptions'] == null) {
            throw new runtime.RequiredError(
                'generateMtaStsRecordOptions',
                'Required parameter "generateMtaStsRecordOptions" was null or undefined when calling generateMtaStsRecord().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = await this.configuration.apiKey("x-api-key"); // API_KEY authentication
        }

        const response = await this.request({
            path: `/tools/generate-mta-sts-record`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: GenerateMtaStsRecordOptionsToJSON(requestParameters['generateMtaStsRecordOptions']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GenerateMtaStsRecordResultsFromJSON(jsonValue));
    }

    /**
     * Create a TLS reporting record policy
     */
    async generateMtaStsRecord(requestParameters: GenerateMtaStsRecordRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GenerateMtaStsRecordResults> {
        const response = await this.generateMtaStsRecordRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a TLS reporting record policy
     */
    async generateTlsReportingRecordRaw(requestParameters: GenerateTlsReportingRecordRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GenerateTlsReportingRecordResults>> {
        if (requestParameters['generateTlsReportingRecordOptions'] == null) {
            throw new runtime.RequiredError(
                'generateTlsReportingRecordOptions',
                'Required parameter "generateTlsReportingRecordOptions" was null or undefined when calling generateTlsReportingRecord().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = await this.configuration.apiKey("x-api-key"); // API_KEY authentication
        }

        const response = await this.request({
            path: `/tools/generate-tls-reporting-record`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: GenerateTlsReportingRecordOptionsToJSON(requestParameters['generateTlsReportingRecordOptions']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GenerateTlsReportingRecordResultsFromJSON(jsonValue));
    }

    /**
     * Create a TLS reporting record policy
     */
    async generateTlsReportingRecord(requestParameters: GenerateTlsReportingRecordRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GenerateTlsReportingRecordResults> {
        const response = await this.generateTlsReportingRecordRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async getFakeEmailByEmailAddressRaw(requestParameters: GetFakeEmailByEmailAddressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FakeEmailResult>> {
        if (requestParameters['emailAddress'] == null) {
            throw new runtime.RequiredError(
                'emailAddress',
                'Required parameter "emailAddress" was null or undefined when calling getFakeEmailByEmailAddress().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['emailAddress'] != null) {
            queryParameters['emailAddress'] = requestParameters['emailAddress'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = await this.configuration.apiKey("x-api-key"); // API_KEY authentication
        }

        const response = await this.request({
            path: `/tools/fake-email/byEmailAddress`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FakeEmailResultFromJSON(jsonValue));
    }

    /**
     */
    async getFakeEmailByEmailAddress(requestParameters: GetFakeEmailByEmailAddressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FakeEmailResult> {
        const response = await this.getFakeEmailByEmailAddressRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async getFakeEmailByIdRaw(requestParameters: GetFakeEmailByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FakeEmailResult>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getFakeEmailById().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['id'] != null) {
            queryParameters['id'] = requestParameters['id'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = await this.configuration.apiKey("x-api-key"); // API_KEY authentication
        }

        const response = await this.request({
            path: `/tools/fake-email`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FakeEmailResultFromJSON(jsonValue));
    }

    /**
     */
    async getFakeEmailById(requestParameters: GetFakeEmailByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FakeEmailResult> {
        const response = await this.getFakeEmailByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async getFakeEmailRawRaw(requestParameters: GetFakeEmailRawRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getFakeEmailRaw().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['id'] != null) {
            queryParameters['id'] = requestParameters['id'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = await this.configuration.apiKey("x-api-key"); // API_KEY authentication
        }

        const response = await this.request({
            path: `/tools/fake-email/html`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     */
    async getFakeEmailRaw(requestParameters: GetFakeEmailRawRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.getFakeEmailRawRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async getFakeEmailsForAddressRaw(requestParameters: GetFakeEmailsForAddressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<FakeEmailPreview>>> {
        if (requestParameters['emailAddress'] == null) {
            throw new runtime.RequiredError(
                'emailAddress',
                'Required parameter "emailAddress" was null or undefined when calling getFakeEmailsForAddress().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['page'] != null) {
            queryParameters['page'] = requestParameters['page'];
        }

        if (requestParameters['emailAddress'] != null) {
            queryParameters['emailAddress'] = requestParameters['emailAddress'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = await this.configuration.apiKey("x-api-key"); // API_KEY authentication
        }

        const response = await this.request({
            path: `/tools/fake-emails`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(FakeEmailPreviewFromJSON));
    }

    /**
     */
    async getFakeEmailsForAddress(requestParameters: GetFakeEmailsForAddressRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<FakeEmailPreview>> {
        const response = await this.getFakeEmailsForAddressRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Lookup a BIMI record policy
     */
    async lookupBimiDomainRaw(requestParameters: LookupBimiDomainRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LookupBimiDomainResults>> {
        if (requestParameters['lookupBimiDomainOptions'] == null) {
            throw new runtime.RequiredError(
                'lookupBimiDomainOptions',
                'Required parameter "lookupBimiDomainOptions" was null or undefined when calling lookupBimiDomain().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = await this.configuration.apiKey("x-api-key"); // API_KEY authentication
        }

        const response = await this.request({
            path: `/tools/lookup-bimi-domain`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LookupBimiDomainOptionsToJSON(requestParameters['lookupBimiDomainOptions']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LookupBimiDomainResultsFromJSON(jsonValue));
    }

    /**
     * Lookup a BIMI record policy
     */
    async lookupBimiDomain(requestParameters: LookupBimiDomainRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LookupBimiDomainResults> {
        const response = await this.lookupBimiDomainRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Lookup a DMARC record policy
     */
    async lookupDmarcDomainRaw(requestParameters: LookupDmarcDomainRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LookupDmarcDomainResults>> {
        if (requestParameters['lookupDmarcDomainOptions'] == null) {
            throw new runtime.RequiredError(
                'lookupDmarcDomainOptions',
                'Required parameter "lookupDmarcDomainOptions" was null or undefined when calling lookupDmarcDomain().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = await this.configuration.apiKey("x-api-key"); // API_KEY authentication
        }

        const response = await this.request({
            path: `/tools/lookup-dmarc-domain`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LookupDmarcDomainOptionsToJSON(requestParameters['lookupDmarcDomainOptions']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LookupDmarcDomainResultsFromJSON(jsonValue));
    }

    /**
     * Lookup a DMARC record policy
     */
    async lookupDmarcDomain(requestParameters: LookupDmarcDomainRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LookupDmarcDomainResults> {
        const response = await this.lookupDmarcDomainRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Lookup a MTA-STS domain policy
     */
    async lookupMtaStsDomainRaw(requestParameters: LookupMtaStsDomainRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LookupMtaStsDomainResults>> {
        if (requestParameters['lookupMtaStsDomainOptions'] == null) {
            throw new runtime.RequiredError(
                'lookupMtaStsDomainOptions',
                'Required parameter "lookupMtaStsDomainOptions" was null or undefined when calling lookupMtaStsDomain().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = await this.configuration.apiKey("x-api-key"); // API_KEY authentication
        }

        const response = await this.request({
            path: `/tools/lookup-mta-sts-domain`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LookupMtaStsDomainOptionsToJSON(requestParameters['lookupMtaStsDomainOptions']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LookupMtaStsDomainResultsFromJSON(jsonValue));
    }

    /**
     * Lookup a MTA-STS domain policy
     */
    async lookupMtaStsDomain(requestParameters: LookupMtaStsDomainRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LookupMtaStsDomainResults> {
        const response = await this.lookupMtaStsDomainRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Lookup a TLS reporting domain policy
     */
    async lookupTlsReportingDomainRaw(requestParameters: LookupTlsReportingDomainRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LookupTlsReportingDomainResults>> {
        if (requestParameters['lookupTlsReportingDomainOptions'] == null) {
            throw new runtime.RequiredError(
                'lookupTlsReportingDomainOptions',
                'Required parameter "lookupTlsReportingDomainOptions" was null or undefined when calling lookupTlsReportingDomain().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-api-key"] = await this.configuration.apiKey("x-api-key"); // API_KEY authentication
        }

        const response = await this.request({
            path: `/tools/lookup-tls-reporting-domain`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LookupTlsReportingDomainOptionsToJSON(requestParameters['lookupTlsReportingDomainOptions']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LookupTlsReportingDomainResultsFromJSON(jsonValue));
    }

    /**
     * Lookup a TLS reporting domain policy
     */
    async lookupTlsReportingDomain(requestParameters: LookupTlsReportingDomainRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LookupTlsReportingDomainResults> {
        const response = await this.lookupTlsReportingDomainRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
