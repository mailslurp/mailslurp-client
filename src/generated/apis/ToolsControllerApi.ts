/* tslint:disable */
/* eslint-disable */
/**
 * MailSlurp API
 * MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It\'s designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from '../runtime';
import {
  CheckEmailFeaturesClientSupportOptions,
  CheckEmailFeaturesClientSupportOptionsFromJSON,
  CheckEmailFeaturesClientSupportOptionsToJSON,
  CheckEmailFeaturesClientSupportResults,
  CheckEmailFeaturesClientSupportResultsFromJSON,
  CheckEmailFeaturesClientSupportResultsToJSON,
  GenerateBimiRecordOptions,
  GenerateBimiRecordOptionsFromJSON,
  GenerateBimiRecordOptionsToJSON,
  GenerateBimiRecordResults,
  GenerateBimiRecordResultsFromJSON,
  GenerateBimiRecordResultsToJSON,
  GenerateDmarcRecordOptions,
  GenerateDmarcRecordOptionsFromJSON,
  GenerateDmarcRecordOptionsToJSON,
  GenerateDmarcRecordResults,
  GenerateDmarcRecordResultsFromJSON,
  GenerateDmarcRecordResultsToJSON,
  GenerateMtaStsRecordOptions,
  GenerateMtaStsRecordOptionsFromJSON,
  GenerateMtaStsRecordOptionsToJSON,
  GenerateMtaStsRecordResults,
  GenerateMtaStsRecordResultsFromJSON,
  GenerateMtaStsRecordResultsToJSON,
  GenerateTlsReportingRecordOptions,
  GenerateTlsReportingRecordOptionsFromJSON,
  GenerateTlsReportingRecordOptionsToJSON,
  GenerateTlsReportingRecordResults,
  GenerateTlsReportingRecordResultsFromJSON,
  GenerateTlsReportingRecordResultsToJSON,
  LookupBimiDomainOptions,
  LookupBimiDomainOptionsFromJSON,
  LookupBimiDomainOptionsToJSON,
  LookupBimiDomainResults,
  LookupBimiDomainResultsFromJSON,
  LookupBimiDomainResultsToJSON,
  LookupDmarcDomainOptions,
  LookupDmarcDomainOptionsFromJSON,
  LookupDmarcDomainOptionsToJSON,
  LookupDmarcDomainResults,
  LookupDmarcDomainResultsFromJSON,
  LookupDmarcDomainResultsToJSON,
  LookupMtaStsDomainOptions,
  LookupMtaStsDomainOptionsFromJSON,
  LookupMtaStsDomainOptionsToJSON,
  LookupMtaStsDomainResults,
  LookupMtaStsDomainResultsFromJSON,
  LookupMtaStsDomainResultsToJSON,
  LookupTlsReportingDomainOptions,
  LookupTlsReportingDomainOptionsFromJSON,
  LookupTlsReportingDomainOptionsToJSON,
  LookupTlsReportingDomainResults,
  LookupTlsReportingDomainResultsFromJSON,
  LookupTlsReportingDomainResultsToJSON,
} from '../models';

export interface CheckEmailFeaturesClientSupportRequest {
  checkEmailFeaturesClientSupportOptions: CheckEmailFeaturesClientSupportOptions;
}

export interface GenerateBimiRecordRequest {
  generateBimiRecordOptions: GenerateBimiRecordOptions;
}

export interface GenerateDmarcRecordRequest {
  generateDmarcRecordOptions: GenerateDmarcRecordOptions;
}

export interface GenerateMtaStsRecordRequest {
  generateMtaStsRecordOptions: GenerateMtaStsRecordOptions;
}

export interface GenerateTlsReportingRecordRequest {
  generateTlsReportingRecordOptions: GenerateTlsReportingRecordOptions;
}

export interface LookupBimiDomainRequest {
  lookupBimiDomainOptions: LookupBimiDomainOptions;
}

export interface LookupDmarcDomainRequest {
  lookupDmarcDomainOptions: LookupDmarcDomainOptions;
}

export interface LookupMtaStsDomainRequest {
  lookupMtaStsDomainOptions: LookupMtaStsDomainOptions;
}

export interface LookupTlsReportingDomainRequest {
  lookupTlsReportingDomainOptions: LookupTlsReportingDomainOptions;
}

/**
 *
 */
export class ToolsControllerApi extends runtime.BaseAPI {
  /**
   * Check email client support for email HTML and CSS features
   */
  async checkEmailFeaturesClientSupportRaw(
    requestParameters: CheckEmailFeaturesClientSupportRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<CheckEmailFeaturesClientSupportResults>> {
    if (
      requestParameters.checkEmailFeaturesClientSupportOptions === null ||
      requestParameters.checkEmailFeaturesClientSupportOptions === undefined
    ) {
      throw new runtime.RequiredError(
        'checkEmailFeaturesClientSupportOptions',
        'Required parameter requestParameters.checkEmailFeaturesClientSupportOptions was null or undefined when calling checkEmailFeaturesClientSupport.'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['x-api-key'] = this.configuration.apiKey('x-api-key'); // API_KEY authentication
    }

    const response = await this.request(
      {
        path: `/tools/check-email-features-client-support`,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: CheckEmailFeaturesClientSupportOptionsToJSON(
          requestParameters.checkEmailFeaturesClientSupportOptions
        ),
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      CheckEmailFeaturesClientSupportResultsFromJSON(jsonValue)
    );
  }

  /**
   * Check email client support for email HTML and CSS features
   */
  async checkEmailFeaturesClientSupport(
    requestParameters: CheckEmailFeaturesClientSupportRequest,
    initOverrides?: RequestInit
  ): Promise<CheckEmailFeaturesClientSupportResults> {
    const response = await this.checkEmailFeaturesClientSupportRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Create a BIMI record policy
   */
  async generateBimiRecordRaw(
    requestParameters: GenerateBimiRecordRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<GenerateBimiRecordResults>> {
    if (
      requestParameters.generateBimiRecordOptions === null ||
      requestParameters.generateBimiRecordOptions === undefined
    ) {
      throw new runtime.RequiredError(
        'generateBimiRecordOptions',
        'Required parameter requestParameters.generateBimiRecordOptions was null or undefined when calling generateBimiRecord.'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['x-api-key'] = this.configuration.apiKey('x-api-key'); // API_KEY authentication
    }

    const response = await this.request(
      {
        path: `/tools/generate-bimi-record`,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: GenerateBimiRecordOptionsToJSON(
          requestParameters.generateBimiRecordOptions
        ),
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      GenerateBimiRecordResultsFromJSON(jsonValue)
    );
  }

  /**
   * Create a BIMI record policy
   */
  async generateBimiRecord(
    requestParameters: GenerateBimiRecordRequest,
    initOverrides?: RequestInit
  ): Promise<GenerateBimiRecordResults> {
    const response = await this.generateBimiRecordRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Create a DMARC record policy
   */
  async generateDmarcRecordRaw(
    requestParameters: GenerateDmarcRecordRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<GenerateDmarcRecordResults>> {
    if (
      requestParameters.generateDmarcRecordOptions === null ||
      requestParameters.generateDmarcRecordOptions === undefined
    ) {
      throw new runtime.RequiredError(
        'generateDmarcRecordOptions',
        'Required parameter requestParameters.generateDmarcRecordOptions was null or undefined when calling generateDmarcRecord.'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['x-api-key'] = this.configuration.apiKey('x-api-key'); // API_KEY authentication
    }

    const response = await this.request(
      {
        path: `/tools/generate-dmarc-record`,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: GenerateDmarcRecordOptionsToJSON(
          requestParameters.generateDmarcRecordOptions
        ),
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      GenerateDmarcRecordResultsFromJSON(jsonValue)
    );
  }

  /**
   * Create a DMARC record policy
   */
  async generateDmarcRecord(
    requestParameters: GenerateDmarcRecordRequest,
    initOverrides?: RequestInit
  ): Promise<GenerateDmarcRecordResults> {
    const response = await this.generateDmarcRecordRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Create a TLS reporting record policy
   */
  async generateMtaStsRecordRaw(
    requestParameters: GenerateMtaStsRecordRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<GenerateMtaStsRecordResults>> {
    if (
      requestParameters.generateMtaStsRecordOptions === null ||
      requestParameters.generateMtaStsRecordOptions === undefined
    ) {
      throw new runtime.RequiredError(
        'generateMtaStsRecordOptions',
        'Required parameter requestParameters.generateMtaStsRecordOptions was null or undefined when calling generateMtaStsRecord.'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['x-api-key'] = this.configuration.apiKey('x-api-key'); // API_KEY authentication
    }

    const response = await this.request(
      {
        path: `/tools/generate-mta-sts-record`,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: GenerateMtaStsRecordOptionsToJSON(
          requestParameters.generateMtaStsRecordOptions
        ),
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      GenerateMtaStsRecordResultsFromJSON(jsonValue)
    );
  }

  /**
   * Create a TLS reporting record policy
   */
  async generateMtaStsRecord(
    requestParameters: GenerateMtaStsRecordRequest,
    initOverrides?: RequestInit
  ): Promise<GenerateMtaStsRecordResults> {
    const response = await this.generateMtaStsRecordRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Create a TLS reporting record policy
   */
  async generateTlsReportingRecordRaw(
    requestParameters: GenerateTlsReportingRecordRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<GenerateTlsReportingRecordResults>> {
    if (
      requestParameters.generateTlsReportingRecordOptions === null ||
      requestParameters.generateTlsReportingRecordOptions === undefined
    ) {
      throw new runtime.RequiredError(
        'generateTlsReportingRecordOptions',
        'Required parameter requestParameters.generateTlsReportingRecordOptions was null or undefined when calling generateTlsReportingRecord.'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['x-api-key'] = this.configuration.apiKey('x-api-key'); // API_KEY authentication
    }

    const response = await this.request(
      {
        path: `/tools/generate-tls-reporting-record`,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: GenerateTlsReportingRecordOptionsToJSON(
          requestParameters.generateTlsReportingRecordOptions
        ),
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      GenerateTlsReportingRecordResultsFromJSON(jsonValue)
    );
  }

  /**
   * Create a TLS reporting record policy
   */
  async generateTlsReportingRecord(
    requestParameters: GenerateTlsReportingRecordRequest,
    initOverrides?: RequestInit
  ): Promise<GenerateTlsReportingRecordResults> {
    const response = await this.generateTlsReportingRecordRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Lookup a BIMI record policy
   */
  async lookupBimiDomainRaw(
    requestParameters: LookupBimiDomainRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<LookupBimiDomainResults>> {
    if (
      requestParameters.lookupBimiDomainOptions === null ||
      requestParameters.lookupBimiDomainOptions === undefined
    ) {
      throw new runtime.RequiredError(
        'lookupBimiDomainOptions',
        'Required parameter requestParameters.lookupBimiDomainOptions was null or undefined when calling lookupBimiDomain.'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['x-api-key'] = this.configuration.apiKey('x-api-key'); // API_KEY authentication
    }

    const response = await this.request(
      {
        path: `/tools/lookup-bimi-domain`,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: LookupBimiDomainOptionsToJSON(
          requestParameters.lookupBimiDomainOptions
        ),
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      LookupBimiDomainResultsFromJSON(jsonValue)
    );
  }

  /**
   * Lookup a BIMI record policy
   */
  async lookupBimiDomain(
    requestParameters: LookupBimiDomainRequest,
    initOverrides?: RequestInit
  ): Promise<LookupBimiDomainResults> {
    const response = await this.lookupBimiDomainRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Lookup a DMARC record policy
   */
  async lookupDmarcDomainRaw(
    requestParameters: LookupDmarcDomainRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<LookupDmarcDomainResults>> {
    if (
      requestParameters.lookupDmarcDomainOptions === null ||
      requestParameters.lookupDmarcDomainOptions === undefined
    ) {
      throw new runtime.RequiredError(
        'lookupDmarcDomainOptions',
        'Required parameter requestParameters.lookupDmarcDomainOptions was null or undefined when calling lookupDmarcDomain.'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['x-api-key'] = this.configuration.apiKey('x-api-key'); // API_KEY authentication
    }

    const response = await this.request(
      {
        path: `/tools/lookup-dmarc-domain`,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: LookupDmarcDomainOptionsToJSON(
          requestParameters.lookupDmarcDomainOptions
        ),
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      LookupDmarcDomainResultsFromJSON(jsonValue)
    );
  }

  /**
   * Lookup a DMARC record policy
   */
  async lookupDmarcDomain(
    requestParameters: LookupDmarcDomainRequest,
    initOverrides?: RequestInit
  ): Promise<LookupDmarcDomainResults> {
    const response = await this.lookupDmarcDomainRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Lookup a MTA-STS domain policy
   */
  async lookupMtaStsDomainRaw(
    requestParameters: LookupMtaStsDomainRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<LookupMtaStsDomainResults>> {
    if (
      requestParameters.lookupMtaStsDomainOptions === null ||
      requestParameters.lookupMtaStsDomainOptions === undefined
    ) {
      throw new runtime.RequiredError(
        'lookupMtaStsDomainOptions',
        'Required parameter requestParameters.lookupMtaStsDomainOptions was null or undefined when calling lookupMtaStsDomain.'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['x-api-key'] = this.configuration.apiKey('x-api-key'); // API_KEY authentication
    }

    const response = await this.request(
      {
        path: `/tools/lookup-mta-sts-domain`,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: LookupMtaStsDomainOptionsToJSON(
          requestParameters.lookupMtaStsDomainOptions
        ),
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      LookupMtaStsDomainResultsFromJSON(jsonValue)
    );
  }

  /**
   * Lookup a MTA-STS domain policy
   */
  async lookupMtaStsDomain(
    requestParameters: LookupMtaStsDomainRequest,
    initOverrides?: RequestInit
  ): Promise<LookupMtaStsDomainResults> {
    const response = await this.lookupMtaStsDomainRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Lookup a TLS reporting domain policy
   */
  async lookupTlsReportingDomainRaw(
    requestParameters: LookupTlsReportingDomainRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<LookupTlsReportingDomainResults>> {
    if (
      requestParameters.lookupTlsReportingDomainOptions === null ||
      requestParameters.lookupTlsReportingDomainOptions === undefined
    ) {
      throw new runtime.RequiredError(
        'lookupTlsReportingDomainOptions',
        'Required parameter requestParameters.lookupTlsReportingDomainOptions was null or undefined when calling lookupTlsReportingDomain.'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['x-api-key'] = this.configuration.apiKey('x-api-key'); // API_KEY authentication
    }

    const response = await this.request(
      {
        path: `/tools/lookup-tls-reporting-domain`,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: LookupTlsReportingDomainOptionsToJSON(
          requestParameters.lookupTlsReportingDomainOptions
        ),
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      LookupTlsReportingDomainResultsFromJSON(jsonValue)
    );
  }

  /**
   * Lookup a TLS reporting domain policy
   */
  async lookupTlsReportingDomain(
    requestParameters: LookupTlsReportingDomainRequest,
    initOverrides?: RequestInit
  ): Promise<LookupTlsReportingDomainResults> {
    const response = await this.lookupTlsReportingDomainRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }
}
