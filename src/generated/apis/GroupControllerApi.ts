/* tslint:disable */
/* eslint-disable */
/**
 * MailSlurp API
 * MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It\'s designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://www.mailslurp.com/docs/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from '../runtime';
import {
    CreateGroupOptions,
    CreateGroupOptionsFromJSON,
    CreateGroupOptionsToJSON,
    GroupContactsDto,
    GroupContactsDtoFromJSON,
    GroupContactsDtoToJSON,
    GroupDto,
    GroupDtoFromJSON,
    GroupDtoToJSON,
    GroupProjection,
    GroupProjectionFromJSON,
    GroupProjectionToJSON,
    PageContactProjection,
    PageContactProjectionFromJSON,
    PageContactProjectionToJSON,
    PageGroupProjection,
    PageGroupProjectionFromJSON,
    PageGroupProjectionToJSON,
    UpdateGroupContacts,
    UpdateGroupContactsFromJSON,
    UpdateGroupContactsToJSON,
} from '../models';

export interface AddContactsToGroupRequest {
    groupId: string;
    updateGroupContactsOption: UpdateGroupContacts;
}

export interface CreateGroupRequest {
    createGroupOptions: CreateGroupOptions;
}

export interface DeleteGroupRequest {
    groupId: string;
}

export interface GetAllGroupsRequest {
    before?: Date;
    page?: number;
    since?: Date;
    size?: number;
    sort?: GetAllGroupsSortEnum;
}

export interface GetGroupRequest {
    groupId: string;
}

export interface GetGroupWithContactsRequest {
    groupId: string;
}

export interface GetGroupWithContactsPaginatedRequest {
    groupId: string;
    before?: Date;
    page?: number;
    since?: Date;
    size?: number;
    sort?: GetGroupWithContactsPaginatedSortEnum;
}

export interface RemoveContactsFromGroupRequest {
    groupId: string;
    updateGroupContactsOption: UpdateGroupContacts;
}

/**
 *
 */
export class GroupControllerApi extends runtime.BaseAPI {
    /**
     * Add contacts to a group
     */
    async addContactsToGroupRaw(
        requestParameters: AddContactsToGroupRequest
    ): Promise<runtime.ApiResponse<GroupContactsDto>> {
        if (
            requestParameters.groupId === null ||
            requestParameters.groupId === undefined
        ) {
            throw new runtime.RequiredError(
                'groupId',
                'Required parameter requestParameters.groupId was null or undefined when calling addContactsToGroup.'
            );
        }

        if (
            requestParameters.updateGroupContactsOption === null ||
            requestParameters.updateGroupContactsOption === undefined
        ) {
            throw new runtime.RequiredError(
                'updateGroupContactsOption',
                'Required parameter requestParameters.updateGroupContactsOption was null or undefined when calling addContactsToGroup.'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters['x-api-key'] = this.configuration.apiKey(
                'x-api-key'
            ); // API_KEY authentication
        }

        const response = await this.request({
            path: `/groups/{groupId}/contacts`.replace(
                `{${'groupId'}}`,
                encodeURIComponent(String(requestParameters.groupId))
            ),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateGroupContactsToJSON(
                requestParameters.updateGroupContactsOption
            ),
        });

        return new runtime.JSONApiResponse(response, jsonValue =>
            GroupContactsDtoFromJSON(jsonValue)
        );
    }

    /**
     * Add contacts to a group
     */
    async addContactsToGroup(
        requestParameters: AddContactsToGroupRequest
    ): Promise<GroupContactsDto> {
        const response = await this.addContactsToGroupRaw(requestParameters);
        return await response.value();
    }

    /**
     * Create a group
     */
    async createGroupRaw(
        requestParameters: CreateGroupRequest
    ): Promise<runtime.ApiResponse<GroupDto>> {
        if (
            requestParameters.createGroupOptions === null ||
            requestParameters.createGroupOptions === undefined
        ) {
            throw new runtime.RequiredError(
                'createGroupOptions',
                'Required parameter requestParameters.createGroupOptions was null or undefined when calling createGroup.'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters['x-api-key'] = this.configuration.apiKey(
                'x-api-key'
            ); // API_KEY authentication
        }

        const response = await this.request({
            path: `/groups`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateGroupOptionsToJSON(
                requestParameters.createGroupOptions
            ),
        });

        return new runtime.JSONApiResponse(response, jsonValue =>
            GroupDtoFromJSON(jsonValue)
        );
    }

    /**
     * Create a group
     */
    async createGroup(
        requestParameters: CreateGroupRequest
    ): Promise<GroupDto> {
        const response = await this.createGroupRaw(requestParameters);
        return await response.value();
    }

    /**
     * Delete group
     */
    async deleteGroupRaw(
        requestParameters: DeleteGroupRequest
    ): Promise<runtime.ApiResponse<void>> {
        if (
            requestParameters.groupId === null ||
            requestParameters.groupId === undefined
        ) {
            throw new runtime.RequiredError(
                'groupId',
                'Required parameter requestParameters.groupId was null or undefined when calling deleteGroup.'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters['x-api-key'] = this.configuration.apiKey(
                'x-api-key'
            ); // API_KEY authentication
        }

        const response = await this.request({
            path: `/groups/{groupId}`.replace(
                `{${'groupId'}}`,
                encodeURIComponent(String(requestParameters.groupId))
            ),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete group
     */
    async deleteGroup(requestParameters: DeleteGroupRequest): Promise<void> {
        await this.deleteGroupRaw(requestParameters);
    }

    /**
     * Get all Contact Groups in paginated format
     */
    async getAllGroupsRaw(
        requestParameters: GetAllGroupsRequest
    ): Promise<runtime.ApiResponse<PageGroupProjection>> {
        const queryParameters: any = {};

        if (requestParameters.before !== undefined) {
            queryParameters[
                'before'
            ] = (requestParameters.before as any).toISOString();
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.since !== undefined) {
            queryParameters[
                'since'
            ] = (requestParameters.since as any).toISOString();
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters['x-api-key'] = this.configuration.apiKey(
                'x-api-key'
            ); // API_KEY authentication
        }

        const response = await this.request({
            path: `/groups/paginated`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, jsonValue =>
            PageGroupProjectionFromJSON(jsonValue)
        );
    }

    /**
     * Get all Contact Groups in paginated format
     */
    async getAllGroups(
        requestParameters: GetAllGroupsRequest
    ): Promise<PageGroupProjection> {
        const response = await this.getAllGroupsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get group
     */
    async getGroupRaw(
        requestParameters: GetGroupRequest
    ): Promise<runtime.ApiResponse<GroupDto>> {
        if (
            requestParameters.groupId === null ||
            requestParameters.groupId === undefined
        ) {
            throw new runtime.RequiredError(
                'groupId',
                'Required parameter requestParameters.groupId was null or undefined when calling getGroup.'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters['x-api-key'] = this.configuration.apiKey(
                'x-api-key'
            ); // API_KEY authentication
        }

        const response = await this.request({
            path: `/groups/{groupId}`.replace(
                `{${'groupId'}}`,
                encodeURIComponent(String(requestParameters.groupId))
            ),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, jsonValue =>
            GroupDtoFromJSON(jsonValue)
        );
    }

    /**
     * Get group
     */
    async getGroup(requestParameters: GetGroupRequest): Promise<GroupDto> {
        const response = await this.getGroupRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get group and contacts belonging to it
     */
    async getGroupWithContactsRaw(
        requestParameters: GetGroupWithContactsRequest
    ): Promise<runtime.ApiResponse<GroupContactsDto>> {
        if (
            requestParameters.groupId === null ||
            requestParameters.groupId === undefined
        ) {
            throw new runtime.RequiredError(
                'groupId',
                'Required parameter requestParameters.groupId was null or undefined when calling getGroupWithContacts.'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters['x-api-key'] = this.configuration.apiKey(
                'x-api-key'
            ); // API_KEY authentication
        }

        const response = await this.request({
            path: `/groups/{groupId}/contacts`.replace(
                `{${'groupId'}}`,
                encodeURIComponent(String(requestParameters.groupId))
            ),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, jsonValue =>
            GroupContactsDtoFromJSON(jsonValue)
        );
    }

    /**
     * Get group and contacts belonging to it
     */
    async getGroupWithContacts(
        requestParameters: GetGroupWithContactsRequest
    ): Promise<GroupContactsDto> {
        const response = await this.getGroupWithContactsRaw(requestParameters);
        return await response.value();
    }

    /**
     * Get group and paginated contacts belonging to it
     */
    async getGroupWithContactsPaginatedRaw(
        requestParameters: GetGroupWithContactsPaginatedRequest
    ): Promise<runtime.ApiResponse<PageContactProjection>> {
        if (
            requestParameters.groupId === null ||
            requestParameters.groupId === undefined
        ) {
            throw new runtime.RequiredError(
                'groupId',
                'Required parameter requestParameters.groupId was null or undefined when calling getGroupWithContactsPaginated.'
            );
        }

        const queryParameters: any = {};

        if (requestParameters.before !== undefined) {
            queryParameters[
                'before'
            ] = (requestParameters.before as any).toISOString();
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.since !== undefined) {
            queryParameters[
                'since'
            ] = (requestParameters.since as any).toISOString();
        }

        if (requestParameters.size !== undefined) {
            queryParameters['size'] = requestParameters.size;
        }

        if (requestParameters.sort !== undefined) {
            queryParameters['sort'] = requestParameters.sort;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters['x-api-key'] = this.configuration.apiKey(
                'x-api-key'
            ); // API_KEY authentication
        }

        const response = await this.request({
            path: `/groups/{groupId}/contacts-paginated`.replace(
                `{${'groupId'}}`,
                encodeURIComponent(String(requestParameters.groupId))
            ),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, jsonValue =>
            PageContactProjectionFromJSON(jsonValue)
        );
    }

    /**
     * Get group and paginated contacts belonging to it
     */
    async getGroupWithContactsPaginated(
        requestParameters: GetGroupWithContactsPaginatedRequest
    ): Promise<PageContactProjection> {
        const response = await this.getGroupWithContactsPaginatedRaw(
            requestParameters
        );
        return await response.value();
    }

    /**
     * Get all groups
     */
    async getGroupsRaw(): Promise<runtime.ApiResponse<Array<GroupProjection>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters['x-api-key'] = this.configuration.apiKey(
                'x-api-key'
            ); // API_KEY authentication
        }

        const response = await this.request({
            path: `/groups`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, jsonValue =>
            jsonValue.map(GroupProjectionFromJSON)
        );
    }

    /**
     * Get all groups
     */
    async getGroups(): Promise<Array<GroupProjection>> {
        const response = await this.getGroupsRaw();
        return await response.value();
    }

    /**
     * Remove contacts from a group
     */
    async removeContactsFromGroupRaw(
        requestParameters: RemoveContactsFromGroupRequest
    ): Promise<runtime.ApiResponse<GroupContactsDto>> {
        if (
            requestParameters.groupId === null ||
            requestParameters.groupId === undefined
        ) {
            throw new runtime.RequiredError(
                'groupId',
                'Required parameter requestParameters.groupId was null or undefined when calling removeContactsFromGroup.'
            );
        }

        if (
            requestParameters.updateGroupContactsOption === null ||
            requestParameters.updateGroupContactsOption === undefined
        ) {
            throw new runtime.RequiredError(
                'updateGroupContactsOption',
                'Required parameter requestParameters.updateGroupContactsOption was null or undefined when calling removeContactsFromGroup.'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters['x-api-key'] = this.configuration.apiKey(
                'x-api-key'
            ); // API_KEY authentication
        }

        const response = await this.request({
            path: `/groups/{groupId}/contacts`.replace(
                `{${'groupId'}}`,
                encodeURIComponent(String(requestParameters.groupId))
            ),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateGroupContactsToJSON(
                requestParameters.updateGroupContactsOption
            ),
        });

        return new runtime.JSONApiResponse(response, jsonValue =>
            GroupContactsDtoFromJSON(jsonValue)
        );
    }

    /**
     * Remove contacts from a group
     */
    async removeContactsFromGroup(
        requestParameters: RemoveContactsFromGroupRequest
    ): Promise<GroupContactsDto> {
        const response = await this.removeContactsFromGroupRaw(
            requestParameters
        );
        return await response.value();
    }
}

/**
 * @export
 * @enum {string}
 */
export enum GetAllGroupsSortEnum {
    Asc = 'ASC',
    Desc = 'DESC',
}
/**
 * @export
 * @enum {string}
 */
export enum GetGroupWithContactsPaginatedSortEnum {
    Asc = 'ASC',
    Desc = 'DESC',
}
