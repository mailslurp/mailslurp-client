/* tslint:disable */
/* eslint-disable */
/**
 * MailSlurp API
 * MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It\'s designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from '../runtime';
import {
  ConnectorDto,
  ConnectorDtoFromJSON,
  ConnectorDtoToJSON,
  ConnectorSyncEventDto,
  ConnectorSyncEventDtoFromJSON,
  ConnectorSyncEventDtoToJSON,
  ConnectorSyncRequestResult,
  ConnectorSyncRequestResultFromJSON,
  ConnectorSyncRequestResultToJSON,
  CreateConnectorOptions,
  CreateConnectorOptionsFromJSON,
  CreateConnectorOptionsToJSON,
  PageConnector,
  PageConnectorFromJSON,
  PageConnectorToJSON,
  PageConnectorSyncEvents,
  PageConnectorSyncEventsFromJSON,
  PageConnectorSyncEventsToJSON,
} from '../models';

export interface CreateConnectorRequest {
  createConnectorOptions: CreateConnectorOptions;
}

export interface DeleteConnectorRequest {
  id: string;
}

export interface GetAllConnectorSyncEventsRequest {
  page?: number;
  size?: number;
  sort?: GetAllConnectorSyncEventsSortEnum;
  since?: Date;
  before?: Date;
}

export interface GetConnectorRequest {
  id: string;
}

export interface GetConnectorSyncEventRequest {
  id: string;
}

export interface GetConnectorSyncEventsRequest {
  id: string;
  page?: number;
  size?: number;
  sort?: GetConnectorSyncEventsSortEnum;
  since?: Date;
  before?: Date;
}

export interface GetConnectorsRequest {
  page?: number;
  size?: number;
  sort?: GetConnectorsSortEnum;
  since?: Date;
  before?: Date;
}

export interface SyncConnectorRequest {
  id: string;
}

export interface UpdateConnectorRequest {
  id: string;
  createConnectorOptions: CreateConnectorOptions;
}

/**
 *
 */
export class ConnectorControllerApi extends runtime.BaseAPI {
  /**
   * Sync emails between external mailboxes and MailSlurp inboxes
   * Create an inbox connector
   */
  async createConnectorRaw(
    requestParameters: CreateConnectorRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<ConnectorDto>> {
    if (
      requestParameters.createConnectorOptions === null ||
      requestParameters.createConnectorOptions === undefined
    ) {
      throw new runtime.RequiredError(
        'createConnectorOptions',
        'Required parameter requestParameters.createConnectorOptions was null or undefined when calling createConnector.'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['x-api-key'] = this.configuration.apiKey('x-api-key'); // API_KEY authentication
    }

    const response = await this.request(
      {
        path: `/connectors`,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: CreateConnectorOptionsToJSON(
          requestParameters.createConnectorOptions
        ),
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      ConnectorDtoFromJSON(jsonValue)
    );
  }

  /**
   * Sync emails between external mailboxes and MailSlurp inboxes
   * Create an inbox connector
   */
  async createConnector(
    requestParameters: CreateConnectorRequest,
    initOverrides?: RequestInit
  ): Promise<ConnectorDto> {
    const response = await this.createConnectorRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Delete an inbox connector
   */
  async deleteConnectorRaw(
    requestParameters: DeleteConnectorRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        'id',
        'Required parameter requestParameters.id was null or undefined when calling deleteConnector.'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['x-api-key'] = this.configuration.apiKey('x-api-key'); // API_KEY authentication
    }

    const response = await this.request(
      {
        path: `/connectors/{id}`.replace(
          `{${'id'}}`,
          encodeURIComponent(String(requestParameters.id))
        ),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Delete an inbox connector
   */
  async deleteConnector(
    requestParameters: DeleteConnectorRequest,
    initOverrides?: RequestInit
  ): Promise<void> {
    await this.deleteConnectorRaw(requestParameters, initOverrides);
  }

  /**
   * Get all inbox connector sync events
   */
  async getAllConnectorSyncEventsRaw(
    requestParameters: GetAllConnectorSyncEventsRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<PageConnectorSyncEvents>> {
    const queryParameters: any = {};

    if (requestParameters.page !== undefined) {
      queryParameters['page'] = requestParameters.page;
    }

    if (requestParameters.size !== undefined) {
      queryParameters['size'] = requestParameters.size;
    }

    if (requestParameters.sort !== undefined) {
      queryParameters['sort'] = requestParameters.sort;
    }

    if (requestParameters.since !== undefined) {
      queryParameters['since'] = (requestParameters.since as any).toISOString();
    }

    if (requestParameters.before !== undefined) {
      queryParameters['before'] = (
        requestParameters.before as any
      ).toISOString();
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['x-api-key'] = this.configuration.apiKey('x-api-key'); // API_KEY authentication
    }

    const response = await this.request(
      {
        path: `/connectors/events`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      PageConnectorSyncEventsFromJSON(jsonValue)
    );
  }

  /**
   * Get all inbox connector sync events
   */
  async getAllConnectorSyncEvents(
    requestParameters: GetAllConnectorSyncEventsRequest,
    initOverrides?: RequestInit
  ): Promise<PageConnectorSyncEvents> {
    const response = await this.getAllConnectorSyncEventsRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Get an inbox connector
   */
  async getConnectorRaw(
    requestParameters: GetConnectorRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<ConnectorDto>> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        'id',
        'Required parameter requestParameters.id was null or undefined when calling getConnector.'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['x-api-key'] = this.configuration.apiKey('x-api-key'); // API_KEY authentication
    }

    const response = await this.request(
      {
        path: `/connectors/{id}`.replace(
          `{${'id'}}`,
          encodeURIComponent(String(requestParameters.id))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      ConnectorDtoFromJSON(jsonValue)
    );
  }

  /**
   * Get an inbox connector
   */
  async getConnector(
    requestParameters: GetConnectorRequest,
    initOverrides?: RequestInit
  ): Promise<ConnectorDto> {
    const response = await this.getConnectorRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Get an inbox connector sync event
   */
  async getConnectorSyncEventRaw(
    requestParameters: GetConnectorSyncEventRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<ConnectorSyncEventDto>> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        'id',
        'Required parameter requestParameters.id was null or undefined when calling getConnectorSyncEvent.'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['x-api-key'] = this.configuration.apiKey('x-api-key'); // API_KEY authentication
    }

    const response = await this.request(
      {
        path: `/connectors/events/{id}`.replace(
          `{${'id'}}`,
          encodeURIComponent(String(requestParameters.id))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      ConnectorSyncEventDtoFromJSON(jsonValue)
    );
  }

  /**
   * Get an inbox connector sync event
   */
  async getConnectorSyncEvent(
    requestParameters: GetConnectorSyncEventRequest,
    initOverrides?: RequestInit
  ): Promise<ConnectorSyncEventDto> {
    const response = await this.getConnectorSyncEventRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Get an inbox connector sync events
   */
  async getConnectorSyncEventsRaw(
    requestParameters: GetConnectorSyncEventsRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<PageConnectorSyncEvents>> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        'id',
        'Required parameter requestParameters.id was null or undefined when calling getConnectorSyncEvents.'
      );
    }

    const queryParameters: any = {};

    if (requestParameters.page !== undefined) {
      queryParameters['page'] = requestParameters.page;
    }

    if (requestParameters.size !== undefined) {
      queryParameters['size'] = requestParameters.size;
    }

    if (requestParameters.sort !== undefined) {
      queryParameters['sort'] = requestParameters.sort;
    }

    if (requestParameters.since !== undefined) {
      queryParameters['since'] = (requestParameters.since as any).toISOString();
    }

    if (requestParameters.before !== undefined) {
      queryParameters['before'] = (
        requestParameters.before as any
      ).toISOString();
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['x-api-key'] = this.configuration.apiKey('x-api-key'); // API_KEY authentication
    }

    const response = await this.request(
      {
        path: `/connectors/{id}/events`.replace(
          `{${'id'}}`,
          encodeURIComponent(String(requestParameters.id))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      PageConnectorSyncEventsFromJSON(jsonValue)
    );
  }

  /**
   * Get an inbox connector sync events
   */
  async getConnectorSyncEvents(
    requestParameters: GetConnectorSyncEventsRequest,
    initOverrides?: RequestInit
  ): Promise<PageConnectorSyncEvents> {
    const response = await this.getConnectorSyncEventsRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * List inbox connectors that sync external emails to MailSlurp inboxes
   * Get inbox connectors
   */
  async getConnectorsRaw(
    requestParameters: GetConnectorsRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<PageConnector>> {
    const queryParameters: any = {};

    if (requestParameters.page !== undefined) {
      queryParameters['page'] = requestParameters.page;
    }

    if (requestParameters.size !== undefined) {
      queryParameters['size'] = requestParameters.size;
    }

    if (requestParameters.sort !== undefined) {
      queryParameters['sort'] = requestParameters.sort;
    }

    if (requestParameters.since !== undefined) {
      queryParameters['since'] = (requestParameters.since as any).toISOString();
    }

    if (requestParameters.before !== undefined) {
      queryParameters['before'] = (
        requestParameters.before as any
      ).toISOString();
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['x-api-key'] = this.configuration.apiKey('x-api-key'); // API_KEY authentication
    }

    const response = await this.request(
      {
        path: `/connectors`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      PageConnectorFromJSON(jsonValue)
    );
  }

  /**
   * List inbox connectors that sync external emails to MailSlurp inboxes
   * Get inbox connectors
   */
  async getConnectors(
    requestParameters: GetConnectorsRequest,
    initOverrides?: RequestInit
  ): Promise<PageConnector> {
    const response = await this.getConnectorsRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Sync an inbox connector
   */
  async syncConnectorRaw(
    requestParameters: SyncConnectorRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<ConnectorSyncRequestResult>> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        'id',
        'Required parameter requestParameters.id was null or undefined when calling syncConnector.'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['x-api-key'] = this.configuration.apiKey('x-api-key'); // API_KEY authentication
    }

    const response = await this.request(
      {
        path: `/connectors/{id}/sync`.replace(
          `{${'id'}}`,
          encodeURIComponent(String(requestParameters.id))
        ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      ConnectorSyncRequestResultFromJSON(jsonValue)
    );
  }

  /**
   * Sync an inbox connector
   */
  async syncConnector(
    requestParameters: SyncConnectorRequest,
    initOverrides?: RequestInit
  ): Promise<ConnectorSyncRequestResult> {
    const response = await this.syncConnectorRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Update an inbox connector
   */
  async updateConnectorRaw(
    requestParameters: UpdateConnectorRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<ConnectorDto>> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        'id',
        'Required parameter requestParameters.id was null or undefined when calling updateConnector.'
      );
    }

    if (
      requestParameters.createConnectorOptions === null ||
      requestParameters.createConnectorOptions === undefined
    ) {
      throw new runtime.RequiredError(
        'createConnectorOptions',
        'Required parameter requestParameters.createConnectorOptions was null or undefined when calling updateConnector.'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['x-api-key'] = this.configuration.apiKey('x-api-key'); // API_KEY authentication
    }

    const response = await this.request(
      {
        path: `/connectors/{id}`.replace(
          `{${'id'}}`,
          encodeURIComponent(String(requestParameters.id))
        ),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: CreateConnectorOptionsToJSON(
          requestParameters.createConnectorOptions
        ),
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      ConnectorDtoFromJSON(jsonValue)
    );
  }

  /**
   * Update an inbox connector
   */
  async updateConnector(
    requestParameters: UpdateConnectorRequest,
    initOverrides?: RequestInit
  ): Promise<ConnectorDto> {
    const response = await this.updateConnectorRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }
}

/**
 * @export
 * @enum {string}
 */
export enum GetAllConnectorSyncEventsSortEnum {
  ASC = 'ASC',
  DESC = 'DESC',
}
/**
 * @export
 * @enum {string}
 */
export enum GetConnectorSyncEventsSortEnum {
  ASC = 'ASC',
  DESC = 'DESC',
}
/**
 * @export
 * @enum {string}
 */
export enum GetConnectorsSortEnum {
  ASC = 'ASC',
  DESC = 'DESC',
}
