/* tslint:disable */
/* eslint-disable */
/**
 * MailSlurp API
 * MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It\'s designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from '../runtime';
import {
  ConnectorDto,
  ConnectorDtoFromJSON,
  ConnectorDtoToJSON,
  ConnectorImapConnectionDto,
  ConnectorImapConnectionDtoFromJSON,
  ConnectorImapConnectionDtoToJSON,
  ConnectorSmtpConnectionDto,
  ConnectorSmtpConnectionDtoFromJSON,
  ConnectorSmtpConnectionDtoToJSON,
  ConnectorSyncEventDto,
  ConnectorSyncEventDtoFromJSON,
  ConnectorSyncEventDtoToJSON,
  ConnectorSyncRequestResult,
  ConnectorSyncRequestResultFromJSON,
  ConnectorSyncRequestResultToJSON,
  CreateConnectorImapConnectionOptions,
  CreateConnectorImapConnectionOptionsFromJSON,
  CreateConnectorImapConnectionOptionsToJSON,
  CreateConnectorOptions,
  CreateConnectorOptionsFromJSON,
  CreateConnectorOptionsToJSON,
  CreateConnectorSmtpConnectionOptions,
  CreateConnectorSmtpConnectionOptionsFromJSON,
  CreateConnectorSmtpConnectionOptionsToJSON,
  PageConnector,
  PageConnectorFromJSON,
  PageConnectorToJSON,
  PageConnectorSyncEvents,
  PageConnectorSyncEventsFromJSON,
  PageConnectorSyncEventsToJSON,
} from '../models';

export interface CreateConnectorRequest {
  createConnectorOptions: CreateConnectorOptions;
}

export interface CreateConnectorImapConnectionRequest {
  id: string;
  createConnectorImapConnectionOptions: CreateConnectorImapConnectionOptions;
}

export interface CreateConnectorSmtpConnectionRequest {
  id: string;
  createConnectorSmtpConnectionOptions: CreateConnectorSmtpConnectionOptions;
}

export interface DeleteConnectorRequest {
  id: string;
}

export interface DeleteConnectorImapConnectionRequest {
  id: string;
}

export interface DeleteConnectorSmtpConnectionRequest {
  id: string;
}

export interface GetAllConnectorSyncEventsRequest {
  page?: number;
  size?: number;
  sort?: GetAllConnectorSyncEventsSortEnum;
  since?: Date;
  before?: Date;
}

export interface GetConnectorRequest {
  id: string;
}

export interface GetConnectorSyncEventRequest {
  id: string;
}

export interface GetConnectorSyncEventsRequest {
  id: string;
  page?: number;
  size?: number;
  sort?: GetConnectorSyncEventsSortEnum;
  since?: Date;
  before?: Date;
}

export interface GetConnectorsRequest {
  page?: number;
  size?: number;
  sort?: GetConnectorsSortEnum;
  since?: Date;
  before?: Date;
}

export interface SyncConnectorRequest {
  id: string;
}

export interface UpdateConnectorRequest {
  id: string;
  createConnectorOptions: CreateConnectorOptions;
}

/**
 *
 */
export class ConnectorControllerApi extends runtime.BaseAPI {
  /**
   * Sync emails between external mailboxes and MailSlurp inboxes
   * Create an inbox connector
   */
  async createConnectorRaw(
    requestParameters: CreateConnectorRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<ConnectorDto>> {
    if (
      requestParameters.createConnectorOptions === null ||
      requestParameters.createConnectorOptions === undefined
    ) {
      throw new runtime.RequiredError(
        'createConnectorOptions',
        'Required parameter requestParameters.createConnectorOptions was null or undefined when calling createConnector.'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['x-api-key'] = this.configuration.apiKey('x-api-key'); // API_KEY authentication
    }

    const response = await this.request(
      {
        path: `/connectors`,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: CreateConnectorOptionsToJSON(
          requestParameters.createConnectorOptions
        ),
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      ConnectorDtoFromJSON(jsonValue)
    );
  }

  /**
   * Sync emails between external mailboxes and MailSlurp inboxes
   * Create an inbox connector
   */
  async createConnector(
    requestParameters: CreateConnectorRequest,
    initOverrides?: RequestInit
  ): Promise<ConnectorDto> {
    const response = await this.createConnectorRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Allows the reading of emails in an external mailbox and syncing to a MailSlurp inbox
   * Create an inbox connector IMAP connection
   */
  async createConnectorImapConnectionRaw(
    requestParameters: CreateConnectorImapConnectionRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<ConnectorImapConnectionDto>> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        'id',
        'Required parameter requestParameters.id was null or undefined when calling createConnectorImapConnection.'
      );
    }

    if (
      requestParameters.createConnectorImapConnectionOptions === null ||
      requestParameters.createConnectorImapConnectionOptions === undefined
    ) {
      throw new runtime.RequiredError(
        'createConnectorImapConnectionOptions',
        'Required parameter requestParameters.createConnectorImapConnectionOptions was null or undefined when calling createConnectorImapConnection.'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['x-api-key'] = this.configuration.apiKey('x-api-key'); // API_KEY authentication
    }

    const response = await this.request(
      {
        path: `/connectors/{id}/imap`.replace(
          `{${'id'}}`,
          encodeURIComponent(String(requestParameters.id))
        ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: CreateConnectorImapConnectionOptionsToJSON(
          requestParameters.createConnectorImapConnectionOptions
        ),
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      ConnectorImapConnectionDtoFromJSON(jsonValue)
    );
  }

  /**
   * Allows the reading of emails in an external mailbox and syncing to a MailSlurp inbox
   * Create an inbox connector IMAP connection
   */
  async createConnectorImapConnection(
    requestParameters: CreateConnectorImapConnectionRequest,
    initOverrides?: RequestInit
  ): Promise<ConnectorImapConnectionDto> {
    const response = await this.createConnectorImapConnectionRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Allows sending via connector and email is routed to connected inbox and sent via SMTP
   * Create an inbox connector SMTP connection
   */
  async createConnectorSmtpConnectionRaw(
    requestParameters: CreateConnectorSmtpConnectionRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<ConnectorSmtpConnectionDto>> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        'id',
        'Required parameter requestParameters.id was null or undefined when calling createConnectorSmtpConnection.'
      );
    }

    if (
      requestParameters.createConnectorSmtpConnectionOptions === null ||
      requestParameters.createConnectorSmtpConnectionOptions === undefined
    ) {
      throw new runtime.RequiredError(
        'createConnectorSmtpConnectionOptions',
        'Required parameter requestParameters.createConnectorSmtpConnectionOptions was null or undefined when calling createConnectorSmtpConnection.'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['x-api-key'] = this.configuration.apiKey('x-api-key'); // API_KEY authentication
    }

    const response = await this.request(
      {
        path: `/connectors/{id}/smtp`.replace(
          `{${'id'}}`,
          encodeURIComponent(String(requestParameters.id))
        ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: CreateConnectorSmtpConnectionOptionsToJSON(
          requestParameters.createConnectorSmtpConnectionOptions
        ),
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      ConnectorSmtpConnectionDtoFromJSON(jsonValue)
    );
  }

  /**
   * Allows sending via connector and email is routed to connected inbox and sent via SMTP
   * Create an inbox connector SMTP connection
   */
  async createConnectorSmtpConnection(
    requestParameters: CreateConnectorSmtpConnectionRequest,
    initOverrides?: RequestInit
  ): Promise<ConnectorSmtpConnectionDto> {
    const response = await this.createConnectorSmtpConnectionRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Delete all inbox connectors
   */
  async deleteAllConnectorRaw(
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<void>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['x-api-key'] = this.configuration.apiKey('x-api-key'); // API_KEY authentication
    }

    const response = await this.request(
      {
        path: `/connectors`,
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Delete all inbox connectors
   */
  async deleteAllConnector(initOverrides?: RequestInit): Promise<void> {
    await this.deleteAllConnectorRaw(initOverrides);
  }

  /**
   * Delete an inbox connector
   */
  async deleteConnectorRaw(
    requestParameters: DeleteConnectorRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        'id',
        'Required parameter requestParameters.id was null or undefined when calling deleteConnector.'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['x-api-key'] = this.configuration.apiKey('x-api-key'); // API_KEY authentication
    }

    const response = await this.request(
      {
        path: `/connectors/{id}`.replace(
          `{${'id'}}`,
          encodeURIComponent(String(requestParameters.id))
        ),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Delete an inbox connector
   */
  async deleteConnector(
    requestParameters: DeleteConnectorRequest,
    initOverrides?: RequestInit
  ): Promise<void> {
    await this.deleteConnectorRaw(requestParameters, initOverrides);
  }

  /**
   * Delete IMAP connection for external inbox
   * Delete an inbox connector IMAP connection
   */
  async deleteConnectorImapConnectionRaw(
    requestParameters: DeleteConnectorImapConnectionRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        'id',
        'Required parameter requestParameters.id was null or undefined when calling deleteConnectorImapConnection.'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['x-api-key'] = this.configuration.apiKey('x-api-key'); // API_KEY authentication
    }

    const response = await this.request(
      {
        path: `/connectors/{id}/imap`.replace(
          `{${'id'}}`,
          encodeURIComponent(String(requestParameters.id))
        ),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Delete IMAP connection for external inbox
   * Delete an inbox connector IMAP connection
   */
  async deleteConnectorImapConnection(
    requestParameters: DeleteConnectorImapConnectionRequest,
    initOverrides?: RequestInit
  ): Promise<void> {
    await this.deleteConnectorImapConnectionRaw(
      requestParameters,
      initOverrides
    );
  }

  /**
   * Delete SMTP connection for external inbox
   * Delete an inbox connector SMTP connection
   */
  async deleteConnectorSmtpConnectionRaw(
    requestParameters: DeleteConnectorSmtpConnectionRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<void>> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        'id',
        'Required parameter requestParameters.id was null or undefined when calling deleteConnectorSmtpConnection.'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['x-api-key'] = this.configuration.apiKey('x-api-key'); // API_KEY authentication
    }

    const response = await this.request(
      {
        path: `/connectors/{id}/smtp`.replace(
          `{${'id'}}`,
          encodeURIComponent(String(requestParameters.id))
        ),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Delete SMTP connection for external inbox
   * Delete an inbox connector SMTP connection
   */
  async deleteConnectorSmtpConnection(
    requestParameters: DeleteConnectorSmtpConnectionRequest,
    initOverrides?: RequestInit
  ): Promise<void> {
    await this.deleteConnectorSmtpConnectionRaw(
      requestParameters,
      initOverrides
    );
  }

  /**
   * Get all inbox connector sync events
   */
  async getAllConnectorSyncEventsRaw(
    requestParameters: GetAllConnectorSyncEventsRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<PageConnectorSyncEvents>> {
    const queryParameters: any = {};

    if (requestParameters.page !== undefined) {
      queryParameters['page'] = requestParameters.page;
    }

    if (requestParameters.size !== undefined) {
      queryParameters['size'] = requestParameters.size;
    }

    if (requestParameters.sort !== undefined) {
      queryParameters['sort'] = requestParameters.sort;
    }

    if (requestParameters.since !== undefined) {
      queryParameters['since'] = (requestParameters.since as any).toISOString();
    }

    if (requestParameters.before !== undefined) {
      queryParameters['before'] = (
        requestParameters.before as any
      ).toISOString();
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['x-api-key'] = this.configuration.apiKey('x-api-key'); // API_KEY authentication
    }

    const response = await this.request(
      {
        path: `/connectors/events`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      PageConnectorSyncEventsFromJSON(jsonValue)
    );
  }

  /**
   * Get all inbox connector sync events
   */
  async getAllConnectorSyncEvents(
    requestParameters: GetAllConnectorSyncEventsRequest,
    initOverrides?: RequestInit
  ): Promise<PageConnectorSyncEvents> {
    const response = await this.getAllConnectorSyncEventsRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Get an inbox connector
   */
  async getConnectorRaw(
    requestParameters: GetConnectorRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<ConnectorDto>> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        'id',
        'Required parameter requestParameters.id was null or undefined when calling getConnector.'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['x-api-key'] = this.configuration.apiKey('x-api-key'); // API_KEY authentication
    }

    const response = await this.request(
      {
        path: `/connectors/{id}`.replace(
          `{${'id'}}`,
          encodeURIComponent(String(requestParameters.id))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      ConnectorDtoFromJSON(jsonValue)
    );
  }

  /**
   * Get an inbox connector
   */
  async getConnector(
    requestParameters: GetConnectorRequest,
    initOverrides?: RequestInit
  ): Promise<ConnectorDto> {
    const response = await this.getConnectorRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Get an inbox connector sync event
   */
  async getConnectorSyncEventRaw(
    requestParameters: GetConnectorSyncEventRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<ConnectorSyncEventDto>> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        'id',
        'Required parameter requestParameters.id was null or undefined when calling getConnectorSyncEvent.'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['x-api-key'] = this.configuration.apiKey('x-api-key'); // API_KEY authentication
    }

    const response = await this.request(
      {
        path: `/connectors/events/{id}`.replace(
          `{${'id'}}`,
          encodeURIComponent(String(requestParameters.id))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      ConnectorSyncEventDtoFromJSON(jsonValue)
    );
  }

  /**
   * Get an inbox connector sync event
   */
  async getConnectorSyncEvent(
    requestParameters: GetConnectorSyncEventRequest,
    initOverrides?: RequestInit
  ): Promise<ConnectorSyncEventDto> {
    const response = await this.getConnectorSyncEventRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Get an inbox connector sync events
   */
  async getConnectorSyncEventsRaw(
    requestParameters: GetConnectorSyncEventsRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<PageConnectorSyncEvents>> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        'id',
        'Required parameter requestParameters.id was null or undefined when calling getConnectorSyncEvents.'
      );
    }

    const queryParameters: any = {};

    if (requestParameters.page !== undefined) {
      queryParameters['page'] = requestParameters.page;
    }

    if (requestParameters.size !== undefined) {
      queryParameters['size'] = requestParameters.size;
    }

    if (requestParameters.sort !== undefined) {
      queryParameters['sort'] = requestParameters.sort;
    }

    if (requestParameters.since !== undefined) {
      queryParameters['since'] = (requestParameters.since as any).toISOString();
    }

    if (requestParameters.before !== undefined) {
      queryParameters['before'] = (
        requestParameters.before as any
      ).toISOString();
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['x-api-key'] = this.configuration.apiKey('x-api-key'); // API_KEY authentication
    }

    const response = await this.request(
      {
        path: `/connectors/{id}/events`.replace(
          `{${'id'}}`,
          encodeURIComponent(String(requestParameters.id))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      PageConnectorSyncEventsFromJSON(jsonValue)
    );
  }

  /**
   * Get an inbox connector sync events
   */
  async getConnectorSyncEvents(
    requestParameters: GetConnectorSyncEventsRequest,
    initOverrides?: RequestInit
  ): Promise<PageConnectorSyncEvents> {
    const response = await this.getConnectorSyncEventsRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * List inbox connectors that sync external emails to MailSlurp inboxes
   * Get inbox connectors
   */
  async getConnectorsRaw(
    requestParameters: GetConnectorsRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<PageConnector>> {
    const queryParameters: any = {};

    if (requestParameters.page !== undefined) {
      queryParameters['page'] = requestParameters.page;
    }

    if (requestParameters.size !== undefined) {
      queryParameters['size'] = requestParameters.size;
    }

    if (requestParameters.sort !== undefined) {
      queryParameters['sort'] = requestParameters.sort;
    }

    if (requestParameters.since !== undefined) {
      queryParameters['since'] = (requestParameters.since as any).toISOString();
    }

    if (requestParameters.before !== undefined) {
      queryParameters['before'] = (
        requestParameters.before as any
      ).toISOString();
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['x-api-key'] = this.configuration.apiKey('x-api-key'); // API_KEY authentication
    }

    const response = await this.request(
      {
        path: `/connectors`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      PageConnectorFromJSON(jsonValue)
    );
  }

  /**
   * List inbox connectors that sync external emails to MailSlurp inboxes
   * Get inbox connectors
   */
  async getConnectors(
    requestParameters: GetConnectorsRequest,
    initOverrides?: RequestInit
  ): Promise<PageConnector> {
    const response = await this.getConnectorsRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Sync an inbox connector
   */
  async syncConnectorRaw(
    requestParameters: SyncConnectorRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<ConnectorSyncRequestResult>> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        'id',
        'Required parameter requestParameters.id was null or undefined when calling syncConnector.'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['x-api-key'] = this.configuration.apiKey('x-api-key'); // API_KEY authentication
    }

    const response = await this.request(
      {
        path: `/connectors/{id}/sync`.replace(
          `{${'id'}}`,
          encodeURIComponent(String(requestParameters.id))
        ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      ConnectorSyncRequestResultFromJSON(jsonValue)
    );
  }

  /**
   * Sync an inbox connector
   */
  async syncConnector(
    requestParameters: SyncConnectorRequest,
    initOverrides?: RequestInit
  ): Promise<ConnectorSyncRequestResult> {
    const response = await this.syncConnectorRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Update an inbox connector
   */
  async updateConnectorRaw(
    requestParameters: UpdateConnectorRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<ConnectorDto>> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
      throw new runtime.RequiredError(
        'id',
        'Required parameter requestParameters.id was null or undefined when calling updateConnector.'
      );
    }

    if (
      requestParameters.createConnectorOptions === null ||
      requestParameters.createConnectorOptions === undefined
    ) {
      throw new runtime.RequiredError(
        'createConnectorOptions',
        'Required parameter requestParameters.createConnectorOptions was null or undefined when calling updateConnector.'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['x-api-key'] = this.configuration.apiKey('x-api-key'); // API_KEY authentication
    }

    const response = await this.request(
      {
        path: `/connectors/{id}`.replace(
          `{${'id'}}`,
          encodeURIComponent(String(requestParameters.id))
        ),
        method: 'PUT',
        headers: headerParameters,
        query: queryParameters,
        body: CreateConnectorOptionsToJSON(
          requestParameters.createConnectorOptions
        ),
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      ConnectorDtoFromJSON(jsonValue)
    );
  }

  /**
   * Update an inbox connector
   */
  async updateConnector(
    requestParameters: UpdateConnectorRequest,
    initOverrides?: RequestInit
  ): Promise<ConnectorDto> {
    const response = await this.updateConnectorRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }
}

/**
 * @export
 * @enum {string}
 */
export enum GetAllConnectorSyncEventsSortEnum {
  ASC = 'ASC',
  DESC = 'DESC',
}
/**
 * @export
 * @enum {string}
 */
export enum GetConnectorSyncEventsSortEnum {
  ASC = 'ASC',
  DESC = 'DESC',
}
/**
 * @export
 * @enum {string}
 */
export enum GetConnectorsSortEnum {
  ASC = 'ASC',
  DESC = 'DESC',
}
