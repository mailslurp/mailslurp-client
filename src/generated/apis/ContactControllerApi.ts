/* tslint:disable */
/* eslint-disable */
/**
 * MailSlurp API
 * MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It\'s designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://www.mailslurp.com/docs/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from '../runtime';
import {
  ContactDto,
  ContactDtoFromJSON,
  ContactDtoToJSON,
  ContactProjection,
  ContactProjectionFromJSON,
  ContactProjectionToJSON,
  CreateContactOptions,
  CreateContactOptionsFromJSON,
  CreateContactOptionsToJSON,
  PageContactProjection,
  PageContactProjectionFromJSON,
  PageContactProjectionToJSON,
} from '../models';

export interface CreateContactRequest {
  createContactOptions: CreateContactOptions;
}

export interface DeleteContactRequest {
  contactId: string;
}

export interface GetAllContactsRequest {
  page?: number;
  size?: number;
  sort?: GetAllContactsSortEnum;
  since?: Date;
  before?: Date;
}

export interface GetContactRequest {
  contactId: string;
}

export interface GetContactVCardRequest {
  contactId: string;
}

/**
 *
 */
export class ContactControllerApi extends runtime.BaseAPI {
  /**
   * Create a contact
   */
  async createContactRaw(
    requestParameters: CreateContactRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<ContactDto>> {
    if (
      requestParameters.createContactOptions === null ||
      requestParameters.createContactOptions === undefined
    ) {
      throw new runtime.RequiredError(
        'createContactOptions',
        'Required parameter requestParameters.createContactOptions was null or undefined when calling createContact.'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['x-api-key'] = this.configuration.apiKey('x-api-key'); // API_KEY authentication
    }

    const response = await this.request(
      {
        path: `/contacts`,
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: CreateContactOptionsToJSON(
          requestParameters.createContactOptions
        ),
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      ContactDtoFromJSON(jsonValue)
    );
  }

  /**
   * Create a contact
   */
  async createContact(
    requestParameters: CreateContactRequest,
    initOverrides?: RequestInit
  ): Promise<ContactDto> {
    const response = await this.createContactRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Delete contact
   */
  async deleteContactRaw(
    requestParameters: DeleteContactRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.contactId === null ||
      requestParameters.contactId === undefined
    ) {
      throw new runtime.RequiredError(
        'contactId',
        'Required parameter requestParameters.contactId was null or undefined when calling deleteContact.'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['x-api-key'] = this.configuration.apiKey('x-api-key'); // API_KEY authentication
    }

    const response = await this.request(
      {
        path: `/contacts/{contactId}`.replace(
          `{${'contactId'}}`,
          encodeURIComponent(String(requestParameters.contactId))
        ),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Delete contact
   */
  async deleteContact(
    requestParameters: DeleteContactRequest,
    initOverrides?: RequestInit
  ): Promise<void> {
    await this.deleteContactRaw(requestParameters, initOverrides);
  }

  /**
   * Get all contacts
   */
  async getAllContactsRaw(
    requestParameters: GetAllContactsRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<PageContactProjection>> {
    const queryParameters: any = {};

    if (requestParameters.page !== undefined) {
      queryParameters['page'] = requestParameters.page;
    }

    if (requestParameters.size !== undefined) {
      queryParameters['size'] = requestParameters.size;
    }

    if (requestParameters.sort !== undefined) {
      queryParameters['sort'] = requestParameters.sort;
    }

    if (requestParameters.since !== undefined) {
      queryParameters['since'] = (requestParameters.since as any).toISOString();
    }

    if (requestParameters.before !== undefined) {
      queryParameters['before'] = (
        requestParameters.before as any
      ).toISOString();
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['x-api-key'] = this.configuration.apiKey('x-api-key'); // API_KEY authentication
    }

    const response = await this.request(
      {
        path: `/contacts/paginated`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      PageContactProjectionFromJSON(jsonValue)
    );
  }

  /**
   * Get all contacts
   */
  async getAllContacts(
    requestParameters: GetAllContactsRequest,
    initOverrides?: RequestInit
  ): Promise<PageContactProjection> {
    const response = await this.getAllContactsRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Get contact
   */
  async getContactRaw(
    requestParameters: GetContactRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<ContactDto>> {
    if (
      requestParameters.contactId === null ||
      requestParameters.contactId === undefined
    ) {
      throw new runtime.RequiredError(
        'contactId',
        'Required parameter requestParameters.contactId was null or undefined when calling getContact.'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['x-api-key'] = this.configuration.apiKey('x-api-key'); // API_KEY authentication
    }

    const response = await this.request(
      {
        path: `/contacts/{contactId}`.replace(
          `{${'contactId'}}`,
          encodeURIComponent(String(requestParameters.contactId))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      ContactDtoFromJSON(jsonValue)
    );
  }

  /**
   * Get contact
   */
  async getContact(
    requestParameters: GetContactRequest,
    initOverrides?: RequestInit
  ): Promise<ContactDto> {
    const response = await this.getContactRaw(requestParameters, initOverrides);
    return await response.value();
  }

  /**
   * Get contact vCard vcf file
   */
  async getContactVCardRaw(
    requestParameters: GetContactVCardRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<Array<string>>> {
    if (
      requestParameters.contactId === null ||
      requestParameters.contactId === undefined
    ) {
      throw new runtime.RequiredError(
        'contactId',
        'Required parameter requestParameters.contactId was null or undefined when calling getContactVCard.'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['x-api-key'] = this.configuration.apiKey('x-api-key'); // API_KEY authentication
    }

    const response = await this.request(
      {
        path: `/contacts/{contactId}/download`.replace(
          `{${'contactId'}}`,
          encodeURIComponent(String(requestParameters.contactId))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse<any>(response);
  }

  /**
   * Get contact vCard vcf file
   */
  async getContactVCard(
    requestParameters: GetContactVCardRequest,
    initOverrides?: RequestInit
  ): Promise<Array<string>> {
    const response = await this.getContactVCardRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Get all contacts
   */
  async getContactsRaw(
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<Array<ContactProjection>>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['x-api-key'] = this.configuration.apiKey('x-api-key'); // API_KEY authentication
    }

    const response = await this.request(
      {
        path: `/contacts`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      jsonValue.map(ContactProjectionFromJSON)
    );
  }

  /**
   * Get all contacts
   */
  async getContacts(
    initOverrides?: RequestInit
  ): Promise<Array<ContactProjection>> {
    const response = await this.getContactsRaw(initOverrides);
    return await response.value();
  }
}

/**
 * @export
 * @enum {string}
 */
export enum GetAllContactsSortEnum {
  ASC = 'ASC',
  DESC = 'DESC',
}
