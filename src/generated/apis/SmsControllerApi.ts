/* tslint:disable */
/* eslint-disable */
/**
 * MailSlurp API
 * MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It\'s designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from '../runtime';
import {
  PageSmsProjection,
  PageSmsProjectionFromJSON,
  PageSmsProjectionToJSON,
  ReplyForSms,
  ReplyForSmsFromJSON,
  ReplyForSmsToJSON,
  SentSmsDto,
  SentSmsDtoFromJSON,
  SentSmsDtoToJSON,
  SmsDto,
  SmsDtoFromJSON,
  SmsDtoToJSON,
  SmsReplyOptions,
  SmsReplyOptionsFromJSON,
  SmsReplyOptionsToJSON,
  UnreadCount,
  UnreadCountFromJSON,
  UnreadCountToJSON,
} from '../models';

export interface DeleteSmsMessageRequest {
  smsId: string;
}

export interface DeleteSmsMessagesRequest {
  phoneNumberId?: string;
}

export interface GetReplyForSmsMessageRequest {
  smsId: string;
}

export interface GetSmsMessageRequest {
  smsId: string;
}

export interface GetSmsMessagesPaginatedRequest {
  phoneNumber?: string;
  page?: number;
  size?: number;
  sort?: GetSmsMessagesPaginatedSortEnum;
  unreadOnly?: boolean;
  since?: Date;
  before?: Date;
}

export interface ReplyToSmsMessageRequest {
  smsId: string;
  smsReplyOptions: SmsReplyOptions;
}

/**
 *
 */
export class SmsControllerApi extends runtime.BaseAPI {
  /**
   * Delete an SMS message
   * Delete SMS message.
   */
  async deleteSmsMessageRaw(
    requestParameters: DeleteSmsMessageRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<void>> {
    if (
      requestParameters.smsId === null ||
      requestParameters.smsId === undefined
    ) {
      throw new runtime.RequiredError(
        'smsId',
        'Required parameter requestParameters.smsId was null or undefined when calling deleteSmsMessage.'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['x-api-key'] = this.configuration.apiKey('x-api-key'); // API_KEY authentication
    }

    const response = await this.request(
      {
        path: `/sms/{smsId}`.replace(
          `{${'smsId'}}`,
          encodeURIComponent(String(requestParameters.smsId))
        ),
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Delete an SMS message
   * Delete SMS message.
   */
  async deleteSmsMessage(
    requestParameters: DeleteSmsMessageRequest,
    initOverrides?: RequestInit
  ): Promise<void> {
    await this.deleteSmsMessageRaw(requestParameters, initOverrides);
  }

  /**
   * Delete all SMS messages or all messages for a given phone number
   * Delete all SMS messages
   */
  async deleteSmsMessagesRaw(
    requestParameters: DeleteSmsMessagesRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<void>> {
    const queryParameters: any = {};

    if (requestParameters.phoneNumberId !== undefined) {
      queryParameters['phoneNumberId'] = requestParameters.phoneNumberId;
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['x-api-key'] = this.configuration.apiKey('x-api-key'); // API_KEY authentication
    }

    const response = await this.request(
      {
        path: `/sms`,
        method: 'DELETE',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.VoidApiResponse(response);
  }

  /**
   * Delete all SMS messages or all messages for a given phone number
   * Delete all SMS messages
   */
  async deleteSmsMessages(
    requestParameters: DeleteSmsMessagesRequest,
    initOverrides?: RequestInit
  ): Promise<void> {
    await this.deleteSmsMessagesRaw(requestParameters, initOverrides);
  }

  /**
   * Get reply for an SMS message.
   * Get reply for an SMS message
   */
  async getReplyForSmsMessageRaw(
    requestParameters: GetReplyForSmsMessageRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<ReplyForSms>> {
    if (
      requestParameters.smsId === null ||
      requestParameters.smsId === undefined
    ) {
      throw new runtime.RequiredError(
        'smsId',
        'Required parameter requestParameters.smsId was null or undefined when calling getReplyForSmsMessage.'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['x-api-key'] = this.configuration.apiKey('x-api-key'); // API_KEY authentication
    }

    const response = await this.request(
      {
        path: `/sms/{smsId}/reply`.replace(
          `{${'smsId'}}`,
          encodeURIComponent(String(requestParameters.smsId))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      ReplyForSmsFromJSON(jsonValue)
    );
  }

  /**
   * Get reply for an SMS message.
   * Get reply for an SMS message
   */
  async getReplyForSmsMessage(
    requestParameters: GetReplyForSmsMessageRequest,
    initOverrides?: RequestInit
  ): Promise<ReplyForSms> {
    const response = await this.getReplyForSmsMessageRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Returns a SMS summary object with content.
   * Get SMS content including body. Expects SMS to exist by ID. For SMS that may not have arrived yet use the WaitForController.
   */
  async getSmsMessageRaw(
    requestParameters: GetSmsMessageRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<SmsDto>> {
    if (
      requestParameters.smsId === null ||
      requestParameters.smsId === undefined
    ) {
      throw new runtime.RequiredError(
        'smsId',
        'Required parameter requestParameters.smsId was null or undefined when calling getSmsMessage.'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['x-api-key'] = this.configuration.apiKey('x-api-key'); // API_KEY authentication
    }

    const response = await this.request(
      {
        path: `/sms/{smsId}`.replace(
          `{${'smsId'}}`,
          encodeURIComponent(String(requestParameters.smsId))
        ),
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      SmsDtoFromJSON(jsonValue)
    );
  }

  /**
   * Returns a SMS summary object with content.
   * Get SMS content including body. Expects SMS to exist by ID. For SMS that may not have arrived yet use the WaitForController.
   */
  async getSmsMessage(
    requestParameters: GetSmsMessageRequest,
    initOverrides?: RequestInit
  ): Promise<SmsDto> {
    const response = await this.getSmsMessageRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * By default returns all SMS messages across all phone numbers sorted by ascending created at date. Responses are paginated. You can restrict results to a list of phone number IDs. You can also filter out read messages
   * Get all SMS messages in all phone numbers in paginated form. .
   */
  async getSmsMessagesPaginatedRaw(
    requestParameters: GetSmsMessagesPaginatedRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<PageSmsProjection>> {
    const queryParameters: any = {};

    if (requestParameters.phoneNumber !== undefined) {
      queryParameters['phoneNumber'] = requestParameters.phoneNumber;
    }

    if (requestParameters.page !== undefined) {
      queryParameters['page'] = requestParameters.page;
    }

    if (requestParameters.size !== undefined) {
      queryParameters['size'] = requestParameters.size;
    }

    if (requestParameters.sort !== undefined) {
      queryParameters['sort'] = requestParameters.sort;
    }

    if (requestParameters.unreadOnly !== undefined) {
      queryParameters['unreadOnly'] = requestParameters.unreadOnly;
    }

    if (requestParameters.since !== undefined) {
      queryParameters['since'] = (requestParameters.since as any).toISOString();
    }

    if (requestParameters.before !== undefined) {
      queryParameters['before'] = (
        requestParameters.before as any
      ).toISOString();
    }

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['x-api-key'] = this.configuration.apiKey('x-api-key'); // API_KEY authentication
    }

    const response = await this.request(
      {
        path: `/sms`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      PageSmsProjectionFromJSON(jsonValue)
    );
  }

  /**
   * By default returns all SMS messages across all phone numbers sorted by ascending created at date. Responses are paginated. You can restrict results to a list of phone number IDs. You can also filter out read messages
   * Get all SMS messages in all phone numbers in paginated form. .
   */
  async getSmsMessagesPaginated(
    requestParameters: GetSmsMessagesPaginatedRequest,
    initOverrides?: RequestInit
  ): Promise<PageSmsProjection> {
    const response = await this.getSmsMessagesPaginatedRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }

  /**
   * Get number of SMS unread. Unread means has not been viewed in dashboard or returned in an email API response
   * Get unread SMS count
   */
  async getUnreadSmsCountRaw(
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<UnreadCount>> {
    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['x-api-key'] = this.configuration.apiKey('x-api-key'); // API_KEY authentication
    }

    const response = await this.request(
      {
        path: `/sms/unreadCount`,
        method: 'GET',
        headers: headerParameters,
        query: queryParameters,
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      UnreadCountFromJSON(jsonValue)
    );
  }

  /**
   * Get number of SMS unread. Unread means has not been viewed in dashboard or returned in an email API response
   * Get unread SMS count
   */
  async getUnreadSmsCount(initOverrides?: RequestInit): Promise<UnreadCount> {
    const response = await this.getUnreadSmsCountRaw(initOverrides);
    return await response.value();
  }

  /**
   * Reply to an SMS message.
   * Send a reply to a received SMS message. Replies are sent from the receiving number.
   */
  async replyToSmsMessageRaw(
    requestParameters: ReplyToSmsMessageRequest,
    initOverrides?: RequestInit
  ): Promise<runtime.ApiResponse<SentSmsDto>> {
    if (
      requestParameters.smsId === null ||
      requestParameters.smsId === undefined
    ) {
      throw new runtime.RequiredError(
        'smsId',
        'Required parameter requestParameters.smsId was null or undefined when calling replyToSmsMessage.'
      );
    }

    if (
      requestParameters.smsReplyOptions === null ||
      requestParameters.smsReplyOptions === undefined
    ) {
      throw new runtime.RequiredError(
        'smsReplyOptions',
        'Required parameter requestParameters.smsReplyOptions was null or undefined when calling replyToSmsMessage.'
      );
    }

    const queryParameters: any = {};

    const headerParameters: runtime.HTTPHeaders = {};

    headerParameters['Content-Type'] = 'application/json';

    if (this.configuration && this.configuration.apiKey) {
      headerParameters['x-api-key'] = this.configuration.apiKey('x-api-key'); // API_KEY authentication
    }

    const response = await this.request(
      {
        path: `/sms/{smsId}/reply`.replace(
          `{${'smsId'}}`,
          encodeURIComponent(String(requestParameters.smsId))
        ),
        method: 'POST',
        headers: headerParameters,
        query: queryParameters,
        body: SmsReplyOptionsToJSON(requestParameters.smsReplyOptions),
      },
      initOverrides
    );

    return new runtime.JSONApiResponse(response, (jsonValue) =>
      SentSmsDtoFromJSON(jsonValue)
    );
  }

  /**
   * Reply to an SMS message.
   * Send a reply to a received SMS message. Replies are sent from the receiving number.
   */
  async replyToSmsMessage(
    requestParameters: ReplyToSmsMessageRequest,
    initOverrides?: RequestInit
  ): Promise<SentSmsDto> {
    const response = await this.replyToSmsMessageRaw(
      requestParameters,
      initOverrides
    );
    return await response.value();
  }
}

/**
 * @export
 * @enum {string}
 */
export enum GetSmsMessagesPaginatedSortEnum {
  ASC = 'ASC',
  DESC = 'DESC',
}
